{
  "dotnet-api/code/EventStore.ClientAPI.EventReadResult.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.EventReadResult.html",
    "title": "Class EventReadResult | Event Store",
    "keywords": "Class EventReadResult A event read result is the result of a single event read operation to Event Store. Inheritance System.Object EventReadResult Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class EventReadResult Fields Event The event read represented as ResolvedEvent . Declaration public readonly ResolvedEvent? Event Field Value Type System.Nullable < ResolvedEvent > EventNumber The event number of the requested event. Declaration public readonly long EventNumber Field Value Type System.Int64 Status The EventReadStatus representing the status of this read attempt. Declaration public readonly EventReadStatus Status Field Value Type EventReadStatus Stream The name of the stream read. Declaration public readonly string Stream Field Value Type System.String"
  },
  "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptions.PersistentSubscriptionDetails.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptions.PersistentSubscriptionDetails.html",
    "title": "Class PersistentSubscriptionDetails | Event Store",
    "keywords": "Class PersistentSubscriptionDetails Details for a Persistent Subscription. Inheritance System.Object PersistentSubscriptionDetails Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.PersistentSubscriptions Assembly : EventStore.ClientAPI.dll Syntax public sealed class PersistentSubscriptionDetails Properties AverageItemsPerSecond Average items per second (count). Declaration public decimal AverageItemsPerSecond { get; set; } Property Value Type System.Decimal Config Configuration of persistent subscription. Declaration public PersistentSubscriptionConfigDetails Config { get; set; } Property Value Type PersistentSubscriptionConfigDetails Remarks Only populated when retrieved via Describe(String, String, UserCredentials) method. Connections List of current connections on this persistent subscription . Declaration public List<PersistentSubscriptionConnectionDetails> Connections { get; set; } Property Value Type System.Collections.Generic.List < PersistentSubscriptionConnectionDetails > Remarks Only populated when retrieved via Describe(String, String, UserCredentials) method. CountSinceLastMeasurement Number of items seen since last measurement on this connection (used as the basis for AverageItemsPerSecond ). Declaration public long CountSinceLastMeasurement { get; set; } Property Value Type System.Int64 EventStreamId Target stream that refers to this subscription. Declaration public string EventStreamId { get; set; } Property Value Type System.String GetMessagesUri Messages URI. Declaration public string GetMessagesUri { get; set; } Property Value Type System.String GroupName The persistent subscription name. Declaration public string GroupName { get; set; } Property Value Type System.String LastKnownEventNumber Last checkpointed target stream version. Declaration public long LastKnownEventNumber { get; set; } Property Value Type System.Int64 LastProcessedEventNumber Last processed target stream version. Declaration public long LastProcessedEventNumber { get; set; } Property Value Type System.Int64 LiveBufferCount Live buffer count. Declaration public long LiveBufferCount { get; set; } Property Value Type System.Int64 ParkedMessageUri Parked message stream URI. Declaration public string ParkedMessageUri { get; set; } Property Value Type System.String ReadBufferCount Read buffer count. Declaration public int ReadBufferCount { get; set; } Property Value Type System.Int32 RetryBufferCount Retry buffer count. Declaration public int RetryBufferCount { get; set; } Property Value Type System.Int32 Status Current status. Declaration public string Status { get; set; } Property Value Type System.String TotalInFlightMessages Current in flight messages across all connections. Declaration public int TotalInFlightMessages { get; set; } Property Value Type System.Int32 TotalItemsProcessed Total items processed (count). Declaration public long TotalItemsProcessed { get; set; } Property Value Type System.Int64"
  },
  "dotnet-api/code/EventStore.ClientAPI.StreamPosition.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.StreamPosition.html",
    "title": "Class StreamPosition | Event Store",
    "keywords": "Class StreamPosition Constants for stream positions Inheritance System.Object StreamPosition Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public static class StreamPosition Fields End The last event in the stream. Declaration public const int End = -1 Field Value Type System.Int32 Start The first event in a stream Declaration public const int Start = 0 Field Value Type System.Int32"
  },
  "dotnet-api/code/EventStore.ClientAPI.ConditionalWriteResult.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ConditionalWriteResult.html",
    "title": "Struct ConditionalWriteResult | Event Store",
    "keywords": "Struct ConditionalWriteResult Result type returned after conditionally writing to a stream. Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public struct ConditionalWriteResult Constructors ConditionalWriteResult(ConditionalWriteStatus) Constructs a new WriteResult . Declaration public ConditionalWriteResult(ConditionalWriteStatus status) Parameters Type Name ConditionalWriteStatus status ConditionalWriteResult(Int64, Position) Constructs a new WriteResult . Declaration public ConditionalWriteResult(long nextExpectedVersion, Position logPosition) Parameters Type Name System.Int64 nextExpectedVersion Position logPosition Fields LogPosition The LogPosition of the write. Declaration public readonly Position? LogPosition Field Value Type System.Nullable < Position > NextExpectedVersion The next expected version for the stream. Declaration public readonly long? NextExpectedVersion Field Value Type System.Nullable < System.Int64 > Status Returns if the write was successful. Declaration public readonly ConditionalWriteStatus Status Field Value Type ConditionalWriteStatus"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.InvalidTransactionException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.InvalidTransactionException.html",
    "title": "Class InvalidTransactionException | Event Store",
    "keywords": "Class InvalidTransactionException Exception thrown if there is an attempt to operate inside a transaction which does not exist. Inheritance System.Object System.Exception EventStoreConnectionException InvalidTransactionException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class InvalidTransactionException : EventStoreConnectionException, ISerializable Constructors InvalidTransactionException() Constructs a new InvalidTransactionException . Declaration public InvalidTransactionException() InvalidTransactionException(SerializationInfo, StreamingContext) Constructs a new InvalidTransactionException . Declaration protected InvalidTransactionException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context InvalidTransactionException(String) Constructs a new InvalidTransactionException . Declaration public InvalidTransactionException(string message) Parameters Type Name System.String message InvalidTransactionException(String, Exception) Constructs a new InvalidTransactionException . Declaration public InvalidTransactionException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.RecordedEvent.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.RecordedEvent.html",
    "title": "Class RecordedEvent | Event Store",
    "keywords": "Class RecordedEvent Represents a previously written event Inheritance System.Object RecordedEvent Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class RecordedEvent Fields Created A datetime representing when this event was created in the system Declaration public DateTime Created Field Value Type System.DateTime CreatedEpoch A long representing the milliseconds since the epoch when the was created in the system Declaration public long CreatedEpoch Field Value Type System.Int64 Data A byte array representing the data of this event Declaration public readonly byte[] Data Field Value Type System.Byte [] EventId The Unique Identifier representing this event Declaration public readonly Guid EventId Field Value Type System.Guid EventNumber The number of this event in the stream Declaration public readonly long EventNumber Field Value Type System.Int64 EventStreamId The Event Stream that this event belongs to Declaration public readonly string EventStreamId Field Value Type System.String EventType The type of event this is Declaration public readonly string EventType Field Value Type System.String IsJson Indicates whether the content is internally marked as json Declaration public readonly bool IsJson Field Value Type System.Boolean Metadata A byte array representing the metadata associated with this event Declaration public readonly byte[] Metadata Field Value Type System.Byte []"
  },
  "dotnet-api/code/EventStore.ClientAPI.EventStoreTransaction.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.EventStoreTransaction.html",
    "title": "Class EventStoreTransaction | Event Store",
    "keywords": "Class EventStoreTransaction Represents a multi-request transaction with the Event Store Inheritance System.Object EventStoreTransaction Implements System.IDisposable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class EventStoreTransaction : IDisposable Fields TransactionId The ID of the transaction. This can be used to recover a transaction later. Declaration public readonly long TransactionId Field Value Type System.Int64 Methods CommitAsync() Asynchronously commits this transaction Declaration public Task<WriteResult> CommitAsync() Returns Type Description System.Threading.Tasks.Task < WriteResult > A System.Threading.Tasks.Task that returns expected version for following write requests Dispose() Disposes this transaction rolling it back if not already committed Declaration public void Dispose() Rollback() Rollsback this transaction. Declaration public void Rollback() WriteAsync(EventData[]) Writes to a transaction in the event store asynchronously Declaration public Task WriteAsync(params EventData[] events) Parameters Type Name EventData [] events Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task allowing the caller to control the async operation WriteAsync(IEnumerable<EventData>) Writes to a transaction in the event store asynchronously Declaration public Task WriteAsync(IEnumerable<EventData> events) Parameters Type Name System.Collections.Generic.IEnumerable < EventData > events Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task allowing the caller to control the async operation Implements System.IDisposable"
  },
  "dotnet-api/code/EventStore.ClientAPI.Common.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Common.html",
    "title": "Namespace EventStore.ClientAPI.Common | Event Store",
    "keywords": "Namespace EventStore.ClientAPI.Common Classes SystemConsumerStrategies System supported consumer strategies for use with persistent subscriptions. SystemEventTypes Constants for System event types SystemMetadata Constants for information in stream metadata"
  },
  "dotnet-api/code/EventStore.ClientAPI.ClusterSettingsBuilder.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ClusterSettingsBuilder.html",
    "title": "Class ClusterSettingsBuilder | Event Store",
    "keywords": "Class ClusterSettingsBuilder Builder used for creating instances of ClusterSettings. Inheritance System.Object ClusterSettingsBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class ClusterSettingsBuilder Methods DiscoverClusterViaDns() Sets the client to discover nodes using a DNS name and a well-known port. Declaration public DnsClusterSettingsBuilder DiscoverClusterViaDns() Returns Type Description DnsClusterSettingsBuilder A DnsClusterSettingsBuilder for further configuration. DiscoverClusterViaGossipSeeds() Sets the client to discover cluster nodes by specifying the IP endpoints of one or more of the nodes. Declaration public GossipSeedClusterSettingsBuilder DiscoverClusterViaGossipSeeds() Returns Type Description GossipSeedClusterSettingsBuilder"
  },
  "dotnet-api/code/EventStore.ClientAPI.Transport.Http.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Transport.Http.html",
    "title": "Namespace EventStore.ClientAPI.Transport.Http | Event Store",
    "keywords": "Namespace EventStore.ClientAPI.Transport.Http Classes HttpAsyncClient HttpResponse Interfaces IHttpClient"
  },
  "dotnet-api/code/EventStore.ClientAPI.StreamAcl.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.StreamAcl.html",
    "title": "Class StreamAcl | Event Store",
    "keywords": "Class StreamAcl Represents an access control list for a stream Inheritance System.Object StreamAcl Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class StreamAcl Constructors StreamAcl(String, String, String, String, String) Creates a new Stream Access Control List Declaration public StreamAcl(string readRole, string writeRole, string deleteRole, string metaReadRole, string metaWriteRole) Parameters Type Name System.String readRole System.String writeRole System.String deleteRole System.String metaReadRole System.String metaWriteRole StreamAcl(String[], String[], String[], String[], String[]) Declaration public StreamAcl(string[] readRoles, string[] writeRoles, string[] deleteRoles, string[] metaReadRoles, string[] metaWriteRoles) Parameters Type Name System.String [] readRoles System.String [] writeRoles System.String [] deleteRoles System.String [] metaReadRoles System.String [] metaWriteRoles Fields DeleteRoles Roles and users permitted to delete the stream Declaration public readonly string[] DeleteRoles Field Value Type System.String [] MetaReadRoles Roles and users permitted to read stream metadata Declaration public readonly string[] MetaReadRoles Field Value Type System.String [] MetaWriteRoles Roles and users permitted to write stream metadata Declaration public readonly string[] MetaWriteRoles Field Value Type System.String [] ReadRoles Roles and users permitted to read the stream Declaration public readonly string[] ReadRoles Field Value Type System.String [] WriteRoles Roles and users permitted to write to the stream Declaration public readonly string[] WriteRoles Field Value Type System.String [] Properties DeleteRole Role or user permitted to delete from the stream Declaration public string DeleteRole { get; } Property Value Type System.String MetaReadRole Role or user permitted to read the stream metadata Declaration public string MetaReadRole { get; } Property Value Type System.String MetaWriteRole Role or user permitted to write to the stream metadata Declaration public string MetaWriteRole { get; } Property Value Type System.String ReadRole Role or user permitted to read the stream Declaration public string ReadRole { get; } Property Value Type System.String WriteRole Role or user permitted to write to the stream Declaration public string WriteRole { get; } Property Value Type System.String Methods ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description System.String A string that represents the current object. Overrides System.Object.ToString()"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.ProjectionCommandFailedException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.ProjectionCommandFailedException.html",
    "title": "Class ProjectionCommandFailedException | Event Store",
    "keywords": "Class ProjectionCommandFailedException Exception thrown if a projection command fails. Inheritance System.Object System.Exception EventStoreConnectionException ProjectionCommandFailedException ProjectionCommandConflictException UserCommandConflictException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class ProjectionCommandFailedException : EventStoreConnectionException, ISerializable Constructors ProjectionCommandFailedException() Constructs a new ProjectionCommandFailedException . Declaration public ProjectionCommandFailedException() ProjectionCommandFailedException(Int32, String) Constructs a new ProjectionCommandFailedException . Declaration public ProjectionCommandFailedException(int httpStatusCode, string message) Parameters Type Name System.Int32 httpStatusCode System.String message ProjectionCommandFailedException(SerializationInfo, StreamingContext) Constructs a new ProjectionCommandFailedException . Declaration protected ProjectionCommandFailedException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context ProjectionCommandFailedException(String, Exception) Constructs a new ProjectionCommandFailedException . Declaration public ProjectionCommandFailedException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Properties HttpStatusCode The Http status code returned by the server Declaration public int HttpStatusCode { get; } Property Value Type System.Int32 Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.AllCheckpoint.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.AllCheckpoint.html",
    "title": "Class AllCheckpoint | Event Store",
    "keywords": "Class AllCheckpoint This class contains constants to be used when setting up subscriptions using the IEventStoreConnection.SubscribeToAllFrom method on IEventStoreConnection . Inheritance System.Object AllCheckpoint Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public static class AllCheckpoint Fields AllStart Indicates that a catch-up subscription should receive all events in the database. Declaration public static Position? AllStart Field Value Type System.Nullable < Position >"
  },
  "dotnet-api/code/EventStore.ClientAPI.Transport.Http.IHttpClient.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Transport.Http.IHttpClient.html",
    "title": "Interface IHttpClient | Event Store",
    "keywords": "Interface IHttpClient Namespace : EventStore.ClientAPI.Transport.Http Assembly : EventStore.ClientAPI.dll Syntax public interface IHttpClient Methods Delete(String, UserCredentials, Action<HttpResponse>, Action<Exception>) Declaration void Delete(string url, UserCredentials userCredentials, Action<HttpResponse> onSuccess, Action<Exception> onException) Parameters Type Name System.String url UserCredentials userCredentials System.Action < HttpResponse > onSuccess System.Action < System.Exception > onException Get(String, UserCredentials, Action<HttpResponse>, Action<Exception>, String) Declaration void Get(string url, UserCredentials userCredentials, Action<HttpResponse> onSuccess, Action<Exception> onException, string hostHeader = \"\") Parameters Type Name System.String url UserCredentials userCredentials System.Action < HttpResponse > onSuccess System.Action < System.Exception > onException System.String hostHeader Post(String, String, String, UserCredentials, Action<HttpResponse>, Action<Exception>) Declaration void Post(string url, string body, string contentType, UserCredentials userCredentials, Action<HttpResponse> onSuccess, Action<Exception> onException) Parameters Type Name System.String url System.String body System.String contentType UserCredentials userCredentials System.Action < HttpResponse > onSuccess System.Action < System.Exception > onException Put(String, String, String, UserCredentials, Action<HttpResponse>, Action<Exception>) Declaration void Put(string url, string body, string contentType, UserCredentials userCredentials, Action<HttpResponse> onSuccess, Action<Exception> onException) Parameters Type Name System.String url System.String body System.String contentType UserCredentials userCredentials System.Action < HttpResponse > onSuccess System.Action < System.Exception > onException"
  },
  "dotnet-api/code/EventStore.ClientAPI.GossipSeedClusterSettingsBuilder.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.GossipSeedClusterSettingsBuilder.html",
    "title": "Class GossipSeedClusterSettingsBuilder | Event Store",
    "keywords": "Class GossipSeedClusterSettingsBuilder Fluent builder used to configure ClusterSettings for connecting to a cluster using gossip seeds. Inheritance System.Object GossipSeedClusterSettingsBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class GossipSeedClusterSettingsBuilder Methods Build() Builds a ClusterSettings object from a GossipSeedClusterSettingsBuilder . Declaration public ClusterSettings Build() Returns Type Description ClusterSettings KeepDiscovering() Allows infinite nodes discovery attempts. Declaration public GossipSeedClusterSettingsBuilder KeepDiscovering() Returns Type Description GossipSeedClusterSettingsBuilder PreferRandomNode() Whether to randomly choose a node that's alive from the known nodes. Declaration public GossipSeedClusterSettingsBuilder PreferRandomNode() Returns Type Description GossipSeedClusterSettingsBuilder A DnsClusterSettingsBuilder for further configuration. PreferSlaveNode() Whether to prioritize choosing a slave node that's alive from the known nodes. Declaration public GossipSeedClusterSettingsBuilder PreferSlaveNode() Returns Type Description GossipSeedClusterSettingsBuilder A DnsClusterSettingsBuilder for further configuration. SetGossipSeedEndPoints(GossipSeed[]) Sets gossip seed endpoints for the client. Declaration public GossipSeedClusterSettingsBuilder SetGossipSeedEndPoints(params GossipSeed[] gossipSeeds) Parameters Type Name GossipSeed [] gossipSeeds Returns Type Description GossipSeedClusterSettingsBuilder A ClusterSettingsBuilder for further configuration. Exceptions Type Condition System.ArgumentException If no gossip seeds are specified. SetGossipSeedEndPoints(Boolean, IPEndPoint[]) Sets gossip seed endpoints for the client. TODO: This was a note. This should be the external HTTP endpoint of the server, as it is required for the client to exchange gossip with the server. The standard port is 2113. If the server requires a specific Host header to be sent as part of the gossip request, use the overload of this method taking GossipSeed instead. Declaration public GossipSeedClusterSettingsBuilder SetGossipSeedEndPoints(bool tlsTerminatedEndpoints, params IPEndPoint[] gossipSeeds) Parameters Type Name System.Boolean tlsTerminatedEndpoints System.Net.IPEndPoint [] gossipSeeds Returns Type Description GossipSeedClusterSettingsBuilder A ClusterSettingsBuilder for further configuration. Exceptions Type Condition System.ArgumentException If no gossip seeds are specified. SetGossipSeedEndPoints(IPEndPoint[]) Sets gossip seed endpoints for the client. TODO: This was a note. This should be the external HTTP endpoint of the server, as it is required for the client to exchange gossip with the server. The standard port is 2113. If the server requires a specific Host header to be sent as part of the gossip request, use the overload of this method taking GossipSeed instead. Declaration public GossipSeedClusterSettingsBuilder SetGossipSeedEndPoints(params IPEndPoint[] gossipSeeds) Parameters Type Name System.Net.IPEndPoint [] gossipSeeds Returns Type Description GossipSeedClusterSettingsBuilder A ClusterSettingsBuilder for further configuration. Exceptions Type Condition System.ArgumentException If no gossip seeds are specified. SetGossipTimeout(TimeSpan) Sets the period after which gossip times out if none is received. Declaration public GossipSeedClusterSettingsBuilder SetGossipTimeout(TimeSpan timeout) Parameters Type Name System.TimeSpan timeout Returns Type Description GossipSeedClusterSettingsBuilder A GossipSeedClusterSettingsBuilder for further configuration. SetMaxDiscoverAttempts(Int32) Sets the maximum number of attempts for discovery. Declaration public GossipSeedClusterSettingsBuilder SetMaxDiscoverAttempts(int maxDiscoverAttempts) Parameters Type Name System.Int32 maxDiscoverAttempts Returns Type Description GossipSeedClusterSettingsBuilder A GossipSeedClusterSettingsBuilder for further configuration. Exceptions Type Condition System.ArgumentOutOfRangeException If maxDiscoverAttempts is less than or equal to 0. Operators Implicit(GossipSeedClusterSettingsBuilder to ClusterSettings) Builds a ClusterSettings object from a GossipSeedClusterSettingsBuilder . Declaration public static implicit operator ClusterSettings(GossipSeedClusterSettingsBuilder builder) Parameters Type Name GossipSeedClusterSettingsBuilder builder Returns Type Description ClusterSettings"
  },
  "dotnet-api/code/EventStore.ClientAPI.UserManagement.RelLink.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.UserManagement.RelLink.html",
    "title": "Class RelLink | Event Store",
    "keywords": "Class RelLink Inheritance System.Object RelLink Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.UserManagement Assembly : EventStore.ClientAPI.dll Syntax public class RelLink Constructors RelLink(String, String) Declaration public RelLink(string href, string rel) Parameters Type Name System.String href System.String rel Fields Href Declaration public readonly string Href Field Value Type System.String Rel Declaration public readonly string Rel Field Value Type System.String"
  },
  "dotnet-api/code/EventStore.ClientAPI.Transport.Http.HttpResponse.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Transport.Http.HttpResponse.html",
    "title": "Class HttpResponse | Event Store",
    "keywords": "Class HttpResponse Inheritance System.Object HttpResponse Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.Transport.Http Assembly : EventStore.ClientAPI.dll Syntax public class HttpResponse Constructors HttpResponse(HttpResponseMessage) Declaration public HttpResponse(HttpResponseMessage responseMessage) Parameters Type Name System.Net.Http.HttpResponseMessage responseMessage Fields CharacterSet Declaration public readonly string CharacterSet Field Value Type System.String ContentEncoding Declaration public readonly string ContentEncoding Field Value Type System.String ContentLength Declaration public readonly long ContentLength Field Value Type System.Int64 ContentType Declaration public readonly string ContentType Field Value Type System.String Headers Declaration public readonly HttpResponseHeaders Headers Field Value Type System.Net.Http.Headers.HttpResponseHeaders HttpStatusCode Declaration public readonly int HttpStatusCode Field Value Type System.Int32 Method Declaration public readonly string Method Field Value Type System.String StatusDescription Declaration public readonly string StatusDescription Field Value Type System.String Properties Body Declaration public string Body { get; } Property Value Type System.String"
  },
  "dotnet-api/code/EventStore.ClientAPI.ClusterSettings.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ClusterSettings.html",
    "title": "Class ClusterSettings | Event Store",
    "keywords": "Class ClusterSettings Contains settings relating to a connection to a cluster. Inheritance System.Object ClusterSettings Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public sealed class ClusterSettings Fields ClusterDns The DNS name to use for discovering endpoints. Declaration public readonly string ClusterDns Field Value Type System.String ExternalGossipPort The well-known endpoint on which cluster managers are running. Declaration public readonly int ExternalGossipPort Field Value Type System.Int32 GossipSeeds Endpoints for seeding gossip if not using DNS. Declaration public readonly GossipSeed[] GossipSeeds Field Value Type GossipSeed [] GossipTimeout Timeout for cluster gossip. Declaration public TimeSpan GossipTimeout Field Value Type System.TimeSpan MaxDiscoverAttempts The maximum number of attempts for discovering endpoints. Declaration public readonly int MaxDiscoverAttempts Field Value Type System.Int32 NodePreference Prefer a randomly selected node. Declaration public NodePreference NodePreference Field Value Type NodePreference Methods Create() Creates a new set of ClusterSettings Declaration public static ClusterSettingsBuilder Create() Returns Type Description ClusterSettingsBuilder A ClusterSettingsBuilder that can be used to build up a ClusterSettings"
  },
  "dotnet-api/code/EventStore.ClientAPI.Internal.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Internal.html",
    "title": "Namespace EventStore.ClientAPI.Internal | Event Store",
    "keywords": "Namespace EventStore.ClientAPI.Internal Classes PersistentSubscriptionUpdateResult A Persistent Subscription Create Result is the result of a single operation updating a persistent subscription in the event store Enums PersistentSubscriptionUpdateStatus Enumeration representing the status of a single subscription create message."
  },
  "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptions.PersistentSubscriptionConnectionDetails.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptions.PersistentSubscriptionConnectionDetails.html",
    "title": "Class PersistentSubscriptionConnectionDetails | Event Store",
    "keywords": "Class PersistentSubscriptionConnectionDetails Details of a connection for a persistent subscription. Inheritance System.Object PersistentSubscriptionConnectionDetails Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.PersistentSubscriptions Assembly : EventStore.ClientAPI.dll Syntax public sealed class PersistentSubscriptionConnectionDetails Properties AvailableSlots Number of available slots. Declaration public int AvailableSlots { get; set; } Property Value Type System.Int32 AverageItemsPerSecond Average events per second on this connection. Declaration public decimal AverageItemsPerSecond { get; set; } Property Value Type System.Decimal CountSinceLastMeasurement Number of items seen since last measurement on this connection (used as the basis for AverageItemsPerSecond ). Declaration public long CountSinceLastMeasurement { get; set; } Property Value Type System.Int64 From Origin of this connection. Declaration public string From { get; set; } Property Value Type System.String InFlightMessages Number of in flight messages on this connection. Declaration public int InFlightMessages { get; set; } Property Value Type System.Int32 TotalItems Total items on this connection. Declaration public long TotalItems { get; set; } Property Value Type System.Int64 Username Connection username. Declaration public string Username { get; set; } Property Value Type System.String"
  },
  "dotnet-api/code/EventStore.ClientAPI.SubscriptionDropReason.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.SubscriptionDropReason.html",
    "title": "Enum SubscriptionDropReason | Event Store",
    "keywords": "Enum SubscriptionDropReason Represents the reason subscription drop happened Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public enum SubscriptionDropReason Fields Name Description AccessDenied Subscription dropped because access to the stream was denied. CatchUpError Subscription dropped because of an error during the catch-up phase. ConnectionClosed Subscription dropped because the connection was closed. EventHandlerException Subscription dropped because an exception was thrown by a handler. MaxSubscribersReached The maximum number of subscribers for the persistent subscription has been reached NotAuthenticated Subscription dropped because the client is not authenticated. NotFound Target of persistent subscription was not found. Needs to be created first PersistentSubscriptionDeleted The persistent subscription has been deleted ProcessingQueueOverflow Subscription dropped because it's queue overflowed. ServerError Subscription dropped because of a server error. SubscribingError Subscription dropped because of an error in the subscription phase. Unknown Subscription was dropped for an unknown reason. UserInitiated Subscription dropped because the client called Close."
  },
  "dotnet-api/code/EventStore.ClientAPI.DeleteResult.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.DeleteResult.html",
    "title": "Struct DeleteResult | Event Store",
    "keywords": "Struct DeleteResult Result type returned after deleting a stream. Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public struct DeleteResult Constructors DeleteResult(Position) Constructs a new DeleteResult . Declaration public DeleteResult(Position logPosition) Parameters Type Name Position logPosition Fields LogPosition The LogPosition of the write. Declaration public readonly Position LogPosition Field Value Type Position"
  },
  "dotnet-api/code/EventStore.ClientAPI.IEventStoreConnectionExtensions.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.IEventStoreConnectionExtensions.html",
    "title": "Class IEventStoreConnectionExtensions | Event Store",
    "keywords": "Class IEventStoreConnectionExtensions Extensions for IEventStoreConnection Inheritance System.Object IEventStoreConnectionExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public static class IEventStoreConnectionExtensions Methods ConnectToPersistentSubscription(IEventStoreConnection, String, String, Action<EventStorePersistentSubscriptionBase, ResolvedEvent>, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception>, UserCredentials, Int32, Boolean) Subscribes to a persistent subscription(competing consumer) on event store Declaration public static EventStorePersistentSubscriptionBase ConnectToPersistentSubscription(this IEventStoreConnection target, string stream, string groupName, Action<EventStorePersistentSubscriptionBase, ResolvedEvent> eventAppeared, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null, int bufferSize = 10, bool autoAck = true) Parameters Type Name IEventStoreConnection target System.String stream System.String groupName System.Action < EventStorePersistentSubscriptionBase , ResolvedEvent > eventAppeared System.Action < EventStorePersistentSubscriptionBase , SubscriptionDropReason , System.Exception > subscriptionDropped UserCredentials userCredentials System.Int32 bufferSize System.Boolean autoAck Returns Type Description EventStorePersistentSubscriptionBase An EventStorePersistentSubscriptionBase representing the subscription Remarks This will connect you to a persistent subscription group for a stream. The subscription group must first be created with CreatePersistentSubscriptionAsync many connections can connect to the same group and they will be treated as competing consumers within the group. If one connection dies work will be balanced across the rest of the consumers in the group. If you attempt to connect to a group that does not exist you will be given an exception. ConnectToPersistentSubscription(IEventStoreConnection, String, String, Func<EventStorePersistentSubscriptionBase, ResolvedEvent, Task>, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception>, UserCredentials, Int32, Boolean) Subscribes to a persistent subscription(competing consumer) on event store Declaration public static EventStorePersistentSubscriptionBase ConnectToPersistentSubscription(this IEventStoreConnection target, string stream, string groupName, Func<EventStorePersistentSubscriptionBase, ResolvedEvent, Task> eventAppeared, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null, int bufferSize = 10, bool autoAck = true) Parameters Type Name IEventStoreConnection target System.String stream System.String groupName System.Func < EventStorePersistentSubscriptionBase , ResolvedEvent , System.Threading.Tasks.Task > eventAppeared System.Action < EventStorePersistentSubscriptionBase , SubscriptionDropReason , System.Exception > subscriptionDropped UserCredentials userCredentials System.Int32 bufferSize System.Boolean autoAck Returns Type Description EventStorePersistentSubscriptionBase An EventStorePersistentSubscriptionBase representing the subscription Remarks This will connect you to a persistent subscription group for a stream. The subscription group must first be created with CreatePersistentSubscriptionAsync many connections can connect to the same group and they will be treated as competing consumers within the group. If one connection dies work will be balanced across the rest of the consumers in the group. If you attempt to connect to a group that does not exist you will be given an exception. ConnectToPersistentSubscriptionAsync(IEventStoreConnection, String, String, Action<EventStorePersistentSubscriptionBase, ResolvedEvent>, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception>, UserCredentials, Int32, Boolean) Subscribes to a persistent subscription(competing consumer) on event store Declaration public static Task<EventStorePersistentSubscriptionBase> ConnectToPersistentSubscriptionAsync(this IEventStoreConnection target, string stream, string groupName, Action<EventStorePersistentSubscriptionBase, ResolvedEvent> eventAppeared, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null, int bufferSize = 10, bool autoAck = true) Parameters Type Name IEventStoreConnection target System.String stream System.String groupName System.Action < EventStorePersistentSubscriptionBase , ResolvedEvent > eventAppeared System.Action < EventStorePersistentSubscriptionBase , SubscriptionDropReason , System.Exception > subscriptionDropped UserCredentials userCredentials System.Int32 bufferSize System.Boolean autoAck Returns Type Description System.Threading.Tasks.Task < EventStorePersistentSubscriptionBase > An EventStorePersistentSubscriptionBase representing the subscription Remarks This will connect you to a persistent subscription group for a stream. The subscription group must first be created with CreatePersistentSubscriptionAsync many connections can connect to the same group and they will be treated as competing consumers within the group. If one connection dies work will be balanced across the rest of the consumers in the group. If you attempt to connect to a group that does not exist you will be given an exception. ConnectToPersistentSubscriptionAsync(IEventStoreConnection, String, String, Func<EventStorePersistentSubscriptionBase, ResolvedEvent, Task>, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception>, UserCredentials, Int32, Boolean) Subscribes to a persistent subscription(competing consumer) on event store Declaration public static Task<EventStorePersistentSubscriptionBase> ConnectToPersistentSubscriptionAsync(this IEventStoreConnection target, string stream, string groupName, Func<EventStorePersistentSubscriptionBase, ResolvedEvent, Task> eventAppeared, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null, int bufferSize = 10, bool autoAck = true) Parameters Type Name IEventStoreConnection target System.String stream System.String groupName System.Func < EventStorePersistentSubscriptionBase , ResolvedEvent , System.Threading.Tasks.Task > eventAppeared System.Action < EventStorePersistentSubscriptionBase , SubscriptionDropReason , System.Exception > subscriptionDropped UserCredentials userCredentials System.Int32 bufferSize System.Boolean autoAck Returns Type Description System.Threading.Tasks.Task < EventStorePersistentSubscriptionBase > An EventStorePersistentSubscriptionBase representing the subscription Remarks This will connect you to a persistent subscription group for a stream. The subscription group must first be created with CreatePersistentSubscriptionAsync many connections can connect to the same group and they will be treated as competing consumers within the group. If one connection dies work will be balanced across the rest of the consumers in the group. If you attempt to connect to a group that does not exist you will be given an exception. SubscribeToAllAsync(IEventStoreConnection, Boolean, Action<EventStoreSubscription, ResolvedEvent>, Action<EventStoreSubscription, SubscriptionDropReason, Exception>, UserCredentials) Asynchronously subscribes to all events in the Event Store. New events written to the stream while the subscription is active will be pushed to the client. Declaration public static Task<EventStoreSubscription> SubscribeToAllAsync(this IEventStoreConnection target, bool resolveLinkTos, Action<EventStoreSubscription, ResolvedEvent> eventAppeared, Action<EventStoreSubscription, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null) Parameters Type Name IEventStoreConnection target System.Boolean resolveLinkTos System.Action < EventStoreSubscription , ResolvedEvent > eventAppeared System.Action < EventStoreSubscription , SubscriptionDropReason , System.Exception > subscriptionDropped UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < EventStoreSubscription > An EventStoreSubscription representing the subscription SubscribeToAllFrom(IEventStoreConnection, Nullable<Position>, CatchUpSubscriptionSettings, Action<EventStoreCatchUpSubscription, ResolvedEvent>, Action<EventStoreCatchUpSubscription>, Action<EventStoreCatchUpSubscription, SubscriptionDropReason, Exception>, UserCredentials) Subscribes to a all events. Existing events from lastCheckpoint onwards are read from the Event Store and presented to the user of EventStoreCatchUpSubscription as if they had been pushed. Once the end of the stream is read the subscription is transparently (to the user) switched to push new events as they are written. The action liveProcessingStarted is called when the EventStoreCatchUpSubscription switches from the reading phase to the live subscription phase. Declaration public static EventStoreAllCatchUpSubscription SubscribeToAllFrom(this IEventStoreConnection target, Position? lastCheckpoint, CatchUpSubscriptionSettings settings, Action<EventStoreCatchUpSubscription, ResolvedEvent> eventAppeared, Action<EventStoreCatchUpSubscription> liveProcessingStarted = null, Action<EventStoreCatchUpSubscription, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null) Parameters Type Name IEventStoreConnection target System.Nullable < Position > lastCheckpoint CatchUpSubscriptionSettings settings System.Action < EventStoreCatchUpSubscription , ResolvedEvent > eventAppeared System.Action < EventStoreCatchUpSubscription > liveProcessingStarted System.Action < EventStoreCatchUpSubscription , SubscriptionDropReason , System.Exception > subscriptionDropped UserCredentials userCredentials Returns Type Description EventStoreAllCatchUpSubscription An EventStoreSubscription representing the subscription SubscribeToStreamAsync(IEventStoreConnection, String, Boolean, Action<EventStoreSubscription, ResolvedEvent>, Action<EventStoreSubscription, SubscriptionDropReason, Exception>, UserCredentials) Asynchronously subscribes to a single event stream. New events written to the stream while the subscription is active will be pushed to the client. Declaration public static Task<EventStoreSubscription> SubscribeToStreamAsync(this IEventStoreConnection target, string stream, bool resolveLinkTos, Action<EventStoreSubscription, ResolvedEvent> eventAppeared, Action<EventStoreSubscription, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null) Parameters Type Name IEventStoreConnection target System.String stream System.Boolean resolveLinkTos System.Action < EventStoreSubscription , ResolvedEvent > eventAppeared System.Action < EventStoreSubscription , SubscriptionDropReason , System.Exception > subscriptionDropped UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < EventStoreSubscription > An EventStoreSubscription representing the subscription SubscribeToStreamFrom(IEventStoreConnection, String, Nullable<Int64>, CatchUpSubscriptionSettings, Action<EventStoreCatchUpSubscription, ResolvedEvent>, Action<EventStoreCatchUpSubscription>, Action<EventStoreCatchUpSubscription, SubscriptionDropReason, Exception>, UserCredentials) Subscribes to a single event stream. Existing events from lastCheckpoint onwards are read from the stream and presented to the user of EventStoreCatchUpSubscription as if they had been pushed. Once the end of the stream is read the subscription is transparently (to the user) switched to push new events as they are written. The action liveProcessingStarted is called when the EventStoreCatchUpSubscription switches from the reading phase to the live subscription phase. Declaration public static EventStoreStreamCatchUpSubscription SubscribeToStreamFrom(this IEventStoreConnection target, string stream, long? lastCheckpoint, CatchUpSubscriptionSettings settings, Action<EventStoreCatchUpSubscription, ResolvedEvent> eventAppeared, Action<EventStoreCatchUpSubscription> liveProcessingStarted = null, Action<EventStoreCatchUpSubscription, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null) Parameters Type Name IEventStoreConnection target System.String stream System.Nullable < System.Int64 > lastCheckpoint CatchUpSubscriptionSettings settings System.Action < EventStoreCatchUpSubscription , ResolvedEvent > eventAppeared System.Action < EventStoreCatchUpSubscription > liveProcessingStarted System.Action < EventStoreCatchUpSubscription , SubscriptionDropReason , System.Exception > subscriptionDropped UserCredentials userCredentials Returns Type Description EventStoreStreamCatchUpSubscription An EventStoreSubscription representing the subscription"
  },
  "dotnet-api/code/EventStore.ClientAPI.ConnectionSettings.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ConnectionSettings.html",
    "title": "Class ConnectionSettings | Event Store",
    "keywords": "Class ConnectionSettings A ConnectionSettings object is an immutable representation of the settings for an IEventStoreConnection . You can build a ConnectionSettings object using a ConnectionSettingsBuilder , either via the Create() method, or via the constructor of ConnectionSettingsBuilder . Inheritance System.Object ConnectionSettings Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public sealed class ConnectionSettings Fields ClientConnectionTimeout The interval after which a client will time out during connection. Declaration public readonly TimeSpan ClientConnectionTimeout Field Value Type System.TimeSpan ClusterDns The DNS name to use for discovering endpoints. Declaration public readonly string ClusterDns Field Value Type System.String DefaultUserCredentials The UserCredentials to use for operations where other UserCredentials are not explicitly supplied. Declaration public readonly UserCredentials DefaultUserCredentials Field Value Type UserCredentials ExternalGossipPort The well-known endpoint on which cluster managers are running. Declaration public readonly int ExternalGossipPort Field Value Type System.Int32 FailOnNoServerResponse Whether to raise an error if no response is received from the server for an operation. Declaration public readonly bool FailOnNoServerResponse Field Value Type System.Boolean GossipSeeds Endpoints for seeding gossip if not using DNS. Declaration public readonly GossipSeed[] GossipSeeds Field Value Type GossipSeed [] GossipTimeout Timeout for cluster gossip. Declaration public readonly TimeSpan GossipTimeout Field Value Type System.TimeSpan HeartbeatInterval The interval at which to send heartbeat messages. Declaration public readonly TimeSpan HeartbeatInterval Field Value Type System.TimeSpan HeartbeatTimeout The interval after which an unacknowledged heartbeat will cause the connection to be considered faulted and disconnect. Declaration public readonly TimeSpan HeartbeatTimeout Field Value Type System.TimeSpan Log The ILogger that this connection will use. Declaration public readonly ILogger Log Field Value Type ILogger MaxConcurrentItems The maximum number of allowed asynchronous operations to be in process. Declaration public readonly int MaxConcurrentItems Field Value Type System.Int32 MaxDiscoverAttempts The maximum number of attempts for discovering endpoints. Declaration public readonly int MaxDiscoverAttempts Field Value Type System.Int32 MaxQueueSize The maximum number of outstanding items allowed in the queue. Declaration public readonly int MaxQueueSize Field Value Type System.Int32 MaxReconnections The maximum number of times to allow for reconnection. Declaration public readonly int MaxReconnections Field Value Type System.Int32 MaxRetries The maximum number of retry attempts. Declaration public readonly int MaxRetries Field Value Type System.Int32 NodePreference Whether to randomly choose a node that's alive from the known nodes. Declaration public readonly NodePreference NodePreference Field Value Type NodePreference OperationTimeout The amount of time before an operation is considered to have timed out. Declaration public readonly TimeSpan OperationTimeout Field Value Type System.TimeSpan OperationTimeoutCheckPeriod The amount of time that timeouts are checked in the system. Declaration public readonly TimeSpan OperationTimeoutCheckPeriod Field Value Type System.TimeSpan QueueTimeout The amount of time a request for an operation is permitted to be queued awaiting transmission to the server. Declaration public readonly TimeSpan QueueTimeout Field Value Type System.TimeSpan ReconnectionDelay The amount of time to delay before attempting to reconnect. Declaration public readonly TimeSpan ReconnectionDelay Field Value Type System.TimeSpan RequireMaster Whether to require EventStore to refuse serving read or write request if it is not master. Declaration public readonly bool RequireMaster Field Value Type System.Boolean TargetHost The host name of the server expected on the SSL certificate. Declaration public readonly string TargetHost Field Value Type System.String UseSslConnection Whether the connection is encrypted using SSL. Declaration public readonly bool UseSslConnection Field Value Type System.Boolean ValidateServer Whether to validate the server SSL certificate. Declaration public readonly bool ValidateServer Field Value Type System.Boolean VerboseLogging Whether to use excessive logging of EventStoreConnection internal logic. Declaration public readonly bool VerboseLogging Field Value Type System.Boolean Properties CustomHttpClient Allows overriding the HTTPClient IHttpClient Declaration public IHttpClient CustomHttpClient { get; set; } Property Value Type IHttpClient Default The default ConnectionSettings . Declaration public static ConnectionSettings Default { get; } Property Value Type ConnectionSettings Methods Create() Creates a new set of ConnectionSettings . Declaration public static ConnectionSettingsBuilder Create() Returns Type Description ConnectionSettingsBuilder A ConnectionSettingsBuilder you can use to build up a ConnectionSettings"
  },
  "dotnet-api/code/EventStore.ClientAPI.ILogger.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ILogger.html",
    "title": "Interface ILogger | Event Store",
    "keywords": "Interface ILogger Simple abstraction of a logger. Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public interface ILogger Remarks You can pass your own logging abstractions into the Event Store Client API. Just pass in your own implementation of ILogger when constructing your client connection. Methods Debug(Exception, String, Object[]) Writes a debug message to the logger Declaration void Debug(Exception ex, string format, params object[] args) Parameters Type Name System.Exception ex System.String format System.Object [] args Debug(String, Object[]) Writes a debug message to the logger Declaration void Debug(string format, params object[] args) Parameters Type Name System.String format System.Object [] args Error(Exception, String, Object[]) Writes an error to the logger Declaration void Error(Exception ex, string format, params object[] args) Parameters Type Name System.Exception ex System.String format System.Object [] args Error(String, Object[]) Writes an error to the logger Declaration void Error(string format, params object[] args) Parameters Type Name System.String format System.Object [] args Info(Exception, String, Object[]) Writes an information message to the logger Declaration void Info(Exception ex, string format, params object[] args) Parameters Type Name System.Exception ex System.String format System.Object [] args Info(String, Object[]) Writes an information message to the logger Declaration void Info(string format, params object[] args) Parameters Type Name System.String format System.Object [] args"
  },
  "dotnet-api/code/EventStore.ClientAPI.ExpectedVersion.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ExpectedVersion.html",
    "title": "Class ExpectedVersion | Event Store",
    "keywords": "Class ExpectedVersion Constants used for expected version control Inheritance System.Object ExpectedVersion Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public static class ExpectedVersion Remarks The use of expected version can be a bit tricky especially when discussing idempotency assurances given by Event Store. There are four possible values you can use for passing an expected version. Any other value states that the last event written to the stream should have a sequence number matching your expected value. Event Store assures idempotency for all operations using any value in ExpectedVersion except for ExpectedVersion.Any and ExpectedVersion.StreamExists. When using ExpectedVersion.Any or ExpectedVersion.StreamExists Event Store does its best to assure idempotency but does not guarantee idempotency. Fields Any The write should not conflict with anything and should always succeed. Declaration public const int Any = -2 Field Value Type System.Int32 EmptyStream The stream should exist but be empty when writing. If it does not exist or is not empty treat that as a concurrency problem. Declaration [Obsolete(\"ExpectedVersion.EmptyStream has been deprecated. Use ExpectedVersion.NoStream instead\")] public const int EmptyStream = -1 Field Value Type System.Int32 NoStream The stream should not yet exist. If it does exist treat that as a concurrency problem. Declaration public const int NoStream = -1 Field Value Type System.Int32 StreamExists The stream should exist. If it or a metadata stream does not exist treat that as a concurrency problem. Declaration public const int StreamExists = -4 Field Value Type System.Int32"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.EventStoreConnectionException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.EventStoreConnectionException.html",
    "title": "Class EventStoreConnectionException | Event Store",
    "keywords": "Class EventStoreConnectionException Base type for exceptions thrown by an IEventStoreConnection , thrown in circumstances which do not have a specific derived exception. Inheritance System.Object System.Exception EventStoreConnectionException AccessDeniedException CannotEstablishConnectionException ClusterException CommandNotExpectedException ConnectionClosedException InvalidTransactionException NoResultException NotAuthenticatedException OperationExpiredException OperationTimedOutException PersistentSubscriptionCommandFailedException ProjectionCommandFailedException RetriesLimitReachedException ServerErrorException StreamDeletedException UserCommandFailedException WrongExpectedVersionException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class EventStoreConnectionException : Exception, ISerializable Constructors EventStoreConnectionException() Constructs a new EventStoreConnectionException . Declaration public EventStoreConnectionException() EventStoreConnectionException(SerializationInfo, StreamingContext) Constructs a new EventStoreConnectionException . Declaration protected EventStoreConnectionException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context EventStoreConnectionException(String) Constructs a new EventStoreConnectionException . Declaration public EventStoreConnectionException(string message) Parameters Type Name System.String message EventStoreConnectionException(String, Exception) Constructs a new EventStoreConnectionException . Declaration public EventStoreConnectionException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.NoResultException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.NoResultException.html",
    "title": "Class NoResultException | Event Store",
    "keywords": "Class NoResultException Exception thrown if there is no result for an operation for which one is expected. Inheritance System.Object System.Exception EventStoreConnectionException NoResultException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class NoResultException : EventStoreConnectionException, ISerializable Constructors NoResultException() Constructs a new NoResultException . Declaration public NoResultException() NoResultException(SerializationInfo, StreamingContext) Constructs a new NoResultException . Declaration protected NoResultException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context NoResultException(String) Constructs a new NoResultException . Declaration public NoResultException(string message) Parameters Type Name System.String message NoResultException(String, Exception) Constructs a new NoResultException . Declaration public NoResultException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.ConnectionString.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ConnectionString.html",
    "title": "Class ConnectionString | Event Store",
    "keywords": "Class ConnectionString Methods for dealing with connection strings. Inheritance System.Object ConnectionString Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class ConnectionString Methods GetConnectionSettings(String, ConnectionSettingsBuilder) Returns a ConnectionSettings for a given connection string. Declaration public static ConnectionSettings GetConnectionSettings(string connectionString, ConnectionSettingsBuilder builder = null) Parameters Type Name System.String connectionString ConnectionSettingsBuilder builder Returns Type Description ConnectionSettings a ConnectionSettings from the connection string"
  },
  "dotnet-api/code/EventStore.ClientAPI.NodePreference.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.NodePreference.html",
    "title": "Enum NodePreference | Event Store",
    "keywords": "Enum NodePreference Indicates which order of preferred nodes for connecting to. Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public enum NodePreference Fields Name Description Master When attempting connnection, prefers master node. Random When attempting connnection, has no node preference. Slave When attempting connnection, prefers slave node."
  },
  "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptions.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptions.html",
    "title": "Namespace EventStore.ClientAPI.PersistentSubscriptions | Event Store",
    "keywords": "Namespace EventStore.ClientAPI.PersistentSubscriptions Classes PersistentSubscriptionConfigDetails Configuration details of a persistent subscription. PersistentSubscriptionConnectionDetails Details of a connection for a persistent subscription. PersistentSubscriptionDetails Details for a Persistent Subscription. PersistentSubscriptionsManager API for managing persistent subscriptions in Event Store through C# code. Communicates with Event Store over the RESTful API."
  },
  "http-api/index.html": {
    "href": "http-api/index.html",
    "title": "Overview | Event Store",
    "keywords": "Overview Event Store provides a native interface of AtomPub over HTTP. AtomPub is a RESTful protocol that can reuse many existing components, for example reverse proxies and a client's native HTTP caching. Since events stored in Event Store are immutable, cache expiration can be infinite. Event Store leverages content type negotiation and you can access appropriately serialised events can as JSON or XML according to the request headers. Compatibility with AtomPub Event Store is fully compatible with the 1.0 version of the Atom Protocol . Event Store adds extensions to the protocol, such as headers for control and custom rel links. Existing implementations Many environments have already implemented the AtomPub protocol, which simplifies the process. Library Description NET (BCL) System.ServiceModel.SyndicationServices JVM http://java-source.net/open-source/rss-rdf-tools PHP http://simplepie.org/ or https://github.com/fguillot/picoFeed Ruby https://github.com/cardmagic/simple-rss Clojure https://github.com/scsibug/feedparser-clj Go https://github.com/jteeuwen/go-pkg-rss Python http://code.google.com/p/feedparser/ node.js https://github.com/danmactough/node-feedparser Objective-C https://geekli.st/darvin/repos/MWFeedParser Note These are not officially supported by Event Store. Content types The preferred way of determining which content type responses Event Store serves is to set the Accept header on the request. As some clients do not deal well with HTTP headers when caching, appending a format parameter to the URL is also supported, for example, ?format=xml . The accepted content types for POST requests are: application/xml application/vnd.eventstore.events+xml application/json application/vnd.eventstore.events+json text/xml The accepted content types for GET requests are: application/xml application/atom+xml application/json application/vnd.eventstore.atom+json text/xml text/html application/vnd.eventstore.streamdesc+json"
  },
  "http-api/description-document/index.html": {
    "href": "http-api/description-document/index.html",
    "title": "Description document | Event Store",
    "keywords": "Description document <!-- TODO: Combine with CC pages? --> With the addition of Competing Consumers, which is another way of reading streams, the need arose to expose these different methods to consumers. The introduction of the description document has some benefits: Clients can rely on the keys (streams, streamSubscription) in the description document to remain unchanged across versions of Event Store and you can rely on it as a lookup for the particular method of reading a stream. Allows the restructuring of URIs underneath without breaking clients. e.g., /streams/newstream -> /streams/newstream/atom . Fetching the description document There are three ways in which Event Store returns the description document. Attempting to read a stream with an unsupported media type. Attempting to read a stream with no accept header. Requesting the description document explicitly. The client is able to request the description document by passing application/vnd.eventstore.streamdesc+json in the accept header, for example: Request Response curl -i http://localhost:2113/streams/newstream -H \"accept:application/vnd.eventstore.streamdesc+json\" HTTP/1.1 200 Description Document Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Content-Type: application/vnd.eventstore.streamdesc+json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Thu, 23 Aug 2018 12:37:18 GMT Content-Length: 517 Keep-Alive: timeout=15,max=100 { \"title\": \"Description document for 'newstream'\", \"description\": \"The description document will be presented when no accept header is present or it was requested\", \"_links\": { \"self\": { \"href\": \"/streams/newstream\", \"supportedContentTypes\": [ \"application/vnd.eventstore.streamdesc+json\" ] }, \"stream\": { \"href\": \"/streams/newstream\", \"supportedContentTypes\": [ \"application/atom+xml\", \"application/vnd.eventstore.atom+json\" ] } } } In the example above, the client requested the description document for the stream called newstream which has a set of links describing the supported methods and content types. The document also includes additional methods available such as the streamSubscription . If there are no subscriptions to the newstream , the streamSubscription key is absent."
  },
  "event-sourcing-basics/index.html": {
    "href": "event-sourcing-basics/index.html",
    "title": "Event Sourcing Basics | Event Store",
    "keywords": "Event Sourcing Basics What is an Event Store? Event Store is a database that supports the concept of Event Sourcing, which is an old idea that has recently become popular again Note If you are familiar with functional programming you may wish to jump to the Event Store viewed as a functional database section . Production systems often rely on storing their current state to process transactions, but this has not always been the case. Before the general acceptance of relational database management systems (RDBMS) as the center of system architectures many did not store the current state. This was especially true in high performance, mission critical, and highly secure systems. If you look at the inner workings of an RDBMS you will find that most do not themselves work by managing current state. What is an event? An event is something that happened in the past, and so you should represent events as verbs in the past tense such as CustomerRelocated , CargoShipped , or InventoryLossageRecorded . If you are taking a domain driven design approach, it's imperative that events are verbs in the past tense, as they are part of the Ubiquitous Language. Consider the differences with ubiquitous language when relocating a customer. An event makes the concept explicit where previously the changes would occur within an aggregate or between multiple aggregates and were left as an implicit concept that you needed to explore and define. In most applications, a developer discovers that a side effect occurred with a tool such as Hibernate or Entity Framework. If there is a change to the side effects of a use case, it is an implicit concept. The introduction of the event makes the concept explicit and part of the Ubiquitous Language. Relocating a customer does not change something, relocating a customer produces a CustomerRelocatedEvent event which is explicitly defined within the language. In code an event is a data holding structure such as the following: public class InventoryItemDeactivated { public readonly Guid InventoryItemId; public readonly string Reason; public InventoryItemDeactivated(inventoryItemId, reason) { InventoryItemId = inventoryItemId; Reason = reason; } } Other definitions of domain events There is a concept related to a Domain Event defined in Streamlined Object Modeling (SOM). The term Domain Event is often used in SOM when discussing The Event Principle. Model the event of people interacting at a place with a thing with a transaction object. Model a point-in-time interaction as a transaction with a single timestamp; model a time-interval interaction as a transaction with multiple timestamps. Jill Nicola, 2002ll, p. 23 Although people use the term Domain Event to describe this concept the term does not have the same definition as a Domain Event in the context of this document. SOM uses another term for the concept that better describes what the object is, a transaction. The concept of a transaction object is an important one in a domain and deserves a name. An example of such a transaction might be a player swinging a bat. This is an action that occurred at a given point and you should model as such in the domain, but this is not the same as a Domain Event. This also differs from Martin Fowlers example of what a Domain Event is: Example: I go to Baburs for a meal on Tuesday, and pay by credit card. This might be modeled as an event, whose type is Make Purchase, whose subject is my credit card, and whose occurred date is Tuesday. If Baburs uses an old manual system and doesnt transmit the transaction until Friday, then the noticed date would be Friday. Fowler Furthermore By funneling inputs of a system into streams of Domain Events you can keep a record of all the inputs to a system. This helps you to organize your processing logic, and also allows you to keep an audit log of the system. Fowler What Martin is actually describing here is a \"command\". The language Make Purchase is wrong if we are to consider this as an event. A purchase was made, therefore it makes more sense to introduce a PurchaseMade event. Martin did make a purchase at the location, they did charge his credit card, and he ate and enjoyed his food. All these events are in the past tense. They have already happened and cannot be undone. An example such as the sales example given tends to lead towards a secondary problem when built within a system. The problem is that the domain may be responsible for filling in parts of the event. Consider a system where the domain processes the sale itself. How much is the sales tax? Often the domain would calculate this. This leads to a dual definition of the event. There is the event as sent from the client without the sales tax, and then the domain would receive it and add in the sales tax. It causes the event to have multiple definitions, as well as forcing mutability on some attributes. Dual events can sidestep this issue (one for the client with just what it provides and another for the domain including what it enriched the event from the client with) but this is the command event model, and the linguistic problems still exist. You can see a further example of the linguistic problems involved in error conditions. How should the domain handle the fact that a client told it to do something that it cannot? This condition can exist for many reasons but lets imagine a simple one of the client not having enough information to source the event in a known correct way. Linguistically the command/event separation makes more sense here as the command arrives in the imperative Place Sale while the event is in the past tense Sale Completed. It's natural for the domain to reject a client attempting to Place a sale, it's not natural for the domain to tell the client that something in the past tense no longer happened. Consider the discussion with a domain expert. Does the domain have a time machine? Parallel realities are far too complex and costly to model in most business systems. These are the problems that led to the separation of the concepts of Commands and Events. This separation makes the language much clearer and although subtle, it tends to lead developers towards a clearer understanding of context based solely on the language used. Dual definitions of a concept force the developer to recognize and distinguish context. This weight can translate into both ramp up time for new developers on a project and another thing a member of the team needs to remember. Anytime a team member needs to remember something to distinguish context there is a higher probability that they will overlook it or mistaken for another context. Being explicit in the language and avoiding dual definitions helps make things clearer both for domain experts, the developers, and anyone who may be consuming the API. Further reading DDD CQRS Video Event Sourcing Getting Started"
  },
  "event-sourcing-basics/impendence-missmatch/index.html": {
    "href": "event-sourcing-basics/impendence-missmatch/index.html",
    "title": "Impedance mismatch | Event Store",
    "keywords": "Impedance mismatch Using events as a storage mechanism offers different properties when compared to a typical relational model, as the impedance mismatch that exists between a typical relational model and the object oriented domain model is analyzed. Scott Ambler describes the problem in an essay on agiledata.org as: Why does this impedance mismatch exist? The object-oriented paradigm is based on proven software engineering principles. The relational paradigm, however, is based on proven mathematical principles. Because the underlying paradigms are different the two technologies do not work together seamlessly. The impedance mismatch becomes apparent when you look at the preferred approach to access: With the object paradigm you traverse objects via their relationships whereas with the relational paradigm you join the data rows of tables. This fundamental difference results in a non-ideal combination of object and relational technologies, although when have you ever used two different things together without a few hitches? Ambler The impedance mismatch between the domain model and the relational database has a large cost associated with it. There are many tools that aim to help minimize the effects of the impedance mismatch such as Object Relational Mappers (ORMs). They tend to work well in most situations but there is a large cost associated to the impedance mismatch even when using tools such as ORMs. The cost is that a developer needs to be intimately familiar with both the relational model and the object oriented model. They also need to be familiar with the subtle differences between the two models. Scott identifies this with: To succeed using objects and relational databases together you need to understand both paradigms, and their differences, and then make intelligent tradeoffs based on that knowledge. Ambler You can find some of these subtle differences on Wikipedia under the \" Object-Relational Impedance Mismatch \" page but to include some of the major differences: Declarative vs. imperative interfaces Relational thinking tends to use data as interfaces, not behaviour as interfaces. It thus has a declarative tilt in design philosophy in contrast to Object-oriented programmings behavioural tilt. (Some relational proponents propose using triggers, stored procedures, etc. to provide complex behaviour, but this is not a common viewpoint.) Object-Relational Impedance Mismatch Structure vs. behaviour - Object-oriented programming primarily focuses on ensuring that the structure of the program is reasonable (maintainable, understandable, extensible, reusable, safe), whereas relational systems focus on what kind of behaviour the resulting run-time system has (efficiency, adaptability, fault-tolerance, liveness, logical integrity, etc.). Object-oriented methods generally assume that the primary user of the object-oriented code and its interfaces are the application developers. In relational systems, the end-users view of the behaviour of the system is sometimes considered to be more important. However, relational queries and \"views\" are common techniques to re-represent information in application- or task-specific configurations. Further, relational does not prohibit local or application-specific structures or tables from being created, although many common development tools do not directly provide such a feature, assuming objects will be used instead. This makes it difficult to know whether the stated non-developer perspective of relational is inherent to relational, or merely a product of current practice and tObject-oriented programmingl implementation assumptions. Object-Relational Impedance Mismatch Set vs. graph relationships The relationship between different items (objects or records) tend to be handled differently between the paradigms. Relational relationships are usually based on idioms taken from set theory, while object relationships lean toward idioms adopted from graph theory (including trees). While each can represent the same information as the other, the approaches they provide to access and manage information differ. Object-Relational Impedance Mismatch There are many other subtle differences such as data types, identity, and how transactions work. The object-relational impedance mismatch can be quite a pain to deal with and it requires a very large amount of knowledge to deal with effectively. There is not an impedance mismatch between events and the domain model. The events are themselves a domain concept. The idea of replaying events to reach a given state is also a domain concept. The entire system becomes defined in domain terms. Defining everything in domain terms not only lowers the amount of knowledge that developers need to have but it also limits the number of representations of the model needed as the events are directly tied to the domain model itself."
  },
  "dotnet-api/projections/index.html": {
    "href": "dotnet-api/projections/index.html",
    "title": "Projections management | Event Store",
    "keywords": "Projections management The Event Store Client API includes helper methods that use the HTTP API to allow you to manage projections. This document describes the methods found in the ProjectionsManager class. All methods in this class are asynchronous. Enable a projection Enables an existing projection by name. You must have access to a projection to enable it. public Task EnableAsync(string name, UserCredentials userCredentials = null) Disable a projection Disables an existing projection by name. You must have access to a projection to disable it. public Task DisableAsync(string name, UserCredentials userCredentials = null) Abort a projection Aborts an existing projection by name. You must have access to a projection to abort it. public Task AbortAsync(string name, UserCredentials userCredentials = null) Create a one-time projection Creates a projection that runs until the end of the log and then stops. The query parameter contains the JavaScript you want created as a one time projection. public Task CreateOneTimeAsync(string query, UserCredentials userCredentials = null) Create a continuous projection Creates a projection that runs until the end of the log and then continues running. The query parameter contains the JavaScript you want created as a one time projection. Continuous projections have explicit names and you can enable or disable them via this name. public Task CreateContinuousAsync(string name, string query, UserCredentials userCredentials = null) List all projections Returns a list of all projections. public Task<List<ProjectionDetails>> ListAllAsync(UserCredentials userCredentials = null) List one-time projections Returns a list of all One-Time Projections. public Task<List<ProjectionDetails>> ListOneTimeAsync(UserCredentials userCredentials = null) Get statistics on a projection Returns the statistics associated with a named projection. public Task<string> GetStatisticsAsync(string name, UserCredentials userCredentials = null) Delete projection Deletes a named projection. You must have access to a projection to delete it. public Task DeleteAsync(string name, UserCredentials userCredentials = null) Get state Retrieves the state of a projection. public Task<string> GetState(string name, UserCredentials userCredentials = null) Get partition state Retrieves the state of the projection via the given partition. public Task<string> GetPartitionStateAsync(string name, string partition, UserCredentials userCredentials = null) Get result Retrieves the result of the projection. public Task<string> GetResult(string name, UserCredentials userCredentials = null) Get partition result Retrieves the result of the projection via the given partition. public Task<string> GetPartitionResultAsync(string name, string partition, UserCredentials userCredentials = null)"
  },
  "dotnet-api/optimistic-concurrency-and-idempotence/index.html": {
    "href": "dotnet-api/optimistic-concurrency-and-idempotence/index.html",
    "title": "Optimistic concurrency and idempotence | Event Store",
    "keywords": "Optimistic concurrency and idempotence Writing supports an optimistic concurrency check on the version of the stream to which events are written. The method of specifying what the expected version is depends whether you are making writes using the HTTP or .NET API. The .NET API has constants which you can use to represent certain conditions: Parameter Description ExpectedVersion.Any Disables the optimistic concurrency check. ExpectedVersion.NoStream Specifies the expectation that target stream does not yet exist. ExpectedVersion.EmptyStream Specifies the expectation that the target stream has been explicitly created, but does not yet have any user events written in it. ExpectedVersion.StreamExists Specifies the expectation that the target stream or its metadata stream has been created, but does not expect the stream to be at a specific event number. Any other integer value The event number that you expect the stream to currently be at. If the optimistic concurrency check fails during writing, a WrongExpectedVersionException is thrown. Idempotence If identical write operations occur, Event Store treats them in a way which makes it idempotent. If a write is treated in this manner, Event Store acknowledges it as successful, but duplicate events are not written. The idempotence check is based on the EventId and stream . It is possible to reuse an EventId across streams whilst maintaining idempotence. The level of idempotence guarantee depends on whether the optimistic concurrency check is not disabled during writing (by passing ExpectedVersion.Any as the expectedVersion for the write). If you specify an expected version The specified expectedVersion is compared to the currentVersion of the stream. This will yield one of three results: expectedVersion > currentVersion - a WrongExpectedVersionException is thrown. expectedVersion == currentVersion - events are written and acknowledged. expectedVersion < currentVersion - the EventId of each event in the stream starting from expectedVersion are compared to those in the write operation. This can yield one of three further results: All events have been committed already - the write is acknowledged as successful, but no duplicate events written. None of the events were previously committed - a WrongExpectedVersionException is thrown. Some of the events were previously committed - this is considered a bad request. If the write contains the same events as a previous request, either all or none of the events should have been previously committed. This surfaces as a WrongExpectedVersionException . If you specify ExpectedVersion.Any Warning Idempotence is not guaranteed if you use ExpectedVersion.Any . The chance of a duplicate event is small, but is possible. The idempotence check will yield one of three results: All events have been committed already - the write is acknowledged as successful, but no duplicate events written. None of the events were previously committed - the events are written and the write acknowledged. Some of the events were previously committed - this is considered a bad request. If the write contains the same events as a previous request, either all or none of the events should have been previously committed. This currently surfaces as a WrongExpectedVersionException ."
  },
  "dotnet-api/index.html": {
    "href": "dotnet-api/index.html",
    "title": "Overview | Event Store",
    "keywords": "Overview The .NET Client API communicates with Event Store over TCP, using length-prefixed serialised protocol buffers. The API allows for reading and writing operations, as well as for subscriptions to individual event streams or all events written. EventStoreConnection The EventStoreConnection class maintains a full-duplex connection between the client and the Event Store server. EventStoreConnection is thread-safe, and we recommend that you create one instance per application. Event Store handles all connections asynchronously, returning either a Task or a Task<T> . If you need to execute synchronously, call .Wait() on the asynchronous version. Note To get maximum performance from the connection, we recommend you use it asynchronously. Quick start The code below shows how to connect to an Event Store server, write to a stream, and read back the events. For more detailed information, read the full pages for connecting to a server , reading events and writing to a stream var connection = EventStoreConnection.Create(new IPEndPoint(IPAddress.Loopback, 1113)); // Don't forget to tell the connection to connect! connection.ConnectAsync().Wait(); var myEvent = new EventData(Guid.NewGuid(), \"testEvent\", false, Encoding.UTF8.GetBytes(\"some data\"), Encoding.UTF8.GetBytes(\"some metadata\")); connection.AppendToStreamAsync(\"test-stream\", ExpectedVersion.Any, myEvent).Wait(); var streamEvents = connection.ReadStreamEventsForwardAsync(\"test-stream\", 0, 1, false).Result; var returnedEvent = streamEvents.Events[0].Event; Console.WriteLine(\"Read event with data: {0}, metadata: {1}\", Encoding.UTF8.GetString(returnedEvent.Data), Encoding.UTF8.GetString(returnedEvent.Metadata));"
  },
  "dotnet-api/embedded-client/index.html": {
    "href": "dotnet-api/embedded-client/index.html",
    "title": "Embedded client | Event Store",
    "keywords": "Embedded client EmbeddedVNodeBuilder The EmbeddedVNodeBuilder class sets up and builds an Event Store node. You can configure your node through methods provided by the EmbeddedVNodeBuilder class. Note The builder used for the EmbeddedVNodeBuilder is the same Event Store uses internally to create the ClusterNode , see EventStore.ClusterNode.Program.cs for more examples on how to use it. Building a node You have two options when you start creating a node, EmbeddedVNodeBuilder.AsSingleNode() or EmbeddedVNodeBuilder.AsClusterMember(clusterSize) , which will create a single node or a cluster node respectively. After creating the builder, you can configure the node through the methods provided by the EmbeddedVNodeBuilder . These are listed below. Once you have configured the node, build it with EmbeddedVNodeBuilder.Build() which returns the configured ClusterVNode . Start the node with ClusterVNode.StartAndWaitUntilReady() or ClusterVNode.Start() . ClusterVNode.StartAndWaitUntilReady() returns a task that completes once the node has started and all subsystems have finished loading. For example, to build a single node with default options : var nodeBuilder = EmbeddedVNodeBuilder.AsSingleNode() .OnDefaultEndpoints() .RunInMemory(); var node = nodeBuilder.Build(); node.StartAndWaitUntilReady().Wait(); To build a node to be part of a cluster with custom endpoints and gossip seeds: var nodeBuilder = EmbeddedVNodeBuilder.AsClusterMember(3) .RunOnDisk(\"node1db\") .WithInternalHttpOn(new IPEndPoint(IPAddress.Loopback, 1112)) .WithExternalHttpOn(new IPEndPoint(IPAddress.Loopback, 1113)) .WithExternalTcpOn(new IPEndPoint(IPAddress.Loopback, 1114)) .WithInternalTcpOn(new IPEndPoint(IPAddress.Loopback, 1115)) .DisableDnsDiscovery() .WithGossipSeeds(new IPEndPoint[] { new IPEndPoint(IPAddress.Loopback, 2112), new IPEndPoint(IPAddress.Loopback, 3112) }); var node = nodeBuilder.Build(); node.Start(); Warning When running an embedded cluster, the task returned by StartAndWaitUntilReady() only completes on the master node. Connecting to an embedded node You can connect to an embedded Event Store node with the EmbeddedEventStoreConnection class. Calling EmbeddedEventStoreConnection.Create(ClusterVNode) returns an IEventStoreConnection configured to connect to your embedded node. From there you can use the connection as normal in the .NET Client. using(var embeddedConn = EmbeddedEventStoreConnection.Create(node)) { embeddedConn.ConnectAsync().Wait(); embeddedConn.AppendToStreamAsync(\"testStream\", ExpectedVersion.Any, new EventData(Guid.NewGuid(), \"eventType\", true, Encoding.UTF8.GetBytes(\"{\\\"Foo\\\":\\\"Bar\\\"}\"), null)).Wait(); } Logging with an embedded node To enable logging for an embedded node, you need to initialize the LogManager and ensure that you configure the logger with a log.config file in your configuration directory. To initialize the LogManager , call this before building the nodes: LogManager.Init(logComponentName, logDirectory, logConfigurationDirectory); EmbeddedVNodeBuilder options The following options are available when building an Embedded Node. Application options Method Description AsSingleNode() Returns a builder set to construct options for a single node instance AsClusterMember(int clusterSize) Returns a builder set to construct options for a cluster node instance with a cluster size DisableHTTPCaching() Disable HTTP Caching WithWorkerThreads(int count) Sets the number of worker threads to use in shared threadpool WithStatsPeriod(TimeSpan statsPeriod) Sets the period between statistics gathers EnableLoggingOfHttpRequests() Enable logging of HTTP requests and responses before they are processed EnableHistograms() Enable the tracking of histograms, typically used for debugging EnableTrustedAuth() Enable trusted authentication by an intermediary in the HTTP Certificate options Method Description WithServerCertificateFromFile(string path, string password) Sets the Server SSL Certificate loaded from a file WithServerCertificate(X509Certificate2 sslCertificate) Sets the Server SSL Certificate WithServerCertificateFromStore(StoreLocation storeLocation, StoreName storeName, string certificateSubjectName, string certificateThumbprint) Sets the Server SSL Certificate loaded from a certificate store WithServerCertificateFromStore(StoreName storeName, string certificateSubjectName, string certificateThumbprint) Sets the Server SSL Certificate loaded from a certificate store Cluster options Method Description WithClusterGossipPort(int port) Sets the internal gossip port (used when using cluster DNS, this should point to a known port gossip will be running on) WithGossipSeeds(params IPEndPoint[] endpoints) Sets the gossip seeds this node should talk to WithClusterDnsName(string name) Sets the DNS name used for the discovery of other cluster nodes DisableDnsDiscovery() Disable DNS discovery for the cluster WithGossipInterval(TimeSpan gossipInterval) Sets the gossip interval WithGossipAllowedTimeDifference(TimeSpan gossipAllowedDifference) Sets the allowed gossip time difference WithGossipTimeout(TimeSpan gossipTimeout) Sets the gossip timeout WithPrepareTimeout(TimeSpan prepareTimeout) Sets the prepare timeout WithCommitTimeout(TimeSpan commitTimeout) Sets the commit timeout WithPrepareCount(int prepareCount) Sets the number of nodes which must acknowledge prepares. WithCommitCount(int commitCount) Sets the number of nodes which must acknowledge commits before acknowledging to a client. WithNodePriority(int nodePriority) Sets the node priority used during master election Database options Method Description RunInMemory() Sets the builder to run in memory RunOnDisk(string path) Sets the builder to write database files to the specified path MaximumMemoryTableSizeOf(int size) Sets the maximum size a memtable is allowed to reach (in count) before moved to be a ptable DoNotVerifyDbHashes() Marks that the existing database files should not be checked for checksums on startup. VerifyDbHashes() Marks that the existing database files should be checked for checksums on startup. WithMinFlushDelay(TimeSpan minFlushDelay) Sets the minimum flush delay DisableScavengeMerging() Disables the merging of chunks when scavenge is running WithScavengeHistoryMaxAge(int scavengeHistoryMaxAge) The number of days to keep scavenge history (Default: 30) WithIndexPath(string indexPath) Sets the path the index should be loaded or saved to WithIndexCacheDepth(int indexCacheDepth) Sets the depth to cache for the mid point cache in index WithUnsafeIgnoreHardDelete() Disables Hard Deletes (UNSAFE: use to remove hard deletes) WithUnsafeDisableFlushToDisk() Disables Hard Deletes (UNSAFE: use to remove hard deletes) WithBetterOrdering() Enable queue affinity on reads during write process to try to get better ordering. WithTfChunkSize(int chunkSize) Sets the transaction file chunk size. Default is TFConsts.ChunkSize WithTfCachedChunks(int cachedChunks) The number of chunks to cache in unmanaged memory. Default is TFConsts.ChunksCacheSize Interface options Method Description OnDefaultEndpoints() Sets the default endpoints on localhost (1113 tcp, 2113 http) AdvertiseInternalIPAs(IPAddress intIpAdvertiseAs) Sets up the Internal IP to advertise AdvertiseExternalIPAs(IPAddress extIpAdvertiseAs) Sets up the External IP to advertise AdvertiseInternalHttpPortAs(int intHttpPortAdvertiseAs) Sets up the Internal HTTP port to advertise AdvertiseExternalHttpPortAs(int extHttpPortAdvertiseAs) Sets up the External HTTP port to advertise AdvertiseInternalSecureTCPPortAs(int intSecureTcpPortAdvertiseAs) Sets up the Internal Secure TCP port to advertise AdvertiseExternalSecureTCPPortAs(int extSecureTcpPortAdvertiseAs) Sets up the External Secure TCP port to advertise AdvertiseInternalTCPPortAs(int intTcpPortAdvertiseAs) Sets up the Internal TCP port to advertise AdvertiseExternalTCPPortAs(int extTcpPortAdvertiseAs) Sets up the External TCP port to advertise WithInternalHttpOn(IPEndPoint endpoint) Sets the internal HTTP endpoint to the specified value WithExternalHttpOn(IPEndPoint endpoint) Sets the external HTTP endpoint to the specified value WithInternalTcpOn(IPEndPoint endpoint) Sets the internal TCP endpoint to the specified value WithInternalSecureTcpOn(IPEndPoint endpoint) Sets the internal secure TCP endpoint to the specified value WithExternalTcpOn(IPEndPoint endpoint) Sets the external TCP endpoint to the specified value WithExternalSecureTcpOn(IPEndPoint endpoint) Sets the external secure TCP endpoint to the specified value EnableSsl() Sets that SSL should be used on connections WithSslTargetHost(string targetHost) Sets the target host of the server's SSL certificate. ValidateSslServer() Sets whether to validate that the server's certificate is trusted. NoGossipOnPublicInterface() Disables gossip on the public (client) interface NoAdminOnPublicInterface() Disables the admin interface on the public (client) interface NoStatsOnPublicInterface() Disables statistics screens on the public (client) interface AddInternalHttpPrefix(string prefix) Adds a HTTP prefix for the internal HTTP endpoint AddExternalHttpPrefix(string prefix) Adds a HTTP prefix for the external HTTP endpoint DontAddInterfacePrefixes() Don't add the interface prefixes (e.g. If the External IP is set to the Loopback address, add http://localhost:2113/ as a prefix) WithInternalHeartbeatInterval(TimeSpan heartbeatInterval) Sets the heartbeat interval for the internal network interface. WithExternalHeartbeatInterval(TimeSpan heartbeatInterval) Sets the heartbeat interval for the external network interface. WithInternalHeartbeatTimeout(TimeSpan heartbeatTimeout) Sets the heartbeat timeout for the internal network interface. WithExternalHeartbeatTimeout(TimeSpan heartbeatTimeout) Sets the heartbeat timeout for the external network interface. Projections options Method Description StartStandardProjections() Start standard projections. RunProjections(ProjectionType projectionType, int numberOfThreads = Opts.ProjectionThreadsDefault) Sets the mode and the number of threads on which to run projections. RunProjections(ClientAPI.Embedded.ProjectionsMode projectionsMode, int numberOfThreads = Opts.ProjectionThreadsDefault) Sets the mode and the number of threads on which to run projections. EmbeddedEventStoreConnection The following methods are available on EmbeddedEventStoreConnection for connecting to an embedded node. Method Description Create(ClusterVNode eventStore, string connectionName = null) Creates a new embedded IEventStoreConnection to a single node with default connection settings Create(ClusterVNode eventStore, ConnectionSettings connectionSettings, string connectionName = null) Creates a new embedded IEventStoreConnection to a single node using specific ConnectionSettings"
  },
  "server/admin-ui/index.html": {
    "href": "server/admin-ui/index.html",
    "title": "Admin UI | Event Store",
    "keywords": "Admin UI The Event Store Admin UI is available at SERVER_IP:2113 helps you interact with and manage a cluster in a visual way. This guide explains the tabs of the interface and what they do. Dashboard The Dashboard tab shows an overview of active queues with associated statistics in the top half. The + icon indicates a queue group, click it to reveal the queues that are part of the group. The second half of the tab shows active connections to Event Store and information about them. Click the Snapshot button in the top right to output a snapshot of all queue statistics at the time you clicked the button. Stream browser The Stream Browser tab gives an overview of recently created and changed streams, clicking on an individual stream shows details about the individual stream. Event stream 'streamname' Each individual stream shows pages of the events in a stream with an overview of the event. Click the Name to see the EventId, and JSON to the see the event data. The buttons above change depending on what you are viewing in the interface. The Back button takes you to the parent screen. The buttons on the top right when you are viewing an event stream are: Pause : Stop showing events arriving into this stream. Resume : Resume showing events arriving into this stream. Edit ACL : Edit the access control lists for a stream. Add Event : Add a new event to the stream. Delete : Delete a stream to the stream. Query : The buttons on the left above the events when you are viewing an event stream are: self : Takes you to the overview of the stream. first : Takes you to the first page of events in a stream. previous : Takes you to the previous page of events in a stream. metadata : Shows the metadata of a stream. On the metadata screen, click Add New Like This to add a new event to the stream. Projections The Projections tab shows system and user created projections defined in Event Store, the buttons above the list do the following: Disable All : Disable all running projections. Enable All : Enable all stopped projections. Include Queries : Toggle displaying queries in the Projections table. New Projection : Create a user-defined projection with the Admin UI. Clicking an individual projection shows further details. On the left is the projection definition, and on the right, the stats, results and state of the projection. The buttons above the details do the following: Start : Start a stopped projection. Stop : Stop a running projection. Edit : Edit the projection definition. Config : Set configuration options for a projection. Debug : Opens the debugging interface to debug what effect a projection is having on events. Delete : Delete a projection. Reset : Reset a projection. Back : Returns you to the parent screen. Query The Query tab a code editor field where you can create transient and short-lived projections for quick analysis of your event streams. Persistent subscriptions The Persistent Subscriptions tab shows an overview of persistent subscriptions configured on streams. The button above the list do the following: New Subscription : Create a new subscriptions Clicking the + icon next to a stream name reveals the subscription name and more buttons. The Back button takes you to the parent screen. : Edit : Edit the subscription. Delete : Delete the subscription. Detail : Shows the subscription configuration options. Replay Parked Messages : Replay events in subscription to return state. Admin The Admin tab shows sub systems enabled (currently only projections ) on Event Store and scavenges run. You can start a new scavenge operation by clicking the Scavenge button, and shut Event Store down by clicking the Shutdown Server button. Users The Users tab shows the users defined in Event Store , clicking an individual user shows a JSON representation of that users details. Log out Logs you out of the Admin UI interface."
  },
  "server/system-streams/index.html": {
    "href": "server/system-streams/index.html",
    "title": "System stream and event types | Event Store",
    "keywords": "System stream and event types $persistentSubscriptionConfig $persistentSubscriptionConfig is a special paged stream that contains all configuration events, for all persistent subscriptions. It uses the following system event types: PersistentConfig : An event that records a configuration event, the event data contains: version : Version of event data updated : Updated date updatedBy : User who updated configuration maxCount : The number of configuration events to save entries : Configuration items set by event. Find more details of configuration items for the .NET API and the HTTP API . $all $all is a special paged stream for all events. You can use the same paged form of reading described above to read all events for a node by pointing the stream at /streams/$all . As it's a stream like any other, you can perform all operations, except posting to it. $settings The $settings stream has a special ACL used as the default ACL. This stream controls the default ACL for streams without an ACL and also controls who can create streams in the system, the default state of these is shown below: { \"$userStreamAcl\": { \"$r\": \"$all\", \"$w\": \"$all\", \"$d\": \"$all\", \"$mr\": \"$all\", \"$mw\": \"$all\" }, \"$systemStreamAcl\": { \"$r\": \"$admins\", \"$w\": \"$admins\", \"$d\": \"$admins\", \"$mr\": \"$admins\", \"$mw\": \"$admins\" } } You can rewrite these to the $settings stream with the following cURL command: curl -i \"http://127.0.0.1:2113/streams/%24settings\" \\ --user admin:changeit \\ -H \"Content-Type: application/vnd.eventstore.events+json\" \\ -d $'[{ \"eventId\": \"7c314750-05e1-439f-b2eb-f5b0e019be72\", \"eventType\": \"update-default-acl\", \"data\": { \"$userStreamAcl\" : { \"$r\" : [\"$admin\", \"$ops\", \"service-a\", \"service-b\"], \"$w\" : [\"$admin\", \"$ops\", \"service-a\", \"service-b\"], \"$d\" : [\"$admin\", \"$ops\"], \"$mr\" : [\"$admin\", \"$ops\"], \"$mw\" : [\"$admin\", \"$ops\"] }, \"$systemStreamAcl\" : { \"$r\" : \"$admins\", \"$w\" : \"$admins\", \"$d\" : \"$admins\", \"$mr\" : \"$admins\", \"$mw\" : \"$admins\" } } }]' The $userStreamAcl controls the default ACL for user streams, while all system streams use the $systemStreamAcl as the default. Note The $w in $userStreamAcl also applies to the ability to create a stream. Members of $admins always have access to everything, you cannot remove this permission. When you set a permission on a stream, it overrides the default values. However, it's not necessary to specify all permissions on a stream. It's only necessary to specify those which differ from the default. $stats Event Store has debug and statistics information available about a cluster in the $stats stream, find out more in the stats guide . $scavenges $scavenges is a special paged stream for all scavenge related events. It uses the following system event types: $scavengeIndexInitialized : An event that records the initialisation of the scavenge index. $scavengeStarted : An event that records the beginning of a scavenge event, the event data contains: scavengeId : Scavenge event ID nodeEndpoint : Node address $scavengeCompleted : An event that records the completion of a scavenge event, the event data contains: scavengeId : Scavenge event ID nodeEndpoint : Node address result : Success , Failed , Stopped error : Error details timeTaken : Time taken for the scavenge event in milliseconds spaceSaved : Space saved by scavenge event in bytes"
  },
  "projections/user-defined-projections/index.html": {
    "href": "projections/user-defined-projections/index.html",
    "title": "User defined projections | Event Store",
    "keywords": "User defined projections <!-- TODO: Again refactor to shopping cart? --> You write user defined projections in JavaScript. For example, the my_demo_projection_result projection below counts the number of myEventType events from the account-1 stream. It then uses the transformBy function to change the final state: options({ resultStreamName: \"my_demo_projection_result\", $includeLinks: false, reorderEvents: false, processingLag: 0 }) fromStream('account-1') .when({ $init:function(){ return { count: 0 } }, myEventType: function(state, event){ state.count += 1; } }) .transformBy(function(state){ state.count = 10; }) .outputState() <!-- TODO: Show example output, see above comment --> User defined projections API Options Name Description Notes resultStreamName Overrides the default resulting stream name for the outputState() transformation, which is $projections-{projection-name}-result . $includeLinks Configures the projection to include/exclude link to events. Default: false processingLag When reorderEvents is enabled, this value is used to compare the total milliseconds between the first and last events in the buffer and if the value is equal or greater, the events in the buffer are processed. The buffer is an ordered list of events. Default: 500ms Only valid for fromStreams() selector reorderEvents Process events by storing a buffer of events ordered by their prepare position Default: false Only valid for fromStreams() selector Selectors Selector Description Notes fromAll() Selects events from the $all stream. Provides partitionBy when foreachStream outputState fromCategory({category}) Selects events from the $ce-{category} stream. Provides partitionBy when foreachStream outputState fromStream({streamId}) Selects events from the {streamId} stream. Provides partitionBy when outputState fromStreams([]streams) Selects events from the streams supplied. Provides partitionBy when outputState fromStreamsMatching(function filter) Selects events from the $all stream that returns true for the given filter. Provides when Filters/Transformations Filter/Partition Description Notes when(handlers) Allows only the given events of a particular to pass through the projection. Provides $defines_state_transform transformBy filterBy outputTo outputState foreachStream() Partitions the state for each of the streams provided. Provides when outputState() If the projection maintains state, setting this option produces a stream called $projections-{projection-name}-result with the state as the event body. Provides transformBy filterBy outputTo partitionBy(function(event)) Partitions a projection by the partition returned from the handler. Provides when transformBy(function(state)) Provides the ability to transform the state of a projection by the provided handler. Provides transformBy filterBy outputState outputTo filterBy(function(state)) Causes projection results to be null for any state that returns a false value from the given predicate. Provides transformBy filterBy outputState outputTo Handlers Each handler is provided with the current state of the projection as well as the event that triggered the handler. The event provided through the handler contains the following properties. isJson : true/false data : {} body : s{} bodyRaw : string sequenceNumber : integer metadataRaw : {} linkMetadataRaw : string partition : string eventType : string Handler Description Notes {event-type} When using fromAll() and 2 or more event type handlers are specified and the $by_event_type projection is enabled and running, the projection starts as a fromStreams($et-event-type-foo, $et-event-type-bar) until the projection has caught up and moves to reading from the transaction log (i.e. from $all ). $init Provide the initialization for a projection. Commonly used to setup the initial state for a projection. $initShared Provide the initialization for a projection where the projection is possibly partitioned. $any Event type pattern match that match any event type. Commonly used when the user is interested in any event type from the selector. $deleted Called upon the deletion of a stream. Can only be used with foreachStream Functions Name Description Notes emit(streamId, eventType, eventBody, metadata) Writes an event to the designated stream linkTo(streamId, event, metadata) Writes a link to event to the designated stream"
  },
  "projections/system-projections/index.html": {
    "href": "projections/system-projections/index.html",
    "title": "System projections | Event Store",
    "keywords": "System projections <!-- TODO: retrofit to shopping cart examples? --> Event Store ships with four built in projections. By Category ( $by_category ) By Event Type ( $by_event_type ) By Correlation ID ( $by_correlation_id ) Stream by Category ( $stream_by_category ) Streams ( $streams ) Enabling system projections When you start Event Store from a fresh database, these projections are present but disabled and querying their statuses returns Stopped . You can enable a projection by issuing a request which switches the status of the projection from Stopped to Running . HTTP API .NET Client curl -i -X POST \"http://{event-store-ip}:{ext-http-port}/projection/{projection-name}/command/enable\" -H \"accept:application/json\" -H \"Content-Length:0\" -u admin:changeit <!-- TODO: Is there a .NET equivelant? --> By category The $by_category ( http://127.0.0.1:2113/projection/$by_category ) projection links existing events from streams to a new stream with a $ce- prefix (a category) by splitting a stream id by a configurable separator. first - You can configure the separator, as well as where to split the stream id . You can edit the projection and provide your own values if the defaults don't fit your particular scenario. The first parameter specifies how the separator is used, and the possible values for that parameter is first or last . The second parameter is the separator, and can be any character. For example, if the body of the projection is first and - , for a stream id of account-1 , the stream name the projection creates is $ce-account . If the body of the projection is last and - , for a stream id of shopping-cart-1 , the stream name the projection creates is $ce-shopping-cart . The use case of this project is subscribing to all events within a category. By event type The $by_event_type ( http://127.0.0.1:2113/projection/$by_event_type ) projection links existing events from streams to a new stream with a stream id in the format $et-{event-type} . You cannot configure this projection. By correlation ID The $by_correlation_id ( http://127.0.0.1:2113/projection/$by_correlation_id ) projection links existing events from projections to a new stream with a stream id in the format $bc-<correlation id> . The projection takes one parameter, a JSON string as a projection source: {\"correlationIdProperty\":\"$myCorrelationId\"} Stream by category The $stream_by_category ( http://127.0.0.1:2113/projection/$by_category ) projection links existing events from streams to a new stream with a $category prefix by splitting a stream id by a configurable separator. first - By default the $stream_by_category projection links existing events from a stream id with a name such as account-1 to a stream called $category-account . You can configure the separator as well as where to split the stream id . You can edit the projection and provide your own values if the defaults don't fit your particular scenario. The first parameter specifies how the separator is used, and the possible values for that parameter is first or last . The second parameter is the separator, and can be any character. For example, if the body of the projection is first and - , for a stream id of account-1 , the stream name the projection creates is $category-account , and the account-1 stream is linked to it. Future streams prefixed with account- are likewise linked to the newly created $category-account stream. If the body of the projection is last and - , for a stream id of shopping-cart-1 , the stream name the projection creates is $category-shopping-cart , and the shopping-cart-1 stream is linked to it. Future streams whose left-side split by the last '-' is shopping-cart , are likewise linked to the newly created $category-shopping-cart stream. The use case of this projection is subscribing to all stream instances of a category. Streams The $streams ( http://127.0.0.1:2113/projection/$streams ) projection links existing events from streams to a stream named $streams You cannot configure this projection."
  },
  "projections/projections-config/index.html": {
    "href": "projections/projections-config/index.html",
    "title": "Configuring projections | Event Store",
    "keywords": "Configuring projections <!-- TODO: And how do you change them? UI, .NET, HTTP etc --> By changing these settings, you can lessen the amount of pressure projections put on an Event Store node or improve projection performance. You can change these settings on a case-by-case basis, and monitor potential improvements. Note You can only change the configuration of a stopped projection. You change the configuration of a projection by setting the relevant key and value in a request, or when you create a projection with the web admin interface. HTTP API .NET Client <!-- TODO: Further explanation here --> curl -i --data-binary \"@xbox-one-s-counter.json\" http://localhost:2113/projections/continuous?name=xbox-one-s-counter%26type=js%26enabled=true%26emit=true%26trackemittedstreams=true -u admin:changeit <!-- TODO: Further explanation here --> PersistentSubscriptionSettings settings = PersistentSubscriptionSettings.Create() .DoNotResolveLinkTos() .StartFromCurrent(); conn.CreatePersistentSubscriptionAsync(streamName, \"examplegroup\", settings, adminCredentials).Wait(); <!-- ## [JVM Client](#tab/tabid-7) --> <!-- TODO: Exists? --> Emit options These options control how projections write events. In busy systems, projections can put a lot of extra pressure on the master node. This is especially true for Event Store servers that also have persistent subscriptions running, which only the master node can process. If you see a lot of commit timeouts and slow writes from your projections and other clients, then start with these settings. Emit enabled The emit boolean setting determines whether a projection can emit events and any projection that calls emit() or linkTo() requires it. If this option is not set and a projection attempts to emit events, you see an error message like the following: <!-- TODO: Is it emit or emitenabled? Or are .NET and HTTP different --> 'emit' is not allowed by the projection/configuration/mode Event Store disables this setting by default, and is usually set when you create the projection and if you need the projection to emit events. Track emitted streams The trackemittedstreams boolean setting enables tracking of a projection's emitted streams. It only has an affect if the projection has EmitEnabled enabled. Tracking emitted streams enables you to delete a projection and all the streams that it has created. You should only the setting if you intend to delete a projection and create new ones that project to the same stream. Warning By default Event Store disables the trackemittedstreams setting for projections. When enabled, an event written records the stream name (in $projections-{projection_name}-emittedstreams ) of each event emitted by the projection. This means that write amplification is a possibility, as each event that the projection emits writes a separate event. As such, this option is not recommended for projections that emit a lot of events, and you should enable only where necessary. Tip Between Event Store versions 3.8.0 and 4.0.2, this option was enabled by default when a projection was created through the UI. If you have any projections created during this time frame, it's worth checking whether this option is enabled. Max allowed writes in flight <!-- TODO: Why is this not in the GUI for new projection? --> <!-- TODO: Is the setting name correct? Especially in HTTP --> The AllowedInFlightMessages setting sets the maximum number of writes to allow for a projection. Because a projection can write to multiple different streams, it's possible for the projection to send multiple writes at the same time. This option sets the number of concurrent writes that a projection can perform. By default, projections try to perform writes as quickly as they come. This can add a lot of pressure to a node, especially for projections that emit to many different streams. If you see your projections causing frequent commit timeouts or slow reads, you can try lowering this value to see if there is any improvement. Note Lower values may cause the projection to slow down as the number of writes are throttled, but the trade off for this is cleaner logs and fewer commit timeouts. By default, this is unbounded, allowing a projection to write as fast as it can. Max write batch length <!-- TODO: Why is this not in the GUI for new projection? --> <!-- TODO: Is the setting name correct? Especially in HTTP --> The MaxWriteBatchLength setting sets the maximum number of events the projection can write in a batch at a time. The default for this option is 500. Checkpoint options Checkpoints store how far along a projection is in the streams it is processing from. There is a performance overhead with writing a checkpoint, as it does more than write an event, and writing them too often can slow projections down. We recommend you try other methods of improving projections before changing these values, as checkpoints are an important part of running projections. Checkpoint after Ms The CheckpointAfterMs setting prevents a new checkpoint from being written within a certain time frame from the previous one. The setting is to keep a projection from writing too many checkpoints too quickly, something that can happen in a busy system. The default setting is 0 seconds, which means there is no limit to how quickly checkpoints can be written. Checkpoint handled threshold The CheckpointHandledThreshold setting controls the number of events that a projection can handle before attempting to write a checkpoint. An event is considered handled if it actually passed through the projection's filter. If the projection is set to checkpoint every 4,000 events, but it only reads from the foo stream, the projection only checkpoints every 4,000 foo events. The default setting is 4,000 events. Checkpoint unhandled bytes threshold The CheckpointUnhandledBytesThreshold setting specifies the number of bytes a projection can process before attempting to write a checkpoint. Unhandled bytes are the events that are not processed by the projection itself. For example, if the projection reads from the foo stream, but writes from the bar stream comes through, a checkpoint is written after this number of bytes have been processed. This prevents the projection from having to read through a potentially large number of unrelated events again because none of them passed its filter. The default setting is 10mb. Processing options Pending events threshold The PendingEventsThreshold setting determines the number of events that can be pending before the projection is paused. Pausing the projection stops the projection from reading, allowing it to finish with the current events that are waiting to be processed. Once the pending queue has drained to half the threshold, the projection starts reading again. The default setting is 5000."
  },
  "projections/index.html": {
    "href": "projections/index.html",
    "title": "Introduction to projections | Event Store",
    "keywords": "Introduction to projections Projections is an Event Store subsystem that lets you write new events or link existing events to streams in a reactive manner. Projections are good at solving one specific query type, a category known as 'temporal correlation queries'. This query type is common in business systems and few can execute these queries well. Note Projections require the event body to be in JSON. Business case examples For example. You are looking for how many Twitter users said \"happy\" within 5 minutes of the word \"foo coffee shop\" and within 2 minutes of saying \"london\". This is the type of query that projections can solve. Let's try a more complex business problem. As a medical research doctor you want to find people diagnosed with pancreatic cancer within the last year. During their treatment a patient should not have had any proxies for a heart condition such as taking aspirin every morning. Within three weeks of their diagnosis they should have been put on treatment X. Within one month after starting the treatment they should have failed with a lab result that looks like L1. Within another six weeks they should have been put on treatment Y, and within four weeks failed that treatment with a lab result that looks like L2. You can use projections in nearly all examples of near real-time complex event processing. There are a large number of problems that fit into this category from monitoring of temperature sensors, to reacting to changes in the stock market. It's important to remember the types of problems that projections help to solve. Many problems are not a good fit for projections and are better served by hosting another read model populated by a catchup subscription . Continuous querying Projections support the concept of continuous queries. When running a projection you can choose whether the query should run and give you all results present, or whether the query should continue running into the future finding new results as they happen and updating its result set. In the medical example above the doctor could leave the query running to be notified of any new patients that meet the criteria. The output of all queries is a stream, this stream can be listened to like any other stream. Types of projections There are two types of projections in Event Store: Built in (system) projections written in C#. User-defined JavaScript projections which you create via the API or the admin UI."
  },
  "http-api/optional-http-headers/requires-master/index.html": {
    "href": "http-api/optional-http-headers/requires-master/index.html",
    "title": "Optional HTTP Headers: Requires Master | Event Store",
    "keywords": "Optional HTTP Headers: Requires Master When running in a clustered environment there are times when you only want an operation to happen on the current leader node. A client can fetch information in an eventually consistent fashion by communicating with the servers. The TCP client included with the multi-node version does this. Over HTTP the RequiresMaster header tells the node that it is not allowed to serve a read or forward a write request. If the node is the leader everything works as normal, if it isn't it responds with a 307 temporary redirect to the leader. Run the below on the master: Request Response curl -i \"http://127.0.0.1:32004/streams/newstream\" -H \"ES-RequireMaster: True\" HTTP/1.1 200 OK Cache-Control: max-age=0, no-cache, must-revalidate Content-Length: 1296 Content-Type: application/vnd.eventstore.atom+json; charset: utf-8 ETag: \"0;-2060438500\" Vary: Accept Server: Microsoft-HTTPAPI/2.0 Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER Access-Control-Allow-Origin: * Date: Thu, 27 Jun 2013 14:48:37 GMT { \"title\": \"Event stream 'stream'\", \"id\": \"http://127.0.0.1:32004/streams/stream\", \"updated\": \"2013-06-27T14:48:15.2596358Z\", \"streamId\": \"stream\", \"author\": { \"name\": \"EventStore\" }, \"links\": [ { \"uri\": \"http://127.0.0.1:32004/streams/stream\", \"relation\": \"self\" }, { \"uri\": \"http://127.0.0.1:32004/streams/stream/head/backward/20\", \"relation\": \"first\" }, { \"uri\": \"http://127.0.0.1:32004/streams/stream/0/forward/20\", \"relation\": \"last\" }, { \"uri\": \"http://127.0.0.1:32004/streams/stream/1/forward/20\", \"relation\": \"previous\" }, { \"uri\": \"http://127.0.0.1:32004/streams/stream/metadata\", \"relation\": \"metadata\" } ], \"entries\": [ { \"title\": \"0@stream\", \"id\": \"http://127.0.0.1:32004/streams/stream/0\", \"updated\": \"2013-06-27T14:48:15.2596358Z\", \"author\": { \"name\": \"EventStore\" }, \"summary\": \"TakeSomeSpaceEvent\", \"links\": [ { \"uri\": \"http://127.0.0.1:32004/streams/stream/0\", \"relation\": \"edit\" }, { \"uri\": \"http://127.0.0.1:32004/streams/stream/0\", \"relation\": \"alternate\" } ] } ] } Run the following on any other node: Request Response curl -i \"http://127.0.0.1:31004/streams/newstream\" -H \"ES-RequireMaster: True\" HTTP/1.1 307 Temporary Redirect Content-Length: 0 Content-Type: text/plain; charset: utf-8 Location: http://127.0.0.1:32004/streams/stream Server: Microsoft-HTTPAPI/2.0 Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER Access-Control-Allow-Origin: * Date: Thu, 27 Jun 2013 14:48:28 GMT"
  },
  "http-api/optional-http-headers/longpoll/index.html": {
    "href": "http-api/optional-http-headers/longpoll/index.html",
    "title": "Optional HTTP Headers: LongPoll | Event Store",
    "keywords": "Optional HTTP Headers: LongPoll You use the ES-LongPoll header to tell Event Store that when on the head link of a stream and no data is available to wait a period of time to see if data becomes available. You can use this to give lower latency for Atom clients instead of client initiated polling. Instead of the client polling every 5 seconds to get data from the feed the client sends a request with ES-LongPoll: 15 . This instructs Event Store to wait for up to 15 seconds before returning with no result. The latency is therefore lowered from the poll interval to about 10ms from the time an event is written until the time the HTTP connection is notified. You can see the use of the ES-LongPoll header in the following cURL command. First go to the head of the stream. Request Response curl -i http://127.0.0.1:2113/streams/newstream -H \"Accept: application/json\" HTTP/1.1 200 OK Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Cache-Control: max-age=0, no-cache, must-revalidate Vary: Accept ETag: \"1;1391431453\" Content-Type: application/json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Mon, 27 Aug 2018 09:37:21 GMT Content-Length: 1749 Keep-Alive: timeout=15,max=100 { \"title\": \"Event stream 'newstream'\", \"id\": \"http://127.0.0.1:2113/streams/newstream\", \"updated\": \"2018-08-27T09:21:39.668888Z\", \"streamId\": \"newstream\", \"author\": { \"name\": \"EventStore\" }, \"headOfStream\": true, \"selfUrl\": \"http://127.0.0.1:2113/streams/newstream\", \"eTag\": \"1;-2060438500\", \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream\", \"relation\": \"self\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/head/backward/20\", \"relation\": \"first\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/2/forward/20\", \"relation\": \"previous\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/metadata\", \"relation\": \"metadata\" } ], \"entries\": [ \"entries\": [ ] } Then fetch the previous rel link http://127.0.0.1:2113/streams/newstream/2/forward/20 and try it. It returns an empty feed. Request Response curl -i http://127.0.0.1:2113/streams/newstream/2/forward/20 -H \"Accept: application/json\" HTTP/1.1 200 OK Access-Control-Allow-Methods: GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Cache-Control: max-age=0, no-cache, must-revalidate Vary: Accept ETag: \"1;1391431453\" Content-Type: application/json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Mon, 27 Aug 2018 09:53:14 GMT Content-Length: 786 Keep-Alive: timeout=15,max=100 { \"title\": \"Event stream 'newstream'\", \"id\": \"http://127.0.0.1:2113/streams/newstream\", \"updated\": \"0001-01-01T00:00:00Z\", \"streamId\": \"newstream\", \"author\": { \"name\": \"EventStore\" }, \"headOfStream\": true, \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream\", \"relation\": \"self\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/head/backward/20\", \"relation\": \"first\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/0/forward/20\", \"relation\": \"last\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/1/backward/20\", \"relation\": \"next\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/metadata\", \"relation\": \"metadata\" } ], \"entries\": [] } The entries section is empty (there is no further data to provide). Now try the same URI with a long poll header. Request curl -i http://127.0.0.1:2113/streams/newstream/2/forward/20 -H \"Accept: application/json\" -H \"ES-LongPoll: 10\" If you do not insert any events into the stream while this is running it takes 10 seconds for the HTTP request to finish. If you append an event to the stream while its running you see the result for that request when you append the event."
  },
  "http-api/optional-http-headers/index.html": {
    "href": "http-api/optional-http-headers/index.html",
    "title": "Optional HTTP headers | Event Store",
    "keywords": "Optional HTTP headers <!-- TODO: Can Swagger replace this? And sub files --> Event Store supports custom HTTP headers for requests. The headers were previously in the form X-ES-ExpectedVersion but were changed to ES-ExpectedVersion in compliance with RFC-6648 . The headers supported are: Header Description ES-ExpectedVersion The expected version of the stream (allows optimistic concurrency) ES-ResolveLinkTo Whether to resolve linkTos in stream ES-RequiresMaster Whether this operation needs to run on the master node ES-TrustedAuth Allows a trusted intermediary to handle authentication ES-LongPoll Instructs the server to do a long poll operation on a stream read ES-HardDelete Instructs the server to hard delete the stream when deleting as opposed to the default soft delete ES-EventType Instructs the server the event type associated to a posted body ES-EventId Instructs the server the event id associated to a posted body"
  },
  "http-api/optional-http-headers/harddelete/index.html": {
    "href": "http-api/optional-http-headers/harddelete/index.html",
    "title": "Optional HTTP Headers: HardDelete | Event Store",
    "keywords": "Optional HTTP Headers: HardDelete The ES-HardDelete header controls deleting a stream. By default Event Store soft deletes a stream allowing you to later reuse that stream. If you set the ES-HardDelete header Event Store permanently deletes the stream. Request Response curl -X DELETE http://127.0.0.1:2113/streams/newstream -H \"ES-HardDelete:true\" HTTP/1.1 204 Stream deleted Content-Length: 0 Content-Type: text/plain; charset=utf-8 Server: Microsoft-HTTPAPI/2.0 Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER, Authorization Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location Date: Thu, 13 Mar 2014 20:56:55 GMT This changes the general behaviour from returning a '404' and recreatable to the stream now return a 410 Deleted response."
  },
  "http-api/optional-http-headers/eventid/index.html": {
    "href": "http-api/optional-http-headers/eventid/index.html",
    "title": "Optional HTTP headers: EventID | Event Store",
    "keywords": "Optional HTTP headers: EventID When you write to a stream and don't use the application/vnd.eventstore.events+json/+xml media type, you need to specify an event ID with the event you post. This is not required with the custom media type as it is specified within the format (there is an EventId on each entry in the format). Event Store uses EventId for impotency. You can include an event ID on an event by specifying this header. Request Response curl -i -d \"@event.json\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/json\" -H \"ES-EventType: SomeEvent\" -H \"ES-EventId: C322E299-CB73-4B47-97C5-5054F920746E\" HTTP/1.1 201 Created Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER Access-Control-Allow-Origin: * Location: http://127.0.0.1:2113/streams/newstream/0 Content-Type: text/plain; charset: utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 28 Jun 2013 12:17:59 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 If you don't add an ES-EventId header on an append where the body is considered the actual event (e.g., not using application/vnd.eventstore.events+json/+xml ) Event Store generates a unique identifier for you and redirects you to an idempotent URI where you can post your event. If you can create a UUID then you shouldn't use this feature, but it's useful when you cannot create a UUID. Request Response curl -i -d \"@event.json\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/json\" -H \"ES-EventType: SomeEvent\" HTTP/1.1 307 Temporary Redirect Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Location: http://127.0.0.1:2113/streams/newstream/incoming/8a00e469-3a99-4517-a0b0-8dc662ffad9b Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Tue, 24 Jul 2018 14:42:44 GMT Content-Length: 28 Keep-Alive: timeout=15,max=100 Forwarding to idempotent URI% Event Store returned a 307 Temporary Redirect with a location header that points to a generated URI that is idempotent for purposes of retrying the post."
  },
  "http-api/creating-writing-a-stream/index.html": {
    "href": "http-api/creating-writing-a-stream/index.html",
    "title": "Creating and writing to a stream | Event Store",
    "keywords": "Creating and writing to a stream You write to a stream over HTTP using a POST request to the resource of the stream. If the stream does not exist then the stream is implicitly created. Event Store media types Event Store supports a custom media type for posting events, application/vnd.eventstore.events+json or application/vnd.eventstore.events+xml . This format allows for extra functionality that posting events as application/json or application/xml does not. For example it allows you to post multiple events in a single batch. <!-- TODO: And more? Why not use it? And why are these examples not using it? --> The format represents data with the following jschema ( eventId must be a UUID). [ { \"eventId\" : \"string\", \"eventType\" : \"string\", \"data\" : \"object\", \"metadata\" : \"object\" } ] Writing a single event If you issue a POST request with data to a stream and the correct content type set it writes the event to the stream, and generates a 201 response from the server, giving you the location of the event. Using the following event, which you can also download as a file : { \"a\": \"1\" } POST the following request to create a stream and add an event to it: Request Response curl -i -d \"@event.json\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/json\" -H \"ES-EventType: SomeEvent\" -H \"ES-EventId: C322E299-CB73-4B47-97C5-5054F920746E\" HTTP/1.1 201 Created Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER Access-Control-Allow-Origin: * Location: http://127.0.0.1:2113/streams/newstream/0 Content-Type: text/plain; charset: utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 28 Jun 2013 12:17:59 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 Some clients may not be able to generate a unique identifier (or may not want to) for the event ID. You need this ID for idempotence purposes and Event Store can generate it for you. If you leave off the ES-EventId header you see different behavior: Request Response curl -i -d \"@event.json\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/json\" -H \"ES-EventType: SomeEvent\" HTTP/1.1 307 Temporary Redirect Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Location: http://127.0.0.1:2113/streams/newstream/incoming/8a00e469-3a99-4517-a0b0-8dc662ffad9b Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Tue, 24 Jul 2018 14:42:44 GMT Content-Length: 28 Keep-Alive: timeout=15,max=100 Forwarding to idempotent URI% In this case Event Store has responded with a 307 Temporary Redirect . The location points to another URI that you can post the event to. This new URI is idempotent for posting, even without an event ID. Request Response curl -i -d \"@event.json\" \"http://127.0.0.1:2113/streams/newstream/incoming/8a00e469-3a99-4517-a0b0-8dc662ffad9b\" -H \"Content-Type: application/json\" -H \"ES-EventType: SomeEvent\" HTTP/1.1 201 Created Access-Control-Allow-Methods: GET, POST, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Location: http://127.0.0.1:2113/streams/newstream/0 Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Tue, 24 Jul 2018 14:46:10 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 It's generally recommended to include an event ID if possible as it results in fewer round trips between the client and the server. When posting to either the stream or to the returned redirect, clients must include the EventType header. If you forget to include the header you receive an error. Request Response curl -i -d \"@event.json\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/json\" HTTP/1.1 400 Must include an event type with the request either in body or as ES-EventType header. Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Content-Type: Server: Mono-HTTPAPI/1.0 Date: Tue, 24 Jul 2018 14:50:59 GMT Content-Length: 0 Connection: close Batch writes You can include more than one write in a single post by placing multiple events inside of the array representing the events, including metadata. For example, the below has two events: [ { \"eventId\": \"fbf4b1a1-b4a3-4dfe-a01f-ec52c34e16e4\", \"eventType\": \"event-type\", \"data\": { \"a\": \"1\" } }, { \"eventId\": \"0f9fad5b-d9cb-469f-a165-70867728951e\", \"eventType\": \"event-type\", \"data\": { \"b\": \"2\" } } ] When you write multiple events in a single post, Event Store treats them transactionally, it writes all events together or fails. Request Response curl -i -d \"@multiple-events.json\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/vnd.eventstore.events+json\" HTTP/1.1 201 Created Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER Access-Control-Allow-Origin: * Location: http://127.0.0.1:2113/streams/newstream/1 Content-Type: text/plain; charset: utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 28 Jun 2013 12:32:18 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 Appending events To append events, issue a POST request to the same resource with a new eventId : [ { \"eventId\": \"fbf4a1a1-b4a3-4dfe-a01f-ec52c34e16e5\", \"eventType\": \"event-type\", \"data\": { \"b\": \"2\" } } ] Request Response curl -i -d \"@event-append.json\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/vnd.eventstore.events+json\" -H \"ES-EventType: SomeEvent\" HTTP/1.1 201 Created Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER Access-Control-Allow-Origin: * Location: http://127.0.0.1:2113/streams/newstream/1 Content-Type: text/plain; charset: utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 28 Jun 2013 12:32:18 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 Data-only events Version 3.7.0 of Event Store added support for the application/octet-stream content type to support data-only binary events. When creating these events, you need to provide the ES-EventType and ES-EventId headers and cannot have metadata associated with the event. In the example below SGVsbG8gV29ybGQ= is the data you POST to the stream: Request Response curl -i -d \"SGVsbG8gV29ybGQ=\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/octet-stream\" -H \"ES-EventType:rawDataType\" -H \"ES-EventId:eeccf3ce-4f54-409d-8870-b35dd836cca6\" HTTP/1.1 201 Created Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTo, ES-ExpectedVersion Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position Location: http://127.0.0.1:2113/streams/newstream/0 Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Mon, 27 Jun 2016 13:15:27 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 Expected version header The expected version header represents the version of the stream you expect. For example if you write to a stream at version 1, then you expect it to be at version 1 next time you write. This can allow for optimistic locking when multiple applications are reading/writing to streams. If your expected version is not the current version you receive an HTTP status code of 400. Warning See the idempotency section below, if you post the same event twice it is idempotent and won't return a version error. First write an event to a stream, setting a version: [ { \"eventId\": \"fbf4b1a1-b4a3-4dfe-a01f-ec52c34e16e4\", \"eventType\": \"event-type\", \"data\": { \"a\": \"1\" } } ] Download Request Response curl -i -d @event-version.json \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/vnd.eventstore.events+json\" -H \"ES-CurrentVersion: 0\" HTTP/1.1 201 Created Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Location: http://127.0.0.1:2113/streams/newstream/2 Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Tue, 14 Aug 2018 10:02:08 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 If you now write to the stream with the incorrect version, you receive an HTTP status code 400 error. Request Response curl -i -d @event-version.json \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/vnd.eventstore.events+json\" -H \"ES-ExpectedVersion: 3\" HTTP/1.1 400 Wrong expected EventNumber Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion ES-CurrentVersion: 0 Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Tue, 14 Aug 2018 14:08:44 GMT Content-Length: 0 Connection: close There are special values you can use in the expected version header: -2 states that this write should never conflict and should always succeed. -1 states that the stream should not exist at the time of the writing (this write creates it). 0 states that the stream should exist but should be empty. Idempotency Appends to streams are idempotent based upon the EventId assigned in your post. If you were to re-run the last command it returns the same value again. This is important behaviour as it's how you implement error handling. If you receive a timeout, broken connection, no answer, etc from your HTTP POST then it's your responsibility to retry the post. You must also keep the same UUID that you assigned to the event in the first POST . If you are using the expected version parameter with your post, then Event Store is 100% idempotent. If you use -2 as your expected version value, Event Store does its best to keep events idempotent but cannot assure that everything is fully idempotent and you end up in 'at-least-once' messaging. Read this guide for more details on idempotency."
  },
  "event-sourcing-basics/events-as-a-storage-mechanism/index.html": {
    "href": "event-sourcing-basics/events-as-a-storage-mechanism/index.html",
    "title": "Events as a storage mechanism | Event Store",
    "keywords": "Events as a storage mechanism When most people consider storage for an object they tend to think about it in a structural sense. That is when considering how to store the sale discussed above they think of it as a \"Sale\" that has \"Line Items\" and perhaps \"Shipping Information\" associated with it. This is not the only way to conceptualize the problem and other solutions offer different and often interesting architectural properties. Consider the creation of a small \"Order\" object for a web-based sale system. Most developers would envision something similar to the image below. An \"Order\" has \"n Line Items\" and \"Shipping Information\". <!-- ![A simplified structural model of an order][1] --> This is not the only way to view this data. Earlier we discussed the concept of a transaction. Developers deal with the concept of transactions regularly, you can view them as representing the change between a point and the next subsequent point, and they are often referred to as deltas. You can define the delta between two static states, but frequently this is an implicit concept, relegated to a framework such as Hibernate in the Java world or Entity Framework in the Microsoft world. These frameworks save the original state and then calculate the differences with the new state and update the backing data model accordingly. Making these deltas explicit can be valuable for technical and business benefits. You can see the usage of deltas in many mature business models. The canonical example of delta usage is in the field of accounting. When looking at a ledger such as below, each transaction or delta is recorded. Next to it is a denormalized total of the state of the account at the end of that delta. To calculate this value, the current delta is applied to the last known value. The last known value can be trusted because at any given point you could re-run the transactions from the \"beginning of time\" for that account to reconcile the validity of that value. A verifiable audit log always exists. Date Comment Change Current Balance 1/Jan/2000 Deposit from 1372 +10,000.00 10,000.00 3/Jan/2000 Check 1 -4,000.00 6,000.00 4/Jan/2000 Purchase Coffee -3.00 5,997.00 4/Jan/2000 Purchase Internet -5.00 5,992.00 8/Jan/2000 Deposit from 1373 +1,000.00 6,992.00 Because the transactions or deltas associated with the account exist, you can step through them, verifying the result at each stage. You can derive the Current Balance at any point by looking at the Current Balance or by adding up all the Changes since the beginning of time for the account. The second property is valuable in a domain such as accounting as accountants are dealing with money and the ability to check that calculations were performed correctly is invaluable. It was more valuable before computers when it was common place to have an exhausted accountant make a mistake in a calculation at 3am when they should be sleeping. There are other interesting properties to this mechanism of representing state. As an example, it's possible to go back and look at what a state was at a given. Consider for example, that the account has reached a balance below zero and there is a rule that says it's not supposed to. It is relatively easy to view the state the account was in prior to processing the transaction that put it into the invalid state. This makes it far easier to reproduce what often end up as heisenbugs in other circumstances. These types of benefits are not only limited to naturally transaction based domains. Every domain is a naturally transaction-based domain when Domain Driven Design is applied. When applying Domain Driven Design there is a heavy focus on behaviours normally coinciding with use cases, Domain Driven Design is interested in how users use the system. Returning to the order example from earlier, you could represent the same order in the form of a transactional model as below: <!-- ![Transactional view of an order][2] --> You can apply this to any type of object. By replaying through the events, you can return the object to the last known state. It is mathematically equivalent to storing the end of the equation or the equation that represents it. There is a structural representation of the object but it exists only by replaying previous transactions to return the structure to its last known state. Data is not persisted in a structure but as a series of transactions. One interesting possibility is that unlike when storing current state in a structural way, there is no coupling between the representation of current state in the domain and in storage. The representation of current state in the domain can vary without thought of the persistence mechanism. It is important to note the language in Figure 3. All of the verbs are in the past tense. These are Domain Events. Consider what would happen if the language were in the imperative tense, \"Add 2 socks item 137\", \"Create Cart\". What if there were behaviours associated with adding an item, such as reserving it from an inventory system via a webservice call? Should you include these behaviours when reconstituting an object? What if logic has changed so that this item could no longer be added given the context? This is one of many examples where dual contexts between commands and events are required, there is a contextual difference between returning to a given state and attempting to transition to a new one. There is no delete A common question that arises is how to delete information. It is not possible, as previously, to jump into the time machine and say that an event never happened (e.g. delete a previous event). As such, it is necessary to model a delete explicitly as a new transaction as shown below. Further discussion on the business value of handling deletes in this mechanism can be found in \" Business Value of the Event Log \". <!-- ![Transactional view of an order with delete][3] --> In the event stream above, the two pairs of socks were added then later removed. The end state is equivalent to not having added the two pairs of socks. However, the data was not deleted, new data was added to bring the object to the state as if the first event had not happened, this process is known as a \"Reversal Transaction\". By placing a reversal transaction in the event stream, not only is the object returned to the state as if the item had not been added, the reversal leaves a trail that shows that the object had been in that state at a given point in time."
  },
  "event-sourcing-basics/event-store-as-a-functional-database/index.html": {
    "href": "event-sourcing-basics/event-store-as-a-functional-database/index.html",
    "title": "Event Store as a functional database | Event Store",
    "keywords": "Event Store as a functional database Much of what we have discussed can be looked at through a functional programming perspective as well. For developers in functional languages such as Scala or Haskell this should feel natural to you, for C# developers it should feel familiar, and for Java developers I hear that Scala is a nice language. All kidding aside When we replay an event stream we are returning a series of events. An event is essentially a serialized method call. We left fold something that redefines what those methods mean to us today in order to get our current state. This can be seen explicitly when looking at how the projections work in JavaScript. We define a function as: when([SomePatternMatch], function(state, event) { return new state; }); These functions are then chained over the event stream resulting at the end with a state object. The state is passed from one function to the next allowing each function to transform it. Said differently, Current State is a [left fold][6] of previous facts. We can further continue this to say that a snapshot is nothing but a memoization of the left fold. When looked at from this perspective one could state that an Event Store is actually a functional database."
  },
  "event-sourcing-basics/business-value-of-the-event-log/index.html": {
    "href": "event-sourcing-basics/business-value-of-the-event-log/index.html",
    "title": "Business value of the event log | Event Store",
    "keywords": "Business value of the event log Note The value of an event log is directly correlated with use cases that you would want to use Domain Driven Design in the first place. You should use Domain Driven Design in cases where the business derives competitive advantage. Domain Driven Design itself is difficult and expensive to apply, but a company will receive high ROI on the effort if the domain is complex and if they derive competitive advantage from it. Using an Event Log similarly will have high ROI when dealing with an area of competitive advantage but may have negative ROI in other places. Storing only current state limits organizations to asking certain kinds of questions about the data. For example consider orders in the stock market. They can change for a few reasons. An order can change the volume to buy/sell, the trading system can automatically adjust the volume of an order, or a trade could occur lowering the volume available on the current order. If posed with a question regarding current liquidity, such as the price for a given number of shares in the market, it does not matter which of these changes occurred. It does not matter how the data got the way it was. It matters what it is at a given point in time. A vast majority of queries even in the business world are focused on the what labels to send customers mails, how much was sold in April, how many widgets are in the warehouse. There are however other types of queries that are becoming more and more popular in business. They focus on the how. Examples can commonly be seen in the buzzword Business Intelligence. Perhaps there is a correlation between people having done an action and their likelihood of purchasing some product? These types of questions generally focus on how something came into being as opposed to what it came out to be. It is best to go through an example. There is a development team at a large online retailer. In an iteration planning meeting a domain expert comes up with an idea. He believes that there is a correlation between people having added then removed an item from their cart and their likelihood of responding to suggestions of that product by purchasing it at a later point. The feature is added to the following iteration. The first hypothetical team is utilizing a stereotypical current state based mechanism for storing state. They plan that in this iteration they will add tracking of items via a fact table that are removed from carts. They plan for the next iteration that they will then build a report. The business will receive after the second iteration a report that can show them information back to the previous iteration when the team released the functionality that began tracking items being removed from carts. This is a very stereotypical process. At some organizations the report and the tracking may be released simultaneously but this is a relatively small detail in the handling. From a business perspective the domain experts are happy. They made a request of the team and the team was able to quickly fulfill the request. New functionality has been added in a quick and relatively painless way. The second team will however have quite a different result. The second team has been storing events; they represent their current state by building up off of a series of events. They just like the first team go through and add tracking of items removed from carts via a fact table but they also run this handler from the beginning of the event log to back populate all of the data from the time that the business started. They release the report in the same iteration and the report has data that dates back for years. The second team can do this because they have managed to store what the system actually did as opposed to what the current state of data is. It is possible to go back and look and interpret the old data in new and interesting ways. It was never considered to track what items were removed from carts or perhaps the number of times a user removes and items from their cart was considered important. These are both examples of new and interesting ways of looking at data. As the events represent every action the system has undertaken any possible model describing the system can be built from the events. Businesses regularly come up with new and interesting ways of looking at data. It is not possible with any level of confidence to predict how a business will want to look at todays data in five years. The ability for the business to look at the data in the way that it wants in five years is of an unknown but possibly extremely high value; it has already been stated that this should be done in areas where the business derives its competitive advantage so it is relatively easy to reason that the ability to look at todays data in an unexpected way could be a competitive advantage for the business. How do you value the possible success or failure of a company based upon an architectural decision now? How do software teams justify looking at their Magic 8 Ball to predict what the business will need in five or even ten years? Many try to use YAGNI (You Aint Gonna Need It) but YAGNI only applies when you actually know that you wont need it. How can the dynamic world of business and how they may want to look at data in five or ten years be predicted? Is it more expensive to actually model every behavior in the system? Yes. Is it more expensive in terms of disk cost and thought process to store every event in the system? Yes. Are these costs worth the ROI when the business derives a competitive advantage from the data?"
  },
  "dotnet-api/streams/index.html": {
    "href": "dotnet-api/streams/index.html",
    "title": "Streams | Event Store",
    "keywords": "Streams Writing to a stream You can use the client API to write one or more events to a stream atomically. You do this by appending the events to the stream in one operation, or by starting a transaction on the stream, writing events in one or more operations in that transaction, and then committing the transaction. You can make an optimistic concurrency check during the write by specifying the version at which you expect the stream to be. Identical write operations are idempotent if the optimistic concurrency check is not disabled. You can find more information on optimistic concurrency and idempotence here . Appending to a stream in a single write Task<WriteResult> AppendToStreamAsync(string stream, long expectedVersion, IEnumerable<EventData> events) Task<WriteResult> AppendToStreamAsync(string stream, long expectedVersion, params EventData[] events) Using a transaction to append to a stream across multiple writes On EventStoreConnection Task<EventStoreTransaction> StartTransactionAsync(string stream, long expectedVersion) EventStoreTransaction ContinueTransaction(long transactionId) On EventStoreTransaction Task WriteAsync(IEnumerable<EventData> events) Task WriteAsync(params EventData[] events) Task CommitAsync() void Rollback() EventData The writing methods all use a type named EventData to represent an event to be stored. Instances of EventData are immutable. Event Store does not have any built-in serialisation, so the body and metadata for each event are represented in EventData as a byte[] . The members on EventData are: Member Description Guid EventId A unique identifier representing this event. Event Store uses this for idempotency if you write the same event twice you should use the same identifier both times. string Type The name of the event type. You can use this for pattern matching in projections, so should be a \"friendly\" name rather than a CLR type name, for example. bool IsJson If the data and metadata fields are serialized as JSON, you should set this to true . Setting this to true will cause the projections framework to attempt to deserialize the data and metadata later. byte[] Data The serialized data representing the event to be stored. byte[] Metadata The serialized data representing metadata about the event to be stored. Append to a stream in a single write The AppendToStreamAsync method writes events atomically to the end of a stream, working in an asynchronous manner. The parameters are: Parameter Description string stream The name of the stream to which to append. long expectedVersion The version at which you expect the stream to be in order that an optimistic concurrency check can be performed. This should either be a positive integer, or one of the constants ExpectedVersion.NoStream , ExpectedVersion.EmptyStream , or to disable the check, ExpectedVersion.Any . See here for a broader discussion of this. IEnumerable<EventData> events The events to append. There is also an overload of each method which takes the events as a params array. Deleting a stream Soft delete Task<DeleteResult> DeleteStreamAsync(string stream, long expectedVersion, UserCredentials userCredentials = null); <!-- TODO: Need a better explanation --> By default when you delete a stream, Event Store soft deletes it. You can recreate the stream by appending new events to it. If you try to read a soft deleted stream you receive an error response. Hard Delete You can hard delete a stream. Warning A hard delete is permanent and the stream is not removed during a scavenge. If you hard delete a stream, you cannot recreate the stream. Task<DeleteResult> DeleteStreamAsync(string stream, long expectedVersion, bool hardDelete, UserCredentials userCredentials = null);"
  },
  "dotnet-api/users/index.html": {
    "href": "dotnet-api/users/index.html",
    "title": "User management | Event Store",
    "keywords": "User management The Event Store Client API includes helper methods that use the HTTP API to allow for the management of users. This document describes the methods found in the UsersManager class. All methods in this class are asynchronous. Create a user Creates a user, the credentials for this operation must be a member of the $admins group. public Task CreateUserAsync(string login, string fullName, string[] groups, string password, UserCredentials userCredentials = null) Disable a user Disables a user, the credentials for this operation must be a member of the $admins group. public Task DisableAsync(string login, UserCredentials userCredentials = null) Enable a User Enables a user, the credentials for this operation must be a member of the $admins group. public Task EnableAsync(string login, UserCredentials userCredentials = null) Delete a user Deletes (non-recoverable) a user, the credentials for this operation must be a member of the $admins group. If you prefer this action to be recoverable, disable the user as opposed to deleting the user. public Task DeleteUserAsync(string login, UserCredentials userCredentials = null) List all users Lists all users. public Task<List<UserDetails>> ListAllAsync(UserCredentials userCredentials = null) Get details of user Return the details of the user supplied in user credentials (e.g. the user making the request). public Task<UserDetails> GetCurrentUserAsync(UserCredentials userCredentials) Get details of logged in user public Task<UserDetails> GetUserAsync(string login, UserCredentials userCredentials) Update user details public Task UpdateUserAsync(string login, string fullName, string[] groups, UserCredentials userCredentials = null) Reset user password Resets the password of a user. The credentials doing this operation must be part of the $admins group. public Task ResetPasswordAsync(string login, string newPassword, UserCredentials userCredentials = null)"
  },
  "dotnet-api/stream-metadata/index.html": {
    "href": "dotnet-api/stream-metadata/index.html",
    "title": "Stream metadata | Event Store",
    "keywords": "Stream metadata Every stream in Event Store has metadata stream associated with it, prefixed by $$ , so the metadata stream from a stream called foo is $$foo . Internally, the metadata includes information such as the ACL of the stream and the maximum count and age for the events in the stream. Client code can also put information into stream metadata for use with projections or through the client API. This information is not part of the actual event but is metadata associated with the event. Event Store stores stream metadata as JSON, and you can access it over the HTTP APIs. Read stream metadata To read stream metadata over the .NET API you can use methods found on the EventStoreConnection . You can use the GetStreamMetadata methods in two ways. The first is to return a fluent interface over the stream metadata, and the second is to return you the raw JSON of the stream metadata. Task<StreamMetadataResult> GetStreamMetadataAsync(string stream, UserCredentials userCredentials = null) This returns a StreamMetadataResult . The fields on this result are: Member Description string Stream The name of the stream bool IsStreamDeleted true is the stream is deleted, false otherwise. long MetastreamVersion The version of the metastream format StreamMetadata Metadata A StreamMetadata object representing the metadata JSON You can then access the StreamMetadata via the StreamMetadata object. It contains typed fields for well known stream metadata entries. Member Description long? MaxAge The maximum age of events in the stream. Items older than this will be automatically removed. long? MaxCount The maximum count of events in the stream. When you have more than count the oldest will be removed. long? TruncateBefore When set says that items prior to event 'E' can be truncated and will be removed. TimeSpan? CacheControl The head of a feed in the atom api is not cacheable. This allows you to specify a period of time you want it to be cacheable. Low numbers are best here (say 30-60 seconds) and introducing values here will introduce latency over the atom protocol if caching is occuring. StreamAcl Acl The access control list for this stream. If instead you want to work with raw JSON you can use the raw methods for stream metadata. Task<RawStreamMetadataResult> GetStreamMetadataAsRawBytesAsync(string stream, UserCredentials userCredentials = null) This returns a RawStreamMetadataResult . The fields on this result are: Member Description string Stream The name of the stream bool IsStreamDeleted True is the stream is deleted, false otherwise. long MetastreamVersion The version of the metastream (see Expected Version ) byte[] Metadata The raw data of the metadata JSON Note If you enabled enabled security , reading metadata may require that you pass credentials. By default it is only allowed for admins though you can change this via default ACLs. If you do not pass credentials and they are required you will receive an AccessedDeniedException . Writing metadata You can write metadata in both a typed and a raw mechanism. When writing it is generally easier to use the typed mechanism. Both writing mechanisms support an expectedVersion which works the same as on any stream and you can use to control concurrency, read Expected Version for further details. Task<WriteResult> SetStreamMetadataAsync(string stream, long expectedMetastreamVersion, StreamMetadata metadata, UserCredentials userCredentials = null) The StreamMetadata passed above has a builder that you can access via the StreamMetadata.Create() method. The options available on the builder are: Method Description SetMaxCount(long count) Sets the maximum count of events in the stream. SetMaxAge(TimeSpan age) Sets the maximum age of events in the stream. SetTruncateBefore(long seq) Sets the event number from which previous events can be scavenged.< SetCacheControl(TimeSpan cacheControl) The amount of time the stream head is cachable. SetReadRoles(string[] roles) Sets the roles allowed to read the underlying stream. SetWriteRoles(string[] roles) Sets the roles allowed to write to the underlying stream. SetDeleteRoles(string[] roles) Sets the roles allowed to delete the underlying stream. SetMetadataReadRoles(string[] roles) Sets the roles allowed to read the metadata stream. SetMetadataWriteRoles(string[] roles) Sets the roles allowed to write the metadata stream. Be careful with this privilege as it gives all the privileges for a stream as that use can assign themselves any other privilege. SetCustomMetadata(string key, string value) The SetCustomMetadata method and overloads allow the setting of arbitrary custom fields into the stream metadata. You can add user-specified metadata via the SetCustomMetadata overloads. Some examples of good uses of user-specified metadata are: which adapter is responsible for populating a stream. which projection caused a stream to be created. a correlation ID of some business process. Task<WriteResult> SetStreamMetadataAsync(string stream, long expectedMetastreamVersion, byte[] metadata, UserCredentials userCredentials = null) This method will put the data that is in metadata as the stream metadata. Metadata in this case can be anything in a vector of bytes. The server only understands JSON. Read Access Control Lists for more information on the format in JSON for access control lists. Note Writing metadata may require that you pass credentials if you have security enabled by default it is only allowed for admins though you can change this via default ACLs. If you do not pass credentials and they are required you will receive an AccessedDeniedException ."
  },
  "dotnet-api/persistent-subscriptions/index.html": {
    "href": "dotnet-api/persistent-subscriptions/index.html",
    "title": "Persistent subscriptions management | Event Store",
    "keywords": "Persistent subscriptions management The Client API includes helper methods that use the HTTP API to allow you to manage persistent subscriptions. This document describes the methods found in the PersistentSubscriptions class. All methods in this class are asynchronous. Methods Get information for all persistent subscriptions from all streams Returns information about all persistent subscriptions from all streams. public Task List(UserCredentials userCredentials = null) Get information about the persistent subscriptions for a stream Returns information about the persistent subscription for a stream you specify with stream . You must have access to the stream. public Task List(string stream, UserCredentials userCredentials = null) Get information for a persistent subscription for a stream Gets the details of the persistent subscription subscriptionName on stream . You must have access to the persistent subscription and the stream. public Task Describe(string stream, string subscriptionName, UserCredentials userCredentials = null) Replay parked messages Replays all parked messages for a particular persistent subscription subscriptionName on a stream that were parked by a negative acknowledgement action. public Task ReplayParkedMessages(string stream, string subscriptionName, UserCredentials userCredentials = null)"
  },
  "dotnet-api/reading-events/index.html": {
    "href": "dotnet-api/reading-events/index.html",
    "title": "Reading events | Event Store",
    "keywords": "Reading events You can use the client API to read events from a stream starting from either end of the stream. There is a method for each direction and one for reading a single event. Methods <!-- TODO: Do the same apply here as in HTTP API --> Read a single event Task<EventReadResult> ReadEventAsync(string stream, long eventNumber, bool resolveLinkTos); Read a specific stream forwards Task<StreamEventsSlice> ReadStreamEventsForwardAsync(string stream, long start, int count, bool resolveLinkTos) Read a specific stream backwards Task<StreamEventsSlice> ReadStreamEventsBackwardAsync(string stream, long start, int count, bool resolveLinkTos) Read all events forwards Task<AllEventsSlice> ReadAllEventsForwardAsync(Position position, int maxCount, bool resolveLinkTos); Read all events backwards Task<AllEventsSlice> ReadAllEventsBackwardAsync(Position position, int maxCount, bool resolveLinkTos); Note These methods also have an optional parameter which allows you to specify the UserCredentials to use for the request. If you don't supply any, the default credentials for the EventStoreConnection are used ( see Connecting to a server - user credentials ). StreamEventsSlice The reading methods for individual streams each return a StreamEventsSlice , which is immutable. The available members on StreamEventsSlice are: Member Description string Stream The name of the stream for the slice ReadDirection ReadDirection Either ReadDirection.Forward or ReadDirection.Backward depending on which method was used to read long FromEventNumber The sequence number of the first event in the stream long LastEventNumber The sequence number of the last event in the stream long NextEventNumber The sequence number from which the next read should be performed to continue reading the stream bool IsEndOfStream Whether this slice contained the end of the stream at the time it was created ResolvedEvent[] Events An array of the events read. See the description of how to interpret a Resolved Events below for more information on this ResolvedEvent When you read events from a stream (or received over a subscription) you receive an instance of the RecordedEvent class packaged inside a ResolvedEvent . Event Store supports a special event type called 'Link Events'. Think of these events as pointers to an event in another stream. In situations where the event you read is a link event, ResolvedEvent allows you to access both the link event itself, as well as the event it points to. The members of this class are as follows: Member Description RecordedEvent Event The event, or the resolved link event if this ResolvedEvent is a link event RecordedEvent Link The link event if this ResolvedEvent is a link event RecordedEvent OriginalEvent Returns the event read or which triggered the subscription. If this ResolvedEvent represents a link event, the link will be the OriginalEvent , otherwise it will be the event bool IsResolved Indicates whether this ResolvedEvent is a resolved link event Position? OriginalPosition The logical position of the OriginalEvent string OriginalStreamId The stream name of the OriginalEvent long OriginalEventNumber The event number in the stream of the OriginalEvent Note To ensure that the Event Store server follows link events when reading, ensure you set the ResolveLinkTos parameter to true when calling read methods. RecordedEvent RecordedEvent contains all the data about a specific event. Instances of this class are immutable, and expose the following members: Member Description string EventStreamId The Event Stream this event belongs to Guid EventId The Unique Identifier representing this event long EventNumber The number of this event in the stream string EventType The event type (supplied when writing) byte[] Data A byte array representing the data of this event byte[] Metadata A byte array representing the metadata associated with this event bool IsJson Indicates whether the content was internally marked as json DateTime Created A datetime representing when this event was created. long CreatedEpoch A long representing the milliseconds since the epoch when the was created. Read a single event The ReadEventAsync method reads a single event from a stream at a specified position. This is the simplest case of reading events, but is still useful for situations such as reading the last event in the stream used as a starting point for a subscription. This function accepts three parameters: Parameter Description string stream The stream to read from long eventNumber The event number to read (use StreamPosition.End to read the last event in the stream) bool resolveLinkTos Determines whether any link events encountered in the stream will be resolved. See the discussion on Resolved Events for more information on this This method returns an instance of EventReadResult which indicates if the read was successful, and if so the ResolvedEvent that was read. Reading a stream forwards The ReadStreamEventsForwardAsync method reads the requested number of events in the order in which they were originally written to the stream from a nominated starting point in the stream. The parameters are: Parameter Description string Stream The name of the stream to read long start The earliest event to read (inclusive). For the special case of the start of the stream, you should use the constant StreamPosition.Start . int count The maximum number of events to read in this request (assuming that many exist between the start specified and the end of the stream) bool resolveLinkTos Determines whether any link events encountered in the stream will be resolved. See the discussion on Resolved Events for more information on this Example: Read an entire stream forwards from start to end This example uses the ReadStreamEventsForwardAsync method in a loop to page through all events in a stream, reading 200 events at a time to build a list of all the events in the stream. var streamEvents = new List<ResolvedEvent>(); StreamEventsSlice currentSlice; var nextSliceStart = StreamPosition.Start; do { currentSlice = _eventStoreConnection.ReadStreamEventsForward(\"myStream\", nextSliceStart, 200, false) .Result; nextSliceStart = currentSlice.NextEventNumber; streamEvents.AddRange(currentSlice.Events); } while (!currentSlice.IsEndOfStream); Note It's unlikely that client code would need to build a list in this manner. It's far more likely that you would pass events into a left fold to derive the state of some object as of a given event. Read a stream backwards The ReadStreamEventsBackwardAsync method reads the requested number of events in the reverse order from that in which they were originally written to the stream from a specified starting point. The parameters are: Parameter Description string Stream The name of the stream to read long start The latest event to read (inclusive). For the end of the stream use the constant StreamPosition.End int count The maximum number of events to read in this request (assuming that many exist between the start specified and the start of the stream) bool resolveLinkTos Determines whether any link events encountered in the stream will be resolved. See the discussion on Resolved Events for more information on this Read all events Event Store allows you to read events across all streams using the ReadAllEventsForwardAsync and ReadAllEventsBackwardsAsync methods. These work in the same way as the regular read methods, but use an instance of the global log file Position to reference events rather than the simple integer stream position described previously. They also return an AllEventsSlice rather than a StreamEventsSlice which is the same except it uses global Position s rather than stream positions. Example: Read all events forward from start to end var allEvents = new List<ResolvedEvent>(); AllEventsSlice currentSlice; var nextSliceStart = Position.Start; do { currentSlice = connection.ReadAllEventsForwardAsync(nextSliceStart, 200, false).Result; nextSliceStart = currentSlice.NextPosition; allEvents.AddRange(currentSlice.Events); } while (!currentSlice.IsEndOfStream);"
  },
  "dotnet-api/connecting-to-a-server/index.html": {
    "href": "dotnet-api/connecting-to-a-server/index.html",
    "title": "Connecting to a server | Event Store",
    "keywords": "Connecting to a server EventStoreConnection The EventStoreConnection class maintains a full-duplex connection between the client and the Event Store server. EventStoreConnection is thread-safe and we recommend that you create one instance per application. All operations are fully asynchronous and return either a Task or a Task<T> . If you need to execute synchronously, call .Wait() , or Result on the asynchronous version. To get maximum performance from the connection we recommend that you use it asynchronously. Note The Create methods have changed since version 3.0.2 as connection strings are now supported. The old mechanisms will still work but are marked obsolete and will be removed in the future. Creating a connection The EventStoreConnection classes uses the static Create methods to create a new connection. All method overloads allow you to optionally specify a name for the connection, which the connection returns when it raises events (see Connection Events ). Method Description Create(Uri uri) Connects to Event Store (see URIs below) with default settings Create(ConnectionSettings connectionSettings, Uri uri) Connects to Event Store (see URIs below) with specified settings Create(string connectionString) Connects to Event Store (see URIs below) with settings from connection string (obsolete) Create(IPEndPoint tcpEndPoint) Connects to a single node with default settings (obsolete) Create(ConnectionSettings settings, IPEndPoint tcpEndPoint) Connects to a single node with custom settings (see Customising Connection Settings ) (obsolete) Create(ConnectionSettings connectionSettings, ClusterSettings clusterSettings) Connects to an Event Store HA cluster with custom settings (see Cluster Settings ) Note The connection returned by these methods is inactive. Use the ConnectAsync() method to establish a connection with the server. URIs The create methods support passing of a URI to the connection as opposed to passing IPEndPoints . This URI should be in the format of: Single Node : tcp://user:password@myserver:11234 Cluster : discover://user:password@myserver:1234 Where the port number points to the TCP port of the Event Store instance (1113 by default) or points to the manager gossip port for discovery purposes. With the URI based mechanism you can pass a domain name and the client will resolve it. Note The client performs a blocking DNS call for single node. If you are worried about blocking DNS due to network issues etc., you should resolve the DNS yourself and pass in an IP address. Customising connection settings Connection string Many of the overloads accept a connection string that you can use to control settings of the connection. A benefit to having these as a connection string instead of using the fluent API is that you can change them between environments without recompiling (i.e. a single node in dev and a cluster in production ). The connection string format should look familiar to those who have used connection strings in the past. It consists of a series of key/value pairs separated by semicolons. You can set the following values using the connection string: <!-- TODO: Moved, to check and what about ConnectTo? --> Name Format Description VerboseLogging True/false Enables verbose logging MaxQueueSize Integer Maximum number of outstanding operations MaxConcurrentItems Integer Maximum number of concurrent async operations MaxRetries Integer Maximum number of retry attempts MaxReconnections Integer The maximum number of times to try reconnecting RequireMaster True/false If set the server will only process if it is master ReconnectionDelay Integer (milliseconds) The delay before attempting to reconnect OperationTimeout Integer (milliseconds) The time before considering an operation timed out OperationTimeoutCheckPeriod Integer (milliseconds) The frequency in which to check timeouts DefaultUserCredentials String in format username:password The default credentials for the connection UseSslConnection True/false whether to use SSL for this connection TargetHost String The hostname expected on the certificate ValidateServer True/false Whether to validate the remote server FailOnNoServerResponse True/False Whether to fail on no server response HeartbeatInterval Integer (milliseconds) The interval at which to send the server a heartbeat HeartbeatTimeout Integer (milliseconds) The amount of time to receive a heartbeat response before timing out ClusterDns string The DNS name of the cluster for discovery MaxDiscoverAttempts Integer The maximum number of attempts to try to discover the cluster ExternalGossipPort Integer The port to try to gossip on GossipTimeout Integer (milliseconds) The amount of time before timing out a gossip response GossipSeeds Comma separated list of ip:port A list of seeds to try to discover from ConnectTo A URI in format described above to connect to The URI to connect to Note You can also use spacing instead of camel casing in your connection string. var connectionString = \"ConnectTo=tcp://admin:changeit@localhost:1113; HeartBeatTimeout=500\" Sets the connection string to connect to localhost on the default port and sets the heartbeat timeout to 500ms. var connectionString = \"Connect To = tcp://admin:changeit@localhost:1113; Gossip Timeout = 500\" Using spaces: var connectionString = \"ConnectTo=discover://admin:changeit@mycluster:3114; HeartBeatTimeout=500\" Tells the connection to try gossiping to a manager node found under the DNS 'mycluster' at port '3114' to connect to the cluster. var connectionString = \"GossipSeeds=192.168.0.2:1111,192.168.0.3:1111; HeartBeatTimeout=500\" Tells the connection to try gossiping to the gossip seeds 192.168.0.2 or 192.168.0.3 on port '1111' to discover information about the cluster. Note See the fluent API below for defaults of values. Note You can also use the ConnectionString class to return a ConnectionSettings object. Fluent API Settings used for modifying the behavior of an EventStoreConnection are encapsulated into an object of type ConnectionSettings passed as a parameter to the Create methods listed above. Instances of ConnectionSettings are created using a fluent builder class: ConnectionSettings settings = ConnectionSettings.Create(); This creates an instance of ConnectionSettings with default options. You can override these by chaining the additional builder methods described below. Logging The .NET API can log information to different destinations. By default logging is disabled. <!-- TODO: Moved, to check. Actually missing options. --> Builder Method Description UseConsoleLogger() Output log messages using Console.WriteLine UseDebugLogger() Output log messages using Debug.WriteLine UseCustomLogger() Output log messages to the specified instance of ILogger (You should implement this interface in order to log using another library such as NLog or log4net). EnableVerboseLogging() Turns on verbose logging. By default information about connection, disconnection and errors are logged, however it can be useful to have more information about specific operations as they are occuring. User credentials Event Store supports Access Control Lists that restrict permissions for a stream based on users and groups. EventStoreConnection allows you to supply credentials for each operation, however it is often more convenient to set default credentials for all operations on the connection. Builder Method Description SetDefaultUserCredentials(UserCredentials credentials) Sets the default UserCredentials to use for this connection. If you don't supply any credentials, the operation will use these. You create a UserCredentials object as follows: UserCredentials credentials = new UserCredentials(\"username\",\"password\"); Security The .NET API and Event Store can communicate either over SSL or an unencrypted channel (by default). To configure the client-side of the SSL connection, use the builder method below. For more information on setting up the server end of the Event Store for SSL, see SSL Setup . UseSslConnection(string targetHost, bool validateServer) Uses an SSL-encrypted connection where targetHost is the name specified on the SSL certificate installed on the server, and validateServer controls whether the connection validates the server certificate. Warning In production systems where credentials are sent from the client to Event Store, you should always use SSL encryption and you should set validateServer to true . Node preference When connecting to an Event Store HA cluster you can specify that operations are performed on any node, or only on the node that is the master. Builder Method Description PerformOnMasterOnly() Require the master to serve all write and read requests (Default). PerformOnAnyNode() Allow for writes to be forwarded and read requests to be served locally if the current node is not master. Handling failures The following methods on the ConnectionSettingsBuilder allow you to change the way the connection handles operation failures and connection issues. Reconnections Builder Method Description WithConnectionTimeoutOf (TimeSpan timeout) Sets the timeout to connect to a server before aborting and attempting a reconnect (Default: 1 second). LimitReconnectionsTo (int limit) Limits the number of reconnections this connection can try to make (Default: 10). KeepReconnecting() Allows infinite reconnection attempts. SetReconnectionDelayTo (TimeSpan reconnectionDelay) Sets the delay between reconnection attempts (Default: 100ms). SetHeartbeatInterval (TimeSpan interval) Sets how often the connection should expect heartbeats (lower values detect broken sockets faster) (Default: 750ms). SetHeartbeatTimeout (TimeSpan timeout) Sets how long to wait without heartbeats before determining a connection to be dead (must be longer than the heatrbeat interval) (Default: 1500ms). Operations Builder Method Description SetOperationTimeout (TimeSpan timeout) Sets the operation timeout duration (Default: 7 seconds). SetTimeoutCheckPeriodTo (TimeSpan timeoutCheckPeriod) Sets how often to check for timeouts (Default: 1 second). LimitAttemptsForOperationTo (int limit) Limits the number of operation attempts (Default: 11). LimitRetriesForOperationTo (int limit) Limits the number of operation retries (Default: 10). KeepRetrying() Allows infinite operation retries. LimitOperationsQueueTo (int limit) Sets the limit for number of outstanding operations (Default: 5000). FailOnNoServerResponse() Marks that no response from server should cause an error on the request. Cluster settings When connecting to an Event Store HA cluster you must pass an instance of ClusterSettings as well as the usual ConnectionSettings . Primarily yu use this to tell the EventStoreConnection how to discover all the nodes in the cluster. A connection to a cluster will automatically handle reconnecting to a new node if the current connection fails. Using DNS discovery DNS discovery uses a single DNS entry with several records listing all node IP addresses. The EventStoreConnection will then use a well known port to gossip with the nodes. Use ClusterSettings.Create().DiscoverClusterViaDns() followed by: <!-- TODO: Moved, to check. --> Builder Method Description SetClusterDns(string clusterDns) Sets the DNS name under which to list cluster nodes. SetClusterGossipPort(int clusterGossipPort) Sets the well-known port on which the cluster gossip is taking place. SetMaxDiscoverAttempts(int maxDiscoverAttempts) Sets the maximum number of attempts for discovery (Default: 10). SetGossipTimeout(TimeSpan timeout) Sets the period after which gossip times out if none is received (Default: 1 second). Note If you are using the commercial edition of Event Store HA with Manager nodes in place, the gossip port should be the port number of the external HTTP port on which the managers are running. If you are using the open source edition of Event Store HA the gossip port should be the External HTTP port that the nodes are running on. If you cannot use a well-known port for this across all nodes you can instead use gossip seed discovery and set the IPEndPoint of some seed nodes instead. Connecting using gossip seeds The second supported method for node discovery uses a hardcoded set of IPEndPoint s as gossip seeds. Use ClusterSettings.Create().DiscoverClusterViaGossipSeeds() followed by: <!-- TODO: Moved, to check. --> Builder Method Description SetGossipSeedEndPoints(params IPEndPoint[] gossipSeeds) Sets gossip seed endpoints for the client. SetGossipSeedEndPoints(params GossipSeed[] gossipSeeds) Same as above, but allows a specific Host header to be sent with all HTTP requests. SetMaxDiscoverAttempts(int maxDiscoverAttempts) Sets the maximum number of attempts for discovery (Default: 10). SetGossipTimeout(TimeSpan timeout) Sets the period after which gossip times out if none is received (Default: 1 second). Connection events EventStoreConnection exposes events that your application can use to be notified of changes to the status of the connection. <!-- TODO: Not moved. --> Event Description EventHandler<ClientConnectionEventArgs> Connected Fired when an IEventStoreConnection connects to an Event Store server. EventHandler<ClientConnectionEventArgs> Disconnected Fired when an IEventStoreConnection disconnects from an Event Store server by some means other than by calling the Close method. EventHandler<ClientReconnectingEventArgs> Reconnecting Fired when an IEventStoreConnection is attempting to reconnect to an Event Store server following a disconnection. EventHandler<ClientClosedEventArgs> Closed Fired when an IEventStoreConnection is closed either using the Close method or when reconnection limits are reached without a successful connection being established. EventHandler<ClientErrorEventArgs> ErrorOccurred Fired when an error is thrown on an IEventStoreConnection . EventHandler<ClientAuthenticationFailedEventArgs> AuthenticationFailed Fired when a client fails to authenticate to an Event Store server."
  },
  "dotnet-api/competing-consumers/index.html": {
    "href": "dotnet-api/competing-consumers/index.html",
    "title": "Competing consumers | Event Store",
    "keywords": "Competing consumers This document explains how to use .NET API for setting up and consuming competing consumer subscription groups. For an overview of competing consumers and how they relate to other subscription types, please see the overview document . Note The Administration UI includes a Competing Consumers section where a user can create, update, delete and view subscriptions and their statuses. Creating a persistent subscription Before interacting with a subscription group, you need to create one. You will receive an error if you attempt to create a subscription group more than once. This requires admin permissions . Task<PersistentSubscriptionCreateResult> CreatePersistentSubscriptionAsync(string stream, string groupName, PersistentSubscriptionSettings settings, UserCredentials credentials); Updating a persistent subscription You can edit the settings of an existing subscription while it is running. This action drops the current subscribers and resets the subscription internally. This requires admin permissions . Task<PersistentSubscriptionUpdateResult> UpdatePersistentSubscriptionAsync(string stream, string groupName, PersistentSubscriptionSettings settings, UserCredentials credentials); Deleting a persistent subscription <!-- TODO: Explanation? --> Task<PersistentSubscriptionDeleteResult> DeletePersistentSubscriptionAsync(string stream, string groupName, UserCredentials userCredentials = null); Connecting to a persistent subscription <!-- TODO: Explanation? --> EventStorePersistentSubscription ConnectToPersistentSubscription( string groupName, string stream, Func<EventStorePersistentSubscription, ResolvedEvent, Task> eventAppeared, Action<EventStorePersistentSubscription, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null, int bufferSize = 10, bool autoAck = true); Persistent subscription settings Both the Create and Update methods take a PersistentSubscriptionSettings object as a parameter. The methods use this object to provide the settings for the persistent subscription. A fluent builder is available for these options that you can locate using the Create() method. The following table shows the options you can set on a persistent subscription. Member Description ResolveLinkTos Tells the subscription to resolve link events. DoNotResolveLinkTos Tells the subscription to not resolve link events. PreferRoundRobin If possible preference a round robin between the connections with messages (if not possible uses next available). PreferDispatchToSingle If possible preference dispatching to a single connection (if not possible will use next available). StartFromBeginning Start the subscription from the first event in the stream. StartFrom(int position) Start the subscription from the position-th event in the stream. StartFromCurrent Start the subscription from the current position. WithMessageTimeoutOf(TimeSpan timeout) Sets the timeout for a client before retrying the message. CheckPointAfter(TimeSpan time) The amount of time the system should try to checkpoint after. MinimumCheckPointCountOf(int count) The minimum number of messages to write a checkpoint for. MaximumCheckPointCountOf(int count) The maximum number of messages not checkpointed before forcing a checkpoint. WithMaxRetriesOf(int count) Sets the number of times to retry a message should before considering it a bad message. WithLiveBufferSizeOf(int count) The size of the live buffer (in memory) before resorting to paging. WithReadBatchOf(int count) The size of the read batch when in paging mode. WithBufferSizeOf(int count) The number of messages to buffer when in paging mode. WithExtraStatistics Tells the backend to measure timings on the clients so statistics contain histograms of them. Creating a subscription group The first step of dealing with a subscription group is to create one. You will receive an error if you attempt to create a subscription group multiple times. You must have admin permissions to create a persistent subscription group. Note Normally you wouldn't create the subscription group in your general executable code. Instead, you create it as a step during an install or as an admin task when setting up Event Store. You should assume the subscription exists in your code. PersistentSubscriptionSettings settings = PersistentSubscriptionSettings.Create() .DoNotResolveLinkTos() .StartFromCurrent(); _result = _conn.CreatePersistentSubscriptionAsync(_stream, \"agroup\", settings, MyCredentials).Result; Parameter Description string stream The stream to the persistent subscription is on. string groupName The name of the subscription group to create. PersistentSubscriptionSettings settings The settings to use when creating this subscription. UserCredentials credentials The user credentials to use for this operation. Updating a subscription group You can edit the settings of an existing subscription group while it is running, you don't need to delete and recreate it to change settings. When you update the subscription group, it resets itself internally dropping the connections and having them reconnect. You must have admin permissions to update a persistent subscription group. PersistentSubscriptionSettings settings = PersistentSubscriptionSettings.Create() .DoNotResolveLinkTos() .StartFromCurrent(); _result = _conn.UpdatePersistentSubscriptionAsync(_stream, \"agroup\", settings, MyCredentials).Result; Note If you change settings such as startFromBeginning , this doesn't reset the group's checkpoint. If you want to change the current position in an update, you must delete and recreate the subscription group. Parameter Description string stream The stream to the persistent subscription is on. string groupName The name of the subscription group to update. PersistentSubscriptionSettings settings The settings to use when updating this subscription. UserCredentials credentials The user credentials to use for this operation. Deleting a subscription group Remove a subscription group with the delete operation. Like the creation of groups, you rarely do this in your runtime code and is undertaken by an administrator running a script. var result = _conn.DeletePersistentSubscriptionAsync(stream, \"groupname\", DefaultData.AdminCredentials).Result; Parameter Description string stream The stream to the persistent subscription is on. string groupName The name of the subscription group to update. UserCredentials credentials The user credentials to use for this operation. Connecting to a subscription group Once you have created a subscription group, clients can connect to that subscription group. A subscription in your application should only have the connection in your code, you should assume that the subscription was created via the client API, the restful API, or manually in the UI. The most important parameter to pass when connecting is the buffer size. This parameter represents how many outstanding messages the server should allow this client. If this number is too small, your subscription will spend much of its time idle as it waits for an acknowledgment to come back from the client. If it's too big, you waste resources and can start causing time out messages depending on the speed of your processing. var subscription = _conn.ConnectToPersistentSubscription(\"foo\", \"nonexisting2\", (sub, e) => Console.Write(\"appeared\"), (sub, reason, ex) =>{}); Parameter Description string stream The stream to the persistent subscription is on. string groupName The name of the subscription group to connect to. Action eventAppeared The action to call when an event arrives over the subscription. Action subscriptionDropped The action to call if the subscription is dropped. UserCredentials credentials The user credentials to use for this operation. int bufferSize The number of in-flight messages this client is allowed. bool autoAck Whether to automatically acknowledge messages after eventAppeared returns. Acknowledgements Clients must acknowledge (or not acknowledge) messages in the competing consumer model. If you enable auto-ack the subscription will automatically acknowledge messages once your handler completes them. If you throw an exception, it will shut down your subscription with a message and the uncaught exception. You can choose to not auto-ack messages. This can be useful when you have multi-threaded processing of messages in your subscriber and need to pass control to something else. There are methods on the subscription object that you can call Acknowledge, and NotAcknowledge both take a ResolvedEvent (the one you processed) both also have overloads for passing and IEnumerable<ResolvedEvent> . Consumer strategies When creating a persistent subscription, the settings allow for different consumer strategies via the WithNamedConsumerStrategy method. Built-in strategies are defined in the enum SystemConsumerStrategies . Note HTTP clients bypass the consumer strategy which means it ignores any ordering or pinning. RoundRobin (default) Distributes events to all clients evenly. If the client bufferSize is reached the client is ignored until events are acknowledged/not acknowledged. | DispatchToSingle Distributes events to a single client until the bufferSize is reached. After which the next client is selected in a round robin style, and the process is repeated. Pinned For use with an indexing projection such as the system $by_category projection. Event Store inspects event for its source stream id, hashing the id to one of 1024 buckets assigned to individual clients. When a client disconnects it's buckets are assigned to other clients. When a client connects, it is assigned some of the existing buckets. This naively attempts to maintain a balanced workload. The main aim of this strategy is to decrease the likelihood of concurrency and ordering issues while maintaining load balancing. This is not a guarantee , and you should handle the usual ordering and concurrency issues."
  },
  "server/stats-debug/index.html": {
    "href": "server/stats-debug/index.html",
    "title": "Stats and debug information | Event Store",
    "keywords": "Stats and debug information Event Store has a lot of debug and statistics information available about a cluster you can find with the following request: HTTP API Response curl -i -X GET \"http://127.0.0.1:2113/stats\" -u \"admin:changeit\" HTTP/1.1 200 OK Access-Control-Allow-Methods: GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Cache-Control: max-age=1, public Vary: Accept Content-Type: application/json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Thu, 06 Dec 2018 09:39:21 GMT Content-Length: 12664 Keep-Alive: timeout=15,max=100 { \"proc\": { \"startTime\": \"2018-12-06T09:33:13.0000000Z\", \"id\": 1, \"mem\": 84639744, \"cpu\": 9.739911, \"cpuScaled\": 4.86995554, \"threadsCount\": 25, \"contentionsRate\": 57.86452, \"thrownExceptionsRate\": 0.0, \"gc\": { \"allocationSpeed\": 0.0, \"gen0ItemsCount\": 14, \"gen0Size\": 0, \"gen1ItemsCount\": 1, \"gen1Size\": 0, \"gen2ItemsCount\": 0, \"gen2Size\": 0, \"largeHeapSize\": 0, \"timeInGc\": 0.0, \"totalBytesInHeaps\": 0 }, \"diskIo\": { \"readBytes\": 30879744, \"writtenBytes\": 987136, \"readOps\": 75895, \"writeOps\": 726 }, \"tcp\": { \"connections\": 0, \"receivingSpeed\": 0.0, \"sendingSpeed\": 0.0, \"inSend\": 0, \"measureTime\": \"00:00:29.5561630\", \"pendingReceived\": 0, \"pendingSend\": 0, \"receivedBytesSinceLastRun\": 0, \"receivedBytesTotal\": 0, \"sentBytesSinceLastRun\": 0, \"sentBytesTotal\": 0 } }, \"sys\": { \"cpu\": 8.282546, \"freeMem\": 375517184, \"drive\": { \"/var/lib/eventstore\": { \"availableBytes\": 13525999616, \"totalBytes\": 15679725568, \"usage\": \"13%\", \"usedBytes\": 2153725952 } } }, \"es\": { \"checksum\": 205117, \"checksumNonFlushed\": 205117, \"queue\": { \"index Committer\": { \"queueName\": \"Index Committer\", \"groupName\": \"\", \"avgItemsPerSecond\": 0, \"avgProcessingTime\": 29590.349000000002, \"currentIdleTime\": null, \"currentItemProcessingTime\": \"0:00:06:06.3938445\", \"idleTimePercent\": 0.0, \"length\": 0, \"lengthCurrentTryPeak\": 0, \"lengthLifetimePeak\": 0, \"totalItemsProcessed\": 60, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"CommitAck\" }, \"mainQueue\": { \"queueName\": \"MainQueue\", \"groupName\": \"\", \"avgItemsPerSecond\": 13, \"avgProcessingTime\": 0.012954452926208651, \"currentIdleTime\": \"0:00:00:00.0290638\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.982804190417681, \"length\": 0, \"lengthCurrentTryPeak\": 5, \"lengthLifetimePeak\": 14, \"totalItemsProcessed\": 6366, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"Schedule\" }, \"monitoringQueue\": { \"queueName\": \"MonitoringQueue\", \"groupName\": \"\", \"avgItemsPerSecond\": 0, \"avgProcessingTime\": 584.2229, \"currentIdleTime\": null, \"currentItemProcessingTime\": \"0:00:00:00.5484086\", \"idleTimePercent\": 98.025629883927763, \"length\": 0, \"lengthCurrentTryPeak\": 0, \"lengthLifetimePeak\": 1, \"totalItemsProcessed\": 25, \"inProgressMessage\": \"GetFreshStats\", \"lastProcessedMessage\": \"GetFreshStats\" }, \"projection Core #0\": { \"queueName\": \"Projection Core #0\", \"groupName\": \"Projection Core\", \"avgItemsPerSecond\": 0, \"avgProcessingTime\": 0.00966, \"currentIdleTime\": \"0:00:00:29.5815685\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.999673204215767, \"length\": 0, \"lengthCurrentTryPeak\": 2, \"lengthLifetimePeak\": 22, \"totalItemsProcessed\": 871, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"EventReaderIdle\" }, \"projection Core #1\": { \"queueName\": \"Projection Core #1\", \"groupName\": \"Projection Core\", \"avgItemsPerSecond\": 0, \"avgProcessingTime\": 0.01033, \"currentIdleTime\": \"0:00:00:29.5815941\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.999651237588822, \"length\": 0, \"lengthCurrentTryPeak\": 2, \"lengthLifetimePeak\": 15, \"totalItemsProcessed\": 505, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"EventReaderIdle\" }, \"projection Core #2\": { \"queueName\": \"Projection Core #2\", \"groupName\": \"Projection Core\", \"avgItemsPerSecond\": 0, \"avgProcessingTime\": 0.010700000000000001, \"currentIdleTime\": \"0:00:00:29.5816107\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.999638057613979, \"length\": 0, \"lengthCurrentTryPeak\": 2, \"lengthLifetimePeak\": 53, \"totalItemsProcessed\": 2897, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"EventReaderIdle\" }, \"projections Master\": { \"queueName\": \"Projections Master\", \"groupName\": \"\", \"avgItemsPerSecond\": 19, \"avgProcessingTime\": 0.0076020905923344945, \"currentIdleTime\": \"0:00:00:00.0398806\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.9850336301286, \"length\": 0, \"lengthCurrentTryPeak\": 0, \"lengthLifetimePeak\": 12, \"totalItemsProcessed\": 7285, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"Schedule\" }, \"storage Chaser\": { \"queueName\": \"Storage Chaser\", \"groupName\": \"\", \"avgItemsPerSecond\": 104, \"avgProcessingTime\": 0.00693448498546981, \"currentIdleTime\": \"0:00:00:00.0012769\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.926313794228051, \"length\": 0, \"lengthCurrentTryPeak\": 0, \"lengthLifetimePeak\": 0, \"totalItemsProcessed\": 38228, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"ChaserCheckpointFlush\" }, \"storageReaderQueue #1\": { \"queueName\": \"StorageReaderQueue #1\", \"groupName\": \"StorageReaderQueue\", \"avgItemsPerSecond\": 0, \"avgProcessingTime\": 0.19243333333333335, \"currentIdleTime\": \"0:00:00:00.5597500\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.994147076653874, \"length\": 0, \"lengthCurrentTryPeak\": 0, \"lengthLifetimePeak\": 1, \"totalItemsProcessed\": 274, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"ReadStreamEventsBackward\" }, \"storageReaderQueue #2\": { \"queueName\": \"StorageReaderQueue #2\", \"groupName\": \"StorageReaderQueue\", \"avgItemsPerSecond\": 0, \"avgProcessingTime\": 0.11274545454545454, \"currentIdleTime\": \"0:00:00:00.0290949\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.995787138839844, \"length\": 0, \"lengthCurrentTryPeak\": 0, \"lengthLifetimePeak\": 1, \"totalItemsProcessed\": 280, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"ReadStreamEventsForward\" }, \"storageReaderQueue #3\": { \"queueName\": \"StorageReaderQueue #3\", \"groupName\": \"StorageReaderQueue\", \"avgItemsPerSecond\": 0, \"avgProcessingTime\": 0.0953888888888889, \"currentIdleTime\": \"0:00:00:02.0327931\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.9970993914555, \"length\": 0, \"lengthCurrentTryPeak\": 0, \"lengthLifetimePeak\": 1, \"totalItemsProcessed\": 262, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"ReadStreamEventsForward\" }, \"storageReaderQueue #4\": { \"queueName\": \"StorageReaderQueue #4\", \"groupName\": \"StorageReaderQueue\", \"avgItemsPerSecond\": 0, \"avgProcessingTime\": 0.087377777777777776, \"currentIdleTime\": \"0:00:00:01.0318977\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.997328182310355, \"length\": 0, \"lengthCurrentTryPeak\": 0, \"lengthLifetimePeak\": 1, \"totalItemsProcessed\": 282, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"ReadStreamEventsForward\" }, \"storageWriterQueue\": { \"queueName\": \"StorageWriterQueue\", \"groupName\": \"\", \"avgItemsPerSecond\": 0, \"avgProcessingTime\": 4.42, \"currentIdleTime\": \"0:00:00:29.5843498\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.985062693918209, \"length\": 0, \"lengthCurrentTryPeak\": 0, \"lengthLifetimePeak\": 2, \"totalItemsProcessed\": 65, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"WritePrepares\" }, \"subscriptions\": { \"queueName\": \"Subscriptions\", \"groupName\": \"\", \"avgItemsPerSecond\": 1, \"avgProcessingTime\": 0.022990322580645161, \"currentIdleTime\": \"0:00:00:00.0293309\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.997594823346091, \"length\": 0, \"lengthCurrentTryPeak\": 0, \"lengthLifetimePeak\": 10, \"totalItemsProcessed\": 436, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"CheckPollTimeout\" }, \"timer\": { \"queueName\": \"Timer\", \"groupName\": \"\", \"avgItemsPerSecond\": 32, \"avgProcessingTime\": 0.024676409185803758, \"currentIdleTime\": \"0:00:00:00.0093879\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.918283810581556, \"length\": 9, \"lengthCurrentTryPeak\": 15, \"lengthLifetimePeak\": 614, \"totalItemsProcessed\": 12915, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"ExecuteScheduledTasks\" }, \"worker #1\": { \"queueName\": \"Worker #1\", \"groupName\": \"Workers\", \"avgItemsPerSecond\": 1, \"avgProcessingTime\": 0.18848333333333334, \"currentIdleTime\": \"0:00:00:00.0295425\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.973144953850138, \"length\": 0, \"lengthCurrentTryPeak\": 1, \"lengthLifetimePeak\": 1, \"totalItemsProcessed\": 520, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"PurgeTimedOutRequests\" }, \"worker #2\": { \"queueName\": \"Worker #2\", \"groupName\": \"Workers\", \"avgItemsPerSecond\": 1, \"avgProcessingTime\": 0.2823279069767442, \"currentIdleTime\": \"0:00:00:00.0295030\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.958977493122433, \"length\": 0, \"lengthCurrentTryPeak\": 1, \"lengthLifetimePeak\": 1, \"totalItemsProcessed\": 516, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"PurgeTimedOutRequests\" }, \"worker #3\": { \"queueName\": \"Worker #3\", \"groupName\": \"Workers\", \"avgItemsPerSecond\": 1, \"avgProcessingTime\": 0.018606976744186047, \"currentIdleTime\": \"0:00:00:00.0294627\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.997299118709734, \"length\": 0, \"lengthCurrentTryPeak\": 1, \"lengthLifetimePeak\": 1, \"totalItemsProcessed\": 517, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"PurgeTimedOutRequests\" }, \"worker #4\": { \"queueName\": \"Worker #4\", \"groupName\": \"Workers\", \"avgItemsPerSecond\": 1, \"avgProcessingTime\": 0.013951162790697674, \"currentIdleTime\": \"0:00:00:00.0292979\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.997871940733575, \"length\": 0, \"lengthCurrentTryPeak\": 1, \"lengthLifetimePeak\": 1, \"totalItemsProcessed\": 517, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"PurgeTimedOutRequests\" }, \"worker #5\": { \"queueName\": \"Worker #5\", \"groupName\": \"Workers\", \"avgItemsPerSecond\": 1, \"avgProcessingTime\": 0.00796046511627907, \"currentIdleTime\": \"0:00:00:00.0290928\", \"currentItemProcessingTime\": null, \"idleTimePercent\": 99.998844217454163, \"length\": 0, \"lengthCurrentTryPeak\": 1, \"lengthLifetimePeak\": 1, \"totalItemsProcessed\": 517, \"inProgressMessage\": \"<none>\", \"lastProcessedMessage\": \"ReadStreamEventsForwardCompleted\" } }, \"writer\": { \"lastFlushSize\": 17025, \"lastFlushDelayMs\": 4.2292, \"meanFlushSize\": 4018, \"meanFlushDelayMs\": 2.6562450980392156, \"maxFlushSize\": 17025, \"maxFlushDelayMs\": 6.9021, \"queuedFlushMessages\": 0 }, \"readIndex\": { \"cachedRecord\": 306, \"notCachedRecord\": 0, \"cachedStreamInfo\": 3012, \"notCachedStreamInfo\": 90, \"cachedTransInfo\": 0, \"notCachedTransInfo\": 0 } } }% This returns a lot of information that you can filter using the sub-path of the stat: HTTP API Response curl -i -X GET \"http://127.0.0.1:2113/stats/proc/tcp\" -u \"admin:changeit\" HTTP/1.1 200 OK Access-Control-Allow-Methods: GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Cache-Control: max-age=1, public Vary: Accept Content-Type: application/json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Thu, 06 Dec 2018 10:03:55 GMT Content-Length: 280 Keep-Alive: timeout=15,max=100 { \"connections\": 0, \"receivingSpeed\": 0.0, \"sendingSpeed\": 0.0, \"inSend\": 0, \"measureTime\": \"00:00:05.0223780\", \"pendingReceived\": 0, \"pendingSend\": 0, \"receivedBytesSinceLastRun\": 0, \"receivedBytesTotal\": 0, \"sentBytesSinceLastRun\": 0, \"sentBytesTotal\": 0 }% You can find more information on what each stat returns by searching for it in the reference code documentation under .NET API -> Code Documentation . <!-- TODO: Make this better, embed -->"
  },
  "server/setting-up-ssl/index.html": {
    "href": "server/setting-up-ssl/index.html",
    "title": "Setting up SSL | Event Store",
    "keywords": "Setting up SSL Setting up SSL on Windows The steps to set up SSL on Windows are as follows. First, create a certificate using powershell, and copy the thumbprint from the output New-SelfSignedCertificate -DnsName eventstore.org, localhost -CertStoreLocation cert:\\CurrentUser\\My To trust the new certificate, the certificate you have to import the certificate into the Trusted Root Certification Authorities: Press WindowsKey + R , and enter 'certmgr.msc'. Navigate to Certificates -> Current User -> Personal -> Certificates . Locate the certificate 'eventstore.org'. Right click on the certificate and click on All Tasks -> Export . Follow the prompts. Navigate to Certificates -> Current User -> Trusted Root Certification Authorities -> Certificates . Right click on the Certificates folder menu item and click All Tasks -> Import . Follow the prompts. Start Event Store with the following configuration in a configuration file : CertificateStoreLocation: CurrentUser CertificateStoreName: My CertificateThumbPrint: {Insert Thumb Print from Step 1} CertificateSubjectName: CN=eventstore.org ExtSecureTcpPort: 1115 Connect to Event Store: .NET API HTTP API var settings = ConnectionSettings.Create().UseSslConnection(\"eventstore.org\", true); using (var conn = EventStoreConnection.Create(settings, new IPEndPoint(IPAddress.Loopback, 1115))) { conn.ConnectAsync().Wait(); } curl -vk --cert <PATH_TO_CERT> --key <PATH_TO_KEY> -i -d \"@event.json\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/vnd.eventstore.events+json\" Setting up SSL on Linux Note This guide uses the latest Ubuntu LTS (18.04) First, create a private key and self-signed certificate request (This is only for testing purposes) openssl req \\ -x509 -sha256 -nodes -days 365 -subj \"/CN=eventstore.org\" \\ -newkey rsa:2048 -keyout eventstore.pem -out eventstore.csr Export a p12 file from the certificate request. You use this when starting Event Store: openssl pkcs12 -export -inkey eventstore.pem -in eventstore.csr -out eventstore.p12 You need to add the certificate to Ubuntu's trusted certificates. Copy the cert to the ca-certificates folder and update the certificates: sudo cp eventstore.csr /usr/local/share/ca-certificates/eventstore.crt sudo update-ca-certificates The mono framework has its own separate certificate store which you need to sync with the changes you made to Ubuntu's certificates. You first need to install mono-devel : sudo apt-get install mono-devel This process installs cert-sync , which you use to update mono's certificate store with the new certificate: sudo cert-sync eventstore.csr Start Event Store with the following configuration in a configuration file : CertificateFile: eventstore.p12 ExtSecureTcpPort: 1115 Connect to Event Store: .NET API HTTP API var settings = ConnectionSettings.Create().UseSslConnection(\"eventstore.org\", true); using (var conn = EventStoreConnection.Create(settings, new IPEndPoint(IPAddress.Loopback, 1115))) { conn.ConnectAsync().Wait(); } curl -vk --cert <PATH_TO_CERT> --key <PATH_TO_KEY> -i -d \"@event.json\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/vnd.eventstore.events+json\""
  },
  "server/scavenging/index.html": {
    "href": "server/scavenging/index.html",
    "title": "Scavenging events | Event Store",
    "keywords": "Scavenging events When you delete events or streams in Event Store, they aren't removed immediately. To permanently delete these events you need to run a 'scavenge' on your database. A scavenge reclaims disk space by rewriting your database chunks, minus the events to delete, and then deleting the old chunks. Scavenges only affect completed chunks, so deleted events in the current chunk are still there after you run a scavenge. After processing the chunks, the operation updates the chunk indexes using a merge sort algorithm, skipping events whose data is no longer available. Warning Once a scavenge has run, you cannot recover any deleted events. Note Before version 4.0.2, a scavenge operation only worked with database chunk files. Since version 4.0.2 that reordering also happens inside the index files. Starting a scavenge Scavenges are not run automatically by Event Store. We recommendation that you set up a scheduled task, for example using cron or Windows Scheduler, to trigger a scavenge as often as you need. You start a scavenge by issuing an empty POST request to the HTTP API with the credentials of an admin or ops user: Request Response curl -i -d {} -X POST http://localhost:2113/admin/scavenge -u \"admin:changeit\" Next Steps Scavenge operations have other options you can set to improve performance, read the API docs for more details. HTTP/1.1 200 OK Access-Control-Allow-Methods: POST, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Content-Type: Server: Mono-HTTPAPI/1.0 Date: Wed, 19 Sep 2018 10:25:55 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 Next Steps For better scavenge performance, you can set the number of threads to use. If you need to restart a stopped scavenge, you can specify the starting chunk ID. Find out more in the API reference . You can also start scavenges from the Admin page of the Admin UI. Tip Each node in a cluster has its own independent database. As such, when you run a scavenge, you need to issue a scavenge request to each node. How often to run a scavenge This depends on the following: How often you delete streams. Depending on how you set $maxAge , $maxCount or $tb metadata on your streams. Stopping a scavenge Stop a running scavenge operation by issuing a DELETE request to the HTTP API with the credentials of an admin or ops user and the ID of the scavenge you want to stop: curl -i -X DELETE http://localhost:2113/admin/scavenge/{scavengeId} -u \"admin:changeit\" You can also stop scavenges from the Admin page of the Admin UI. Tip Each node in a cluster has its own independent database. As such, when you run a scavenge, you need to issue a scavenge request to each node. How often should you run a scavenge This depends on the following: How often you delete streams. How you set $maxAge , $maxCount or $tb metadata on your streams. Tip Read the .NET API or HTTP API docs for more details on setting metadata. Scavenging while Event Store is online It's safe to run a scavenge while Event Store is running and processing events, as it's designed to be an online operation. Warning Scavenging increases the number of reads/writes made to disk, and it is not recommended when your system is under heavy load."
  },
  "server/node-roles/index.html": {
    "href": "server/node-roles/index.html",
    "title": "Cluster node roles | Event Store",
    "keywords": "Cluster node roles Every node in an Event Store cluster can have one of three roles. Master A cluster assigns the Master role based on an election process. The node with the Master role ensures that the data are committed and persisted to disk before sending back to the client an acknowledge message. A cluster can only have one Master at a time. If a cluster detects two nodes with a Master role, a new election begins and shuts down the node with less data to restart and re-join the cluster. Slave A cluster assigns the Slave role based on an election process. A cluster uses one or more nodes with the Slave role to form the quorum, or the majority of nodes necessary to confirm that a write is persisted. Clone If you add nodes to a cluster beyond the number of nodes specified in the ClusterSize setting the cluster automatically assigns them the Clone role. A cluster asynchronously replicates data one way to a node with the Clone role. You don't need to wait for an acknowledgement message as the node is not part of the quorum. For this reason a node with a Clone role does not add much overhead to the other nodes. If a cluster loses nodes to take it below ClusterSize , then the cluster can promote a Clone to a Master or Slave role. You can control which clones the cluster promotes with the NodePriority command line option . The default value is 0 , and the cluster is more likely to promote clones with higher values. Note Changing NodePriority doesn't guarantee that the cluster won't promote the clone. It's only one of the criteria that the Election Service considers."
  },
  "server/default-directories/index.html": {
    "href": "server/default-directories/index.html",
    "title": "Default directories | Event Store",
    "keywords": "Default directories The default directories used by Event Store vary by platform to fit with the common practices each platform. Note Paths beginning with \".\" are relative to the directory in which eventstored or EventStore.ClusterNode.exe are located. Absolute paths are as written. Linux Application: /usr/bin Content: /usr/share/eventstore Configuration: /etc/eventstore/ Data: /var/lib/eventstore Application Logs: /var/log/eventstore Test Client Logs: ./testclientlog Web Content: ./clusternode-web then {Content}/clusternode-web Projections: ./projections then {Content}/projections Prelude: ./Prelude then {Content}/Prelude Windows and macOS Content: ./ Configuration: ./ Data: ./data Application Logs: ./logs Test Client Log: ./testclientlogs Web Content: ./clusternode-web then {Content}/clusternode-web Projections: ./projections then {Content}/projections Prelude: ./Prelude then {Content}/Prelude"
  },
  "server/database-backup/index.html": {
    "href": "server/database-backup/index.html",
    "title": "Database backup | Event Store",
    "keywords": "Database backup Backing up an Event Store database is straightforward, but relies on you carrying out the steps below in the correct order. Backing up a database Copy all *.chk files to your backup location. Copy the remaining files and directories to your backup location. For example: rsync -a /data/eventstore/db/*.chk /backup/eventstore/db/ rsync -a /data/eventstore/db/index /backup/eventstore/db/ rsync -a /data/eventstore/db/*.0* /backup/eventstore/db/ Restoring a database Create a copy of chaser.chk and call it truncate.chk . Copy all files to the desired location. Note Many people do not rely on hot backups in a highly available cluster but instead increase their node counts to keep further copies of data. Differential backup Event Store keep most data in chunk files , named chunkX.Y , where X is the chunk number, and Y is the version of that chunk file. As Event Store scavenges, it creates new versions of scavenged chunks which are interchangeable with older versions (but for the removed data). It's only necessary to keep the file whose name has the highest Y for each X , as well as the checkpoint files and the index directory (to avoid expensive index rebuilding). Other options There are many other options available for backing up an Event Store database. For example, you can set up a durable subscription that writes all events to another storage mechanism such as a key/value or column store. These methods would require a manual set up for restoring back to a cluster group. You can expand upon this option to use a second Event Store node/cluster as a back up. This is commonly known as a primary/secondary back up scheme. The primary cluster runs and asynchronously pushes data to a second cluster as described above. The second cluster/node is available in case of disaster on the primary cluster. If you are using this strategy then we recommend you only support manual failover from Primary to Secondary as automated strategies risk causing a split brain problem."
  },
  "server/command-line-arguments/index.html": {
    "href": "server/command-line-arguments/index.html",
    "title": "Command line arguments | Event Store",
    "keywords": "Command line arguments Event Store supports many configuration options. There are three distinct ways to set any parameter, all with their own advantages and disadvantages. The command line Environment variables YAML files Command line To pass a configuration value over the command line you add the configuration to the line executing Event Store, for example: EventStore.ClusterNode.exe --log ~/logs While command line arguments are useful during development, they are not the preferred way to handle configuration in a production system. Environment variables You can set all arguments can also as environment variables. This mechanism is often used in UNIX based systems. For example: log=~/logs You can reference another environment variable by setting the variables value to ${env:REFERENCED_ENV_VAR} . For example, if youre using Azure Service Fabric, some predefined environment variables exist. You can use EVENTSTORE_EXT_IP={env:Fabric_NodeIPOrFQDN} to reference the node's IP address. YAML files The last way you can set arguments is to put them into one or more configuration files. To tell Event Store to use a different configuration file, you pass the file path on the command line with --config=filename , or use the CONFIG enivornment variable. The basic format of the YAML configuration file is as follows: --- Log: \"~/logs\" IntHttpPort: 2111 --- Note You need to use the three dashes and spacing in your YAML file. YAML files are better for large installations as you can centrally distribute and manage them, or generate them from a configuration management system. Order of precedence The order of precedence between multiple configuration sources is important as you can set them in multiple ways. The command line is the highest priority followed by environment variables. Files are the lowest precedence and are processed in the order given on the command line. When starting Event Store it lists the major parameters in the log (including what set them). Parameter list Event Store supports the following parameters. Application options Command line parameter Environment variable prefixed with EVENTSTORE_ Config file YAML Description -Help --help=VALUE HELP Help Show help. (Default: False) -Version --version=VALUE VERSION Version Show version. (Default: False) -Log --log=VALUE LOG Log Path where to keep log files. (Default: See default directories -StructuredLog --structured-log=VALUE STRUCTURED_LOG StructuredLog Enable Structured (JSON) logging. (Default: True) -Config --config=VALUE CONFIG Config Configuration files. -Defines --defines=VALUE DEFINES Defines Run-time conditionals. (Default: n/a) -WhatIf --what-if=VALUE WHAT_IF WhatIf Print effective configuration to console and then exit. (Default: False) -StartStandardProjections --start-standard-projections=VALUE START_STANDARD_PROJECTIONS StartStandardProjections Start the built in system projections. (Default: False) -DisableHTTPCaching --disable-http-caching=VALUE DISABLE_HTTP_CACHING DisableHTTPCaching Disable HTTP caching. (Default: False) -MonoMinThreadpoolSize --mono-min-threadpool-size=VALUE MONO_MIN_THREADPOOL_SIZE MonoMinThreadpoolSize Minimum number of worker threads when running under mono. Set to 0 to leave machine defaults. (Default: 10) -Force --force=VALUE FORCE Force Force the Event Store to run in possibly harmful environments such as with Boehm GC. (Default: False) -StatsPeriodSec --stats-period-sec=VALUE STATS_PERIOD_SEC StatsPeriodSec The number of seconds between statistics gathers. (Default: 30) -WorkerThreads --worker-threads=VALUE WORKER_THREADS WorkerThreads The number of threads to use for pool of worker services. (Default: 5) -EnableHistograms --enable-histograms=VALUE ENABLE_HISTOGRAMS EnableHistograms Enables the tracking of various histograms in the backend, typically only used for debugging etc (Default: False) -LogHttpRequests --log-http-requests=VALUE LOG_HTTP_REQUESTS LogHttpRequests Log HTTP Requests and Responses before processing them. (Default: False) Authentication options Command line parameter Environment variable prefixed with EVENTSTORE_ Config file YAML Description -AuthenticationType --authentication-type=VALUE AUTHENTICATION_TYPE AuthenticationType The type of authentication to use. (Default: internal) -AuthenticationConfig --authentication-config=VALUE AUTHENTICATION_CONFIG AuthenticationConfig Path to the configuration file for authentication configuration (if applicable). Certificate options Command line parameter Environment variable prefixed with EVENTSTORE_ Config file YAML Description -CertificateStoreLocation --certificate-store-location=VALUE CERTIFICATE_STORE_LOCATION CertificateStoreLocation The certificate store location name. -CertificateStoreName --certificate-store-name=VALUE CERTIFICATE_STORE_NAME CertificateStoreName The certificate store name. -CertificateSubjectName --certificate-subject-name=VALUE CERTIFICATE_SUBJECT_NAME CertificateSubjectName The certificate subject name. -CertificateThumbprint --certificate-thumbprint=VALUE CERTIFICATE_THUMBPRINT CertificateThumbprint The certificate fingerprint/thumbprint. -CertificateFile --certificate-file=VALUE CERTIFICATE_FILE CertificateFile The path to certificate file. -CertificatePassword --certificate-password=VALUE CERTIFICATE_PASSWORD CertificatePassword The password to certificate in file. Cluster options Command line parameter Environment variable prefixed with EVENTSTORE_ Config file YAML Description -ClusterSize --cluster-size=VALUE CLUSTER_SIZE ClusterSize The number of nodes in the cluster. (Default: 1) -NodePriority --node-priority=VALUE NODE_PRIORITY NodePriority The node priority used during master election (Default: 0) -CommitCount --commit-count=VALUE COMMIT_COUNT CommitCount The number of nodes which must acknowledge commits before acknowledging to a client. (Default: -1) -PrepareCount --prepare-count=VALUE PREPARE_COUNT PrepareCount The number of nodes which must acknowledge prepares. (Default: -1) -DiscoverViaDns --discover-via-dns=VALUE DISCOVER_VIA_DNS DiscoverViaDns Whether to use DNS lookup to discover other cluster nodes. (Default: True) -ClusterDns --cluster-dns=VALUE CLUSTER_DNS ClusterDns DNS name from which other nodes can be discovered. (Default: fake.dns) -ClusterGossipPort --cluster-gossip-port=VALUE CLUSTER_GOSSIP_PORT ClusterGossipPort The port on which cluster nodes' managers are running. (Default: 30777) -GossipSeed --gossip-seed=VALUE GOSSIP_SEED GossipSeed Endpoints for other cluster nodes from which to seed gossip (Default: n/a) -GossipIntervalMs --gossip-interval-ms=VALUE GOSSIP_INTERVAL_MS GossipIntervalMs The interval in ms that nodes should try to gossip with each other (Default: 1000) -GossipAllowedDifferenceMs --gossip-allowed-difference-ms=VALUE GOSSIP_ALLOWED_DIFFERENCE_MS GossipAllowedDifferenceMs The amount of drift, in ms, between clocks on nodes allowed before gossip is rejected. (Default: 60000) -GossipTimeoutMs --gossip-timeout-ms=VALUE GOSSIP_TIMEOUT_MS GossipTimeoutMs The timeout in ms of gossip to another node. (Default: 500) -InitializationThreads --initialization-threads=VALUE INITIALIZATION_THREADS InitializationThreads Number of threads used to load chunk and index files. (Default: 1) -reduceFileCachePressure --reduce-file-cache-pressure=VALUE REDUCE_FILE_CACHE_PRESSURE reduceFileCachePressure Disables FileOptions.RandomAccess cache flag when opening chunk files. Useful if the Windows File Cache is consuming memory. (Default: False) -DisableFirstLevelHttpAuthorization --disable-first-level-http-authorization=VALUE DISABLE_FIRST_LEVEL_HTTP_AUTHORIZATION DisableFirstLevelHttpAuthorization Disables authorization layer on endpoints. (Default: True) -SkipIndexVerify --skip-index-verify=VALUE SKIP_INDEX_VERIFY SkipIndexVerify Skips reading and verification of PTables during start-up. (Default: False) -MaxAutoMergeIndexLevel --max-auto-merge-index-level=VALUE MAX_AUTO_MERGE_INDEX_LEVEL MaxAutoMergeIndexLevel Maximum level of index file to merge automatically before manual merge. (Default: 1000) -OptimizeIndexMerge --optimize-index-merge=VALUE OPTIMIZE_INDEX_MERGE OptimizeIndexMerge Bypasses the checking of file hashes of indexes during startup and after index merges. (Default: False) Database options Command line parameter Environment variable prefixed with EVENTSTORE_ Config file YAML Description -MinFlushDelayMs --min-flush-delay-ms=VALUE MIN_FLUSH_DELAY_MS MinFlushDelayMs The minimum flush delay in milliseconds. (Default: 2) -DisableScavengeMerging --disable-scavenge-merging=VALUE DISABLE_SCAVENGE_MERGING DisableScavengeMerging Disables the merging of chunks when scavenge is running (Default: False) -ScavengeHistoryMaxAge --scavenge-history-max-age=VALUE SCAVENGE_HISTORY_MAX_AGE ScavengeHistoryMaxAge The number of days to keep scavenge history (Default: 30) -CachedChunks --cached-chunks=VALUE CACHED_CHUNKS CachedChunks The number of chunks to cache in unmanaged memory. (Default: -1, or all) -ReaderThreadsCount --reader-threads-count=VALUE READER_THREADS_COUNT ReaderThreadsCount The number of reader threads to use for processing reads. (Default: 4) -ChunksCacheSize --chunks-cache-size=VALUE CHUNKS_CACHE_SIZE ChunksCacheSize The amount of unmanaged memory to use for caching chunks in bytes. (Default: 536871424) -MaxMemTableSize --max-mem-table-size=VALUE MAX_MEM_TABLE_SIZE MaxMemTableSize Adjusts the maximum size of a mem table. (Default: 1000000) -HashCollisionReadLimit --hash-collision-read-limit=VALUE HASH_COLLISION_READ_LIMIT HashCollisionReadLimit The number of events to read per candidate in the case of a hash collision (Default: 100) -Db --db=VALUE DB Db The path the db should be loaded/saved to. (Default: See default directories ) -Index --index=VALUE INDEX Index The path the index should be loaded/saved to. -MemDb --mem-db=VALUE MEM_DB MemDb Keep everything in memory, no directories or files are created. (Default: False) -SkipDbVerify --skip-db-verify=VALUE SKIP_DB_VERIFY SkipDbVerify Bypasses the checking of file hashes of database during startup (allows for faster startup). (Default: False) -WriteThrough --write-through=VALUE WRITE_THROUGH WriteThrough Enables Write Through when writing to the file system, this bypasses filesystem caches. (Default: False) -Unbuffered --unbuffered=VALUE UNBUFFERED Unbuffered Enables Unbuffered/DirectIO when writing to the file system, this bypasses filesystem caches. (Default: False) -PrepareTimeoutMs --prepare-timeout-ms=VALUE PREPARE_TIMEOUT_MS PrepareTimeoutMs Prepare timeout (in milliseconds). (Default: 2000) -CommitTimeoutMs --commit-timeout-ms=VALUE COMMIT_TIMEOUT_MS CommitTimeoutMs Commit timeout (in milliseconds). (Default: 2000) -UnsafeDisableFlushToDisk --unsafe-disable-flush-to-disk=VALUE UNSAFE_DISABLE_FLUSH_TO_DISK UnsafeDisableFlushToDisk Disable flushing to disk. (UNSAFE: on power off) (Default: False) -BetterOrdering --better-ordering=VALUE BETTER_ORDERING BetterOrdering Enable Queue affinity on reads during write process to try to get better ordering. (Default: False) -UnsafeIgnoreHardDelete --unsafe-ignore-hard-delete=VALUE UNSAFE_IGNORE_HARD_DELETE UnsafeIgnoreHardDelete Disables Hard Deletes (UNSAFE: use to remove hard deletes) (Default: False) -IndexCacheDepth --index-cache-depth=VALUE INDEX_CACHE_DEPTH IndexCacheDepth Sets the depth to cache for the mid point cache in index. (Default: 16) -AlwaysKeepScavenged --always-keep-scavenged=VALUE ALWAYS_KEEP_SCAVENGED AlwaysKeepScavenged Always keeps the newer chunks from a scavenge operation. (Default: False) Interface options Command line parameter Environment variable prefixed with EVENTSTORE_ Config file YAML Description -IntIp --int-ip=VALUE INT_IP IntIp Internal IP Address. (Default: 127.0.0.1) -ExtIp --ext-ip=VALUE EXT_IP ExtIp External IP Address. (Default: 127.0.0.1) -IntHttpPort --int-http-port=VALUE INT_HTTP_PORT IntHttpPort Internal HTTP Port. (Default: 2112) -ExtHttpPort --ext-http-port=VALUE EXT_HTTP_PORT ExtHttpPort External HTTP Port. (Default: 2113) -IntTcpPort --int-tcp-port=VALUE INT_TCP_PORT IntTcpPort Internal TCP Port. (Default: 1112) -IntSecureTcpPort --int-secure-tcp-port=VALUE INT_SECURE_TCP_PORT IntSecureTcpPort Internal Secure TCP Port. (Default: 0) -ExtTcpPort --ext-tcp-port=VALUE EXT_TCP_PORT ExtTcpPort External TCP Port. (Default: 1113) -ExtSecureTcpPortAdvertiseAs --ext-secure-tcp-port-advertise-as=VALUE EXT_SECURE_TCP_PORT_ADVERTISE_AS ExtSecureTcpPortAdvertiseAs Advertise Secure External Tcp Port As. (Default: 0) -ExtSecureTcpPort --ext-secure-tcp-port=VALUE EXT_SECURE_TCP_PORT ExtSecureTcpPort External Secure TCP Port. (Default: 0) -ExtIpAdvertiseAs --ext-ip-advertise-as=VALUE EXT_IP_ADVERTISE_AS ExtIpAdvertiseAs Advertise External Tcp Address As. -ExtTcpPortAdvertiseAs --ext-tcp-port-advertise-as=VALUE EXT_TCP_PORT_ADVERTISE_AS ExtTcpPortAdvertiseAs Advertise External Tcp Port As. (Default: 0) -ExtHttpPortAdvertiseAs --ext-http-port-advertise-as=VALUE EXT_HTTP_PORT_ADVERTISE_AS ExtHttpPortAdvertiseAs Advertise External Http Port As. (Default: 0) -IntIpAdvertiseAs --int-ip-advertise-as=VALUE INT_IP_ADVERTISE_AS IntIpAdvertiseAs Advertise Internal Tcp Address As. -IntSecureTcpPortAdvertiseAs --int-secure-tcp-port-advertise-as=VALUE INT_SECURE_TCP_PORT_ADVERTISE_AS IntSecureTcpPortAdvertiseAs Advertise Secure Internal Tcp Port As. (Default: 0) -IntTcpPortAdvertiseAs --int-tcp-port-advertise-as=VALUE INT_TCP_PORT_ADVERTISE_AS IntTcpPortAdvertiseAs Advertise Internal Tcp Port As. (Default: 0) -IntHttpPortAdvertiseAs --int-http-port-advertise-as=VALUE INT_HTTP_PORT_ADVERTISE_AS IntHttpPortAdvertiseAs Advertise Internal Http Port As. (Default: 0) -IntTcpHeartbeatTimeout --int-tcp-heartbeat-timeout=VALUE INT_TCP_HEARTBEAT_TIMEOUT IntTcpHeartbeatTimeout Heartbeat timeout for internal TCP sockets (Default: 700) -ExtTcpHeartbeatTimeout --ext-tcp-heartbeat-timeout=VALUE EXT_TCP_HEARTBEAT_TIMEOUT ExtTcpHeartbeatTimeout Heartbeat timeout for external TCP sockets (Default: 1000) -IntTcpHeartbeatInterval --int-tcp-heartbeat-interval=VALUE INT_TCP_HEARTBEAT_INTERVAL IntTcpHeartbeatInterval Heartbeat interval for internal TCP sockets (Default: 700) -ExtTcpHeartbeatInterval --ext-tcp-heartbeat-interval=VALUE EXT_TCP_HEARTBEAT_INTERVAL ExtTcpHeartbeatInterval Heartbeat interval for external TCP sockets (Default: 2000) -GossipOnSingleNode --gossip-on-single-node=VALUE GOSSIP_ON_SINGLE_NODE GossipOnSingleNode When enabled tells a single node to run gossip as if it is a cluster (Default: False) -AdminOnExt --admin-on-ext=VALUE ADMIN_ON_EXT AdminOnExt Whether or not to run the admin ui on the external HTTP endpoint (Default: True) -StatsOnExt --stats-on-ext=VALUE STATS_ON_EXT StatsOnExt Whether or not to accept statistics requests on the external HTTP endpoint, needed if you use admin ui (Default: True) -GossipOnExt --gossip-on-ext=VALUE GOSSIP_ON_EXT GossipOnExt Whether or not to accept gossip requests on the external HTTP endpoint (Default: True) -IntHttpPrefixes --int-http-prefixes=VALUE INT_HTTP_PREFIXES IntHttpPrefixes The prefixes that the internal HTTP server should respond to. (Default: n/a) -ExtHttpPrefixes --ext-http-prefixes=VALUE EXT_HTTP_PREFIXES ExtHttpPrefixes The prefixes that the external HTTP server should respond to. (Default: n/a) -EnableTrustedAuth --enable-trusted-auth=VALUE ENABLE_TRUSTED_AUTH EnableTrustedAuth Enables trusted authentication by an intermediary in the HTTP (Default: False) -AddInterfacePrefixes --add-interface-prefixes=VALUE ADD_INTERFACE_PREFIXES AddInterfacePrefixes Add interface prefixes (Default: True) -UseInternalSsl --use-internal-ssl=VALUE USE_INTERNAL_SSL UseInternalSsl Whether to use secure internal communication. (Default: False) -DisableInsecureTCP --disable-insecure-tcp=VALUE DISABLE_INSECURE_TCP DisableInsecureTCP Whether to disable insecure TCP communication (Default: False) -SslTargetHost --ssl-target-host=VALUE SSL_TARGET_HOST SslTargetHost Target host of server's SSL certificate. (Default: n/a) -SslValidateServer --ssl-validate-server=VALUE SSL_VALIDATE_SERVER SslValidateServer Whether to validate that server's certificate is trusted. (Default: True) -ConnectionPendingSendBytesThreshold --connection-pending-send-bytes-threshold=VALUE CONNECTION_PENDING_SEND_BYTES_THRESHOLD ConnectionPendingSendBytesThreshold The maximum number of pending send bytes allowed before a connection is closed. (Default: 10485760) -FaultOutOfOrderProjections --fault-out-of-order-projections=VALUE FAULT_OUT_OF_ORDER_PROJECTIONS FaultOutOfOrderProjections Specify if a projection should be faulted when there is a discontinuity in event ordering (Default: True) Projections options Command line parameter Environment variable prefixed with EVENTSTORE_ Config file YAML Description -RunProjections --run-projections=VALUE RUN_PROJECTIONS RunProjections Enables the running of projections. System runs built-in projections, All runs user projections. (Default: None) Possible Values:None,System,All -ProjectionThreads --projection-threads=VALUE PROJECTION_THREADS ProjectionThreads The number of threads to use for projections. (Default: 3)"
  },
  "server/indexing/index.html": {
    "href": "server/indexing/index.html",
    "title": "Indexing | Event Store",
    "keywords": "Indexing Event Store stores indexes separately from the main data files, accessing records by stream name. Overview Event Store creates index entries as it processes commit events. It holds these in memory (called memtables ) until it reaches the MaxMemTableSize and then persisted on disk in the index folder along with an index map file. The index files are uniquely named, and the index map file called indexmap . The index map describes the order and the level of the index file as well as containing the data checkpoint for the last written file, the version of the index map file and a checksum for the index map file. The logs refer to the index files as a PTable . Indexes are sorted lists based on the hashes of stream names. To speed up seeking the correct location in the file of an entry for a stream, Event Store keeps midpoints to relate the stream hash to the physical offset in the file. As Event Store saves more files, they are automatically merged together whenever there are more than 2 files at the same level into a single file at the next level. Each index entry is 24 bytes and the index file size is approximately 24Mb per 1M events. Level 0 is the level of the memtable that is kept in memory. Generally there is only 1 level 0 table unless an ongoing merge operation produces multiple level 0 tables. Assuming the default MaxMemTableSize of 1M, the index files by level are: Level Number of entries Size 1 1M 24MB 2 2M 48MB 3 4M 96MB 4 8M 192MB 5 16M 384MB 6 32M 768MB 7 64M 1536MB 8 128M 3072MB n (2^n) * 1M (2^n-1) * 24Mb Each index entry is 24 bytes and the index file size is approximately 24Mb per M events. Configuration Options The configuration options that effect indexing are: Index : where the indexes are stored MaxMemTableSize : how many entries to have in memory before writing out to disk IndexCacheDepth : sets the minimum number of midpoints to calculate for an index file SkipIndexVerify : skips reading and verification of PTables during start-up MaxAutoMergeIndexLevel : the maximum level of index file to merge automatically before manual merge OptimizeIndexMerge : Bypasses the checking of file hashes of indexes during startup and after index merges (allows for faster startup and less disk pressure after merges) See Command line arguments for how to specify these options. Index Index effects the location of the index files. We recommend you place index files on a separate drive to avoid competition for IO between the data, index and log files. MaxMemTableSize MaxMemTableSize effects disk IO when Event Store writes files to disk, index seek time and database startup time. The default size is a good tradeoff between low disk IO and startup time. Increasing the MaxMemTableSize results in longer database startup time because a node has to read through the data files from the last position in the indexmap file and rebuild the in memory index table before it starts. <!-- TODO: Polish a little more --> Increasing MaxMemTableSize also decreases the number of times Event Store writes index files to disk and how often it merges them together, which increases IO operations. It also reduces the number of seek operations when stream entries span multiple files as Event Store needs to search each file for the stream entries. This affects streams written to over longer periods of time more than streams written to over a shorter time, where time is measured by the number of events created, not time passed. This is because streams written to over longer time periods are more likely to have entries in multiple index files. IndexCacheDepth IndexCacheDepth effects the how many midpoints Event Store calculates for an index file which effects file size slightly, but can effect lookup times significantly. Looking up a stream entry in a file requires a binary search on the midpoints to find the nearest midpoint, and then a seek through the entries to find the entry or entries that match. Increasing this value decreases the second part of the operation and increase the first for extremely large indexes. The default value of 16 results in files up to about 1.5GB in size being fully searchable through midpoints. After that a maximum distance between midpoints of 4096 bytes for the seek, which is buffered from disk, up to a maximum level of 2TB where the seek distance starts to grow. Reducing this value can relieve a small amount of memory pressure in highly constrained environments. Increasing it causes index files larger than 1.5GB, and less than 2TB to have more dense midpoint populations which means the binary search is not used for long before switching back to scanning the entries between. The maximum number of entries scanned in this way is distance/24b , so with the default setting and a 2TB index file this is approximately 170 entries. Most clusters should not need to change this setting. SkipIndexVerify SkipIndexVerify skips reading and verification of index file hashes during startup. Instead of recalculating midpoints when Event Store reads the file, it reads the midpoints directly from the footer of the index file. You can set SkipIndexVerify to true to reduce startup time in exchange for the acceptance of a small risk that the index file becomes corrupted. This corruption could lead to a failure if you read the corrupted entries, and a message saying the index needs to be rebuilt. You can safely disable this setting for ZFS on Linux as the filesystem takes care of file checksums. In the event of corruption indexes will be rebuilt by reading through all the chunk files and recreating the indexes from scratch. MaxAutoMergeIndexLevel MaxAutoMergeIndexLevel allows you to specify the maximum index file level to automatically merge. By default Event Store merges all levels. Depending on the specification of the host running Event Store, at some point index merges will use a large amount of disk IO. For example: Merging 2 level 7 files results in at least 3072MB reads (2 * 1536MB), and 3072MB writes while merging 2 level 8 files together results in at least 6144MB reads (2 * 3072MB) and 6144MB writes. Setting MaxAutoMergeLevel to 7 allows all levels up to and including level 7 to be automatically merged, but to merge the level 8 files together, you need to trigger a manual merge. This manual merge allows better control over when these larger merges happen and which nodes they happen on. Due to the replication process, all nodes tend to merge at about the same time. OptimizeIndexMerge OptimizeIndexMerge allows faster merging of indexes when Event Store has scavenged a chunk. This option has no effect on unscavenged chunks. When Event Store has scavenged a chunk, and this option is set to true , it uses a bloom filter before reading the chunk to see if the value exists before reading the chunk to make sure that it still exists. Indexing in depth For general operation of Event Store the following information is not critical but useful for developers wanting to make changes in the indexing subsystem and for understanding crash recovery and tuning scenarios. Index map files Indexmap files are text files made up of line delimited values. The line delimiter varies based on operating system, so while you can consider indexmap files valid when transferred between operating systems, if you make changes to fix an issue (for example, disk corruption) it is best to make them on the same operating system as the cluster. The indexmap structure is as follows: hash - an md5 hash of the rest of the file version - the version of the indexmap file checkpoint - the maximum prepare/commit position of the persisted ptables maxAutoMergeLevel - either the value of MaxAutoMergeLevel or int32.MaxValue if it was not set. This is primarily used to detect increases in MaxAutoMergeLevel , which is not supported. ptable , level , index - List of all the ptables used by this index map with the level of the ptable and it's order. Event Store writes indexmap files to a temporary file and then deletes the original and renames the temporary file. Event Store attempts this 5 times before failing. Because of the order, this operation can only fail if there is an issue with the underlying file system or the disk is full. This is a 2 phase process, and in the unlikely event of a crash during this process, Event Store recovers by rebuilding the indexes using the same process used if it detects corrupted files during startup. Writing and Merging of index files Merging ptables , updating the indexmap and persisting memtable operations happen on a background thread. These operations are performed on a single thread with any additional operations queued and completed later. Event Store runs these operations on a thread pool thread rather than a dedicated thread. Generally there is only one operation queued at a time, but if merging to ptables at one level causes 2 tables to be available at the next level, then the next merge operation is immediately queued. While merge operations are in progress, if Event Store is writing large numbers of events, it may queue 1 or more memtables for persistence. The number of pending operations is logged. For safety ptables Event Store is currently merging are only deleted after the new ptable has persisted and the indexmap updated. In the event of a crash, Event Store recovers by deleting any files not in the indexmap and reindexing from the prepare/commit position stored in the indexmap file. Manual Merging If you have set the maximum level ( MaxAutoMergeIndexLevel ) for automatically merging indexes, then you need to trigger merging indexes above this level manually by using the [/admin/mergeindexes](xref:eventstore.org%2FHTTP%20API%2F5.0.4%2FMerge%20Indexes) endpoint, or the ES-CLI tool that is available with commercial support. Triggering a manual merge causes Event Store to merge all tables that have a level equal to the maximum merge level or above into a single table. If there is only 1 table at the maximum level or above, no merge is performed. Tuning For most Event Store clusters, the default settings are enough to give consistent and good performance. For clusters with larger numbers of events, or those that run in constrained environments the configuration options allow for some tuning to meet operational constraints. The most common optimization needed is to set a MaxAutoMergeLevel to avoid large merges occurring across all nodes at approximately the same time. Large index merges use a lot of IOPS and in IOPS constrained environments it is often desirable to have better control over when these happen. Because increasing this value requires an index rebuild you should start with a higher value and decrease until the desired balance between triggering manual merges (operational cost) and automatic merges (IOPS) cost. The exact value to set this varies between environments due to IOPS generated by other operations such as read and write load on the cluster. For example: A cluster with 3000 256b IOPS can read/write about 0.73Gb/sec (This level of IOPS represents a small cloud instance). Assuming sustained read/write throughput of 0.73Gb/s. When an index merge of level 7 or above starts, it consumes as many IOPS up to all on the node until it completes. Because Event Store has a shared nothing architecture for clustering this operation is likely to cause all nodes to appear to stall simultaneously as they all try and perform an index merge at the same time. By setting MaxAutoMergeLevel to 6 or below you can avoid this, and you can run the merge on each node individually keeping read/write latency in the cluster consistent. <!-- TODO: the 64 bit index bits should probably come under this indexing doc -->"
  },
  "server/uninstalling/index.html": {
    "href": "server/uninstalling/index.html",
    "title": "Uninstalling Event Store | Event Store",
    "keywords": "Uninstalling Event Store This document describes how to uninstall Event Store. The instructions depend on which installation method you used. For different installation methods, refer to Getting started - Step 1 . These instructions cover how to uninstall Event Store, but not how to remove dependencies such as the .NET framework or Mono. Windows Linux macOS Chocolatey If you installed Event Store with Chocolatey, you can uninstall with: choco uninstall eventstore-oss This removes the eventstore-oss Chocolatey package. Binary or built from source If you installed Event Store by downloading a binary , you can remove it by: Deleting the EventStore-OSS-Win-* directory. Removing the directory from your PATH. Pre-built packages If you installed one of the pre-built packages for Debian based systems , you can remove it with: sudo apt-get purge eventstore-oss This removes Event Store completely, including any user settings. Binary or built from source If you built Event Store from source, remove it by deleting the directory containing the source and build, and manually removing any environment variables. <!--NOTE: the following needs to be tested. I am basing it off some googling --> If you installed Event Store using Homebrew, you can remove it with one of the following: brew cask uninstall eventstore Binary or built from source If you built Event Store from source, remove it by deleting the directory containing the source and build, and manually removing any environment variables."
  },
  "http-api/deleting-a-stream/index.html": {
    "href": "http-api/deleting-a-stream/index.html",
    "title": "Deleting a stream | Event Store",
    "keywords": "Deleting a stream Soft deleting To delete a stream over the Atom interface, issue a DELETE request to the resource. Request Response curl -X DELETE \"http://127.0.0.1:2113/streams/newstream\" HTTP/1.1 204 Stream deleted Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 27 Jul 2018 11:51:02 GMT Content-Length: 0 Connection: close By default when you delete a stream, Event Store soft deletes it. This means you can recreate it later by setting the $tb metadata section in the stream. If you try to GET a soft deleted stream you receive a 404 response: Request Response curl -X GET \"http://127.0.0.1:2113/streams/newstream\" -H 'Accept: application/vnd.eventstore.events+json' HTTP/1.1 410 Deleted Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 27 Jul 2018 12:04:10 GMT Content-Length: 0 Connection: close You can recreate the stream by appending new events to it (like creating a new stream): Request Response curl -i -d \"@event-append.json\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/vnd.eventstore.events+json\" -H \"ES-EventType: SomeEvent\" HTTP/1.1 201 Created Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER Access-Control-Allow-Origin: * Location: http://127.0.0.1:2113/streams/newstream/1 Content-Type: text/plain; charset: utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 28 Jun 2013 12:32:18 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 The version numbers do not start at zero but at where you soft deleted the stream from Hard deleting You can hard delete a stream. To issue a permanent delete use the ES-HardDelete header. Warning A hard delete is permanent and the stream is not removed during a scavenge. If you hard delete a stream, you cannot recreate the stream. Issue the DELETE as before but with the permanent delete header: Request Response curl -X DELETE http://127.0.0.1:2113/streams/newstream -H \"ES-HardDelete:true\" HTTP/1.1 204 Stream deleted Content-Length: 0 Content-Type: text/plain; charset=utf-8 Server: Microsoft-HTTPAPI/2.0 Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER, Authorization Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location Date: Thu, 13 Mar 2014 20:56:55 GMT The stream is now permanently deleted, and now the response is a 410 . Request Response curl -X GET \"http://127.0.0.1:2113/streams/newstream\" -H 'Accept: application/vnd.eventstore.events+json' HTTP/1.1 410 Deleted Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 27 Jul 2018 12:04:10 GMT Content-Length: 0 Connection: close If you try to recreate the stream as in the above example you also receive a 410 response. Request Response curl -i -d \"@event-append.json\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/vnd.eventstore.events+json\" -H \"ES-EventType: SomeEvent\" HTTP/1.1 410 Deleted Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER Access-Control-Allow-Origin: * Location: http://127.0.0.1:2113/streams/newstream/1 Content-Type: text/plain; charset: utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 28 Jun 2013 12:32:18 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100"
  },
  "http-api/competing-consumers/index.html": {
    "href": "http-api/competing-consumers/index.html",
    "title": "Competing Consumers | Event Store",
    "keywords": "Competing Consumers This document explains how to use HTTP API for setting up and consuming competing consumer subscription groups. For an overview on competing consumers and how they relate to other subscription types please see our getting started guide . Note The Administration UI includes a Competing Consumers section where you are able to create, update, delete and view subscriptions and their statuses. Creating a Persistent Subscription Before interacting with a subscription group, you need to create one. You receive an error if you try to create a subscription group more than once. This requires admin permissions . <!-- TODO: File inclusion for the below? --> URI Supported Content Types Method /subscriptions/{stream}/{subscription_name} application/json PUT Query Parameters Parameter Description stream The stream the persistent subscription is on. subscription_name The name of the subscription group. Body Parameter Description resolveLinktos Tells the subscription to resolve link events. startFrom Start the subscription from the position-of the event in the stream. extraStatistics Tells the backend to measure timings on the clients so statistics will contain histograms of them. checkPointAfterMilliseconds The amount of time the system should try to checkpoint after. liveBufferSize The size of the live buffer (in memory) before resorting to paging. readBatchSize The size of the read batch when in paging mode. bufferSize The number of messages that should be buffered when in paging mode. maxCheckPointCount The maximum number of messages not checkpointed before forcing a checkpoint. maxRetryCount Sets the number of times a message should be retried before considered a bad message. maxSubscriberCount Sets the maximum number of allowed TCP subscribers. messageTimeoutMilliseconds Sets the timeout for a client before the message will be retried. minCheckPointCount The minimum number of messages to write a checkpoint for. namedConsumerStrategy RoundRobin/DispatchToSingle/Pinned Updating a Persistent Subscription You can edit the settings of an existing subscription while it is running. This drops the current subscribers and resets the subscription internally. This requires admin permissions. URI Supported Content Types Method /subscriptions/{stream}/{subscription_name} application/json POST Query Parameters Parameter Description stream The stream to the persistent subscription is on. subscription_name The name of the subscription group. Body Same parameters as \"Creating a Persistent Subscription\" Deleting a Persistent Subscription URI Supported Content Types Method /subscriptions/{stream}/{subscription_name} application/json DELETE Query Parameters Parameter Description stream The stream to the persistent subscription is on. subscription_name The name of the subscription group. Reading a stream via a Persistent Subscription By default, reading a stream via a persistent subscription returns a single event per request and does not embed the event properties as part of the response. URI Supported Content Types Method /subscriptions/{stream}/{subscription_name} /subscriptions/{stream}/{subscription_name}?embed={embed} /subscriptions/{stream}/{subscription}/{count}?embed={embed} application/vnd.eventstore.competingatom+xml application/vnd.eventstore.competingatom+json GET Query Parameters Parameter Description stream The stream the persistent subscription is on. subscription_name The name of the subscription group. count How many events to return for the request. embed None , Content , Rich , Body , PrettyBody , TryHarder Read Reading Streams for information on the different embed levels. Response { \"title\": \"All Events Persistent Subscription\", \"id\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1\", \"updated\": \"2015-12-02T09:17:48.556545Z\", \"author\": { \"name\": \"EventStore\" }, \"headOfStream\": false, \"links\": [ { \"uri\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1/ack%3Fids=c322e299-cb73-4b47-97c5-5054f920746f\", \"relation\": \"ackAll\" }, { \"uri\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1/nack%3Fids=c322e299-cb73-4b47-97c5-5054f920746f\", \"relation\": \"nackAll\" }, { \"uri\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1/1%3Fembed=None\", \"relation\": \"previous\" }, { \"uri\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1\", \"relation\": \"self\" } ], \"entries\": [ { \"title\": \"1@newstream\", \"id\": \"http://localhost:2113/streams/newstream/1\", \"updated\": \"2015-12-02T09:17:48.556545Z\", \"author\": { \"name\": \"EventStore\" }, \"summary\": \"SomeEvent\", \"links\": [ { \"uri\": \"http://localhost:2113/streams/newstream/1\", \"relation\": \"edit\" }, { \"uri\": \"http://localhost:2113/streams/newstream/1\", \"relation\": \"alternate\" }, { \"uri\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1/ack/c322e299-cb73-4b47-97c5-5054f920746f\", \"relation\": \"ack\" }, { \"uri\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1/nack/c322e299-cb73-4b47-97c5-5054f920746f\", \"relation\": \"nack\" } ] } ] } Acknowledgements Clients must acknowledge (or not acknowledge) messages in the competing consumer model. If the client fails to respond in the given timeout period, the message is retried. You should use the rel links in the feed for acknowledgements not bookmark URIs as they are subject to change in future versions. For example: { \"uri\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1/ack/c322e299-cb73-4b47-97c5-5054f920746f\", \"relation\": \"ack\" } Ack multiple messages URI Supported Content Types Method /subscriptions/{stream}/{subscription_name}/ack?ids={messageids} application/json POST Query Parameters Parameter Description stream The stream the persistent subscription is on. subscription_name The name of the subscription group. messageids The ids of the messages that needs to be acked Ack a single message URI Supported Content Types Method /subscriptions/{stream}/{subscription_name}/ack/{messageid} application/json POST Query Parameters Parameter Description stream The stream to the persistent subscription is on. subscription_name The name of the subscription group. messageid The id of the message that needs to be acked <!-- Has this been explained? --> Nack multiple messages URI Supported Content Types Method /subscriptions/{stream}/{subscription_name}/nack?ids={messageids}?action={action} application/json POST Query Parameters Parameter Description stream The stream to the persistent subscription is on. subscription_name The name of the subscription group. action Park : Don't retry the message, park it until a request is sent to reply the parked messages Retry : Retry the message Skip : Discard the message Stop : Stop the subscription messageid The id of the message that needs to be acked Nack a single message URI Supported Content Types Method /subscriptions/{stream}/{subscription_name}/nack/{messageid}?action={action} application/json POST Replaying parked messages URI Supported Content Types Method /subscriptions/{stream}/{subscription_name}/replayParked application/json POST Getting information for all subscriptions URI Method /subscriptions GET Response [ { \"links\": [ { \"href\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1/info\", \"rel\": \"detail\" } ], \"eventStreamId\": \"newstream\", \"groupName\": \"competing_consumers_group1\", \"parkedMessageUri\": \"http://localhost:2113/streams/$persistentsubscription-newstream::competing_consumers_group1-parked\", \"getMessagesUri\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1/1\", \"status\": \"Live\", \"averageItemsPerSecond\": 0.0, \"totalItemsProcessed\": 0, \"lastProcessedEventNumber\": -1, \"lastKnownEventNumber\": 5, \"connectionCount\": 0, \"totalInFlightMessages\": 0 }, { \"links\": [ { \"href\": \"http://localhost:2113/subscriptions/another_newstream/competing_consumers_group1/info\", \"rel\": \"detail\" } ], \"eventStreamId\": \"another_newstream\", \"groupName\": \"competing_consumers_group1\", \"parkedMessageUri\": \"http://localhost:2113/streams/$persistentsubscription-another_newstream::competing_consumers_group1-parked\", \"getMessagesUri\": \"http://localhost:2113/subscriptions/another_newstream/competing_consumers_group1/1\", \"status\": \"Live\", \"averageItemsPerSecond\": 0.0, \"totalItemsProcessed\": 0, \"lastProcessedEventNumber\": -1, \"lastKnownEventNumber\": -1, \"connectionCount\": 0, \"totalInFlightMessages\": 0 } ] Getting information about the subscriptions for a stream URI Supported Content Types Method /subscriptions/{stream} application/json GET Response [ { \"links\": [ { \"href\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1/info\", \"rel\": \"detail\" } ], \"eventStreamId\": \"newstream\", \"groupName\": \"competing_consumers_group1\", \"parkedMessageUri\": \"http://localhost:2113/streams/$persistentsubscription-newstream::competing_consumers_group1-parked\", \"getMessagesUri\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1/1\", \"status\": \"Live\", \"averageItemsPerSecond\": 0.0, \"totalItemsProcessed\": 0, \"lastProcessedEventNumber\": -1, \"lastKnownEventNumber\": 5, \"connectionCount\": 0, \"totalInFlightMessages\": 0 } ] Getting information about a specific subscription URI Supported Content Types Method /subscriptions/{stream}/{subscription_name}/info application/json GET Response { \"links\": [ { \"href\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1/info\", \"rel\": \"detail\" }, { \"href\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1/replayParked\", \"rel\": \"replayParked\" } ], \"config\": { \"resolveLinktos\": false, \"startFrom\": 0, \"messageTimeoutMilliseconds\": 10000, \"extraStatistics\": false, \"maxRetryCount\": 10, \"liveBufferSize\": 500, \"bufferSize\": 500, \"readBatchSize\": 20, \"preferRoundRobin\": true, \"checkPointAfterMilliseconds\": 1000, \"minCheckPointCount\": 10, \"maxCheckPointCount\": 500, \"maxSubscriberCount\": 10, \"namedConsumerStrategy\": \"RoundRobin\" }, \"eventStreamId\": \"newstream\", \"groupName\": \"competing_consumers_group1\", \"status\": \"Live\", \"averageItemsPerSecond\": 0.0, \"parkedMessageUri\": \"http://localhost:2113/streams/$persistentsubscription-newstream::competing_consumers_group1-parked\", \"getMessagesUri\": \"http://localhost:2113/subscriptions/newstream/competing_consumers_group1/1\", \"totalItemsProcessed\": 0, \"countSinceLastMeasurement\": 0, \"lastProcessedEventNumber\": -1, \"lastKnownEventNumber\": 5, \"readBufferCount\": 6, \"liveBufferCount\": 5, \"retryBufferCount\": 0, \"totalInFlightMessages\": 0, \"connections\": [] } <!-- TODO: Is this better as a general subscriptions page? --> <!-- TODO: Somehow get this better integrated with API docs --> <!-- TODO: Still to do -->"
  },
  "event-sourcing-basics/rolling-snapshots/index.html": {
    "href": "event-sourcing-basics/rolling-snapshots/index.html",
    "title": "Rolling snapshots | Event Store",
    "keywords": "Rolling snapshots A rolling snapshot is a projection of the current state of an aggregate at a given point. It represents the state when all events to that point have been replayed. You use rolling snapshots as a heuristic to prevent the need to load all events for the entire history of an aggregate. One way of processing events in the event stream is to replay the events from the beginning of time until the end of the event stream. The problem is that there may be a large number of events between the beginning of time and the current point. You can imagine that an event stream with a million or more events would be inefficient to load. The solution is to use a rolling snapshot to place a denormalization of the state at a given point. It is then possible to play the events from that point forward to load the aggregate. The process for rebuilding an aggregate changes when using rolling snapshots. Instead of reading forward from the beginning of time it is read backwards, putting the events on to a stack until there are no more events left or a snapshot is found. The snapshot is then applied and the events would popped off the stack and applied until the stack was empty. Note Although this is an easy way to conceptualize how rolling snapshots work, this is a less than ideal solution in a production system for various reasons. It is better to store them separately events. The snapshot itself is nothing more than a serialized form of the graph at that given point. By having the state of that graph at that point replaying all the events prior to that snapshot can be avoided. Snapshots can be taken asynchronously by a process monitoring the Event Store. Introducing Rolling Snapshots allows control of the worst case when loading from events. The maximum number of events that would be processed can be tuned to optimize performance for the system in question. With the introduction of Rolling Snapshots it is a relatively trivial process to achieve one to two orders of magnitude of performance gain on the two operations that the Event Storage supports. It is important though to remember that Rolling Snapshots are just a heuristic and that conceptually the event stream is still viewed in its entirety."
  },
  "event-sourcing-basics/performance-and-scaling/index.html": {
    "href": "event-sourcing-basics/performance-and-scaling/index.html",
    "title": "Performance and scalability | Event Store",
    "keywords": "Performance and scalability There are also architectural benefits to not deleting data. The storage system becomes an append-only architecture. Append-only architectures typically distribute and scale more easily than updating architectures because there are fewer locks to deal with. A common performance optimization is the use of \"horizontal partitioning\" (or \"sharding\"), where the same schema will exist in many places and a key within the data will determine in which place the data exists. One problem with horizontal partitioning with an RDMS is that it is necessary to define the key with which the partitioning should operate. This problem goes away when using events. Aggregate IDs are the only partition point in the system. No matter how many aggregates exist or how they may change structures, the aggregate ID associated with events is the only partition point in the system. Horizontally partitioning an Event Store is a simpler process. Saving objects When dealing with a stereotypical system utilizing an RDMS it can be complex to figure out what has changed within the aggregate. Many tools have been built to help alleviate the pain that arises from this task but is the need for a tool a sign of a bigger problem? Most Object-relational mapping (ORM) tools figure out the changes that occurred within a graph. They do this by maintaining two copies of a given graph. The first held in memory and the second for applications to interact with. When it's time to save, the database logic traverses the graph that the code has interacted with and uses the copy of the original graph to determine what has changed while the graph was in use by the code. These changes are then saved to the data storage system. In a system that is Domain Event centric, the aggregates are themselves tracking strong events as to what has changed within them. There is no complex process for comparing to another copy of a graph. Instead ask the aggregate for its changes. The operation to ask for changes is far more efficient than having to figure out what has changed. Loading objects A similar issue exists when loading objects. Consider the work that involved with loading a graph of objects in a stereotypical relational database backed system. Often there are many queries that must be issued to build the aggregate. To help minimize the latency cost of these queries many ORMs have introduced a heuristic of \"Lazy Loading\" also known as \"Delayed Loading\", where a proxy is given in lieu of the real object. The data is only loaded when some code attempts to use that particular object. Lazy loading is useful because often a given behavior will only use a certain portion of data out of the aggregate and it prevents the developer from having to explicitly represent which data that is while reducing the cost of the loading of the aggregate. It is this need for reducing cost that shows a problem. Aggregates are considered as a whole represented by the Aggregate Root. Conceptually an Aggregate is loaded and saved in its entirety. Evans, 2001 Conceptually it is much easier to deal with the concept of an aggregate loaded and saved in its entirety. The concept of lazy loading is not a trivial one and especially when optimizing use cases. The heuristic is needed because loading full aggregates from a relational database is operationally too slow. When dealing with events as a storage mechanism things are different. There is one thing stored, events. Load all the events for an aggregate and replay them. There can only ever be a single query on the system. There is no need to attempt to implement things like lazy loading."
  },
  "server/users-and-access-control-lists/index.html": {
    "href": "server/users-and-access-control-lists/index.html",
    "title": "Users and access control lists | Event Store",
    "keywords": "Users and access control lists Default users Event Store provides two default users, $ops and $admin . $admin has full access to everything in Event Store. It can read and write to protected streams, which is any stream that starts with $, such as $projections-master . Protected streams are usually system streams, for example, $projections-master manages some of the projections' states. The $admin user can also run operational commands, such as scavenges and shutdowns on Event Store. An $ops user can do everything that an $admin can do except manage users and read from system streams (except for $scavenges and $scavenges-streams ). New users New users created in Event Store are standard non-authenticated users. Non-authenticated users are allowed GET access to the /info , /ping , /stats , /elections , and /gossip system streams. POST access to the /elections and /gossip system streams is only allowed on the internal HTTP service. By default, any user can read any non-protected stream unless there is an ACL preventing that. Stream ACLs Event Store keeps the ACL of a stream in the streams metadata as JSON with the below definition: { \"$acl\": { \"$w\": \"$admins\", \"$r\": \"$all\", \"$d\": \"$admins\", \"$mw\": \"$admins\", \"$mr\": \"$admins\" } } These fields represent the following: $w The permission to write to this stream. $r The permission to read from this stream. $d The permission to delete this stream. $mw The permission to write the metadata associated with this stream. $mr The permission to read the metadata associated with this stream. You can update these fields with either a single string or an array of strings representing users or groups ( $admins , $all , or custom groups). It's possible to put an empty array into one of these fields, and this has the effect of removing all users from that permission. Note We recommend you don't give people access to $mw as then they can then change the ACL. Example The ACL below gives writer read and write permission on the stream, while reader has read permission on the stream. Only users in the $admins group can delete the stream or read and write the metadata. HTTP API Response .NET API Inside a file named metadata.json : [ { \"eventId\": \"7c314750-05e1-439f-b2eb-f5b0e019be72\", \"eventType\": \"update-acl\", \"metadata\": { \"$acl\": { \"$w\": \"writer\", \"$r\": [ \"reader\", \"also-reader\" ], \"$d\": \"$admins\", \"$mw\": \"$admins\", \"$mr\": \"$admins\" } } } ] curl -i -d @metadata.json http://127.0.0.1:2113/streams/newstream/metadata --user admin:changeit -H \"Content-Type: application/vnd.eventstore.events+json\" HTTP/1.1 201 Created Access-Control-Allow-Methods: GET, POST, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Location: http://127.0.0.1:2113/streams/%24%24newstream/0 Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Tue, 18 Sep 2018 09:38:56 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 <!-- TODO: Refactor into demo application --> StreamMetadata metadata = StreamMetadata.Build() .SetCustomPropertyWithValueAsRawJsonString(\"customRawJson\", @\"{ \"\"$acl\"\": { \"\"$w\"\": \"\"writer\"\", \"\"$r\"\": [ \"\"reader\"\", \"\"also-reader\"\" ], \"\"$d\"\": \"\"$admins\"\", \"\"$mw\"\": \"\"$admins\"\", \"\"$mr\"\": \"\"$admins\"\" }}\"); conn.SetStreamMetadataAsync(streamName, ExpectedVersion.Any, metadata, adminCredentials); Default ACL The $settings stream has a special ACL used as the default ACL. This stream controls the default ACL for streams without an ACL and also controls who can create streams in the system, the default state of these is shown below: { \"$userStreamAcl\": { \"$r\": \"$all\", \"$w\": \"$all\", \"$d\": \"$all\", \"$mr\": \"$all\", \"$mw\": \"$all\" }, \"$systemStreamAcl\": { \"$r\": \"$admins\", \"$w\": \"$admins\", \"$d\": \"$admins\", \"$mr\": \"$admins\", \"$mw\": \"$admins\" } } You can rewrite these to the $settings stream with the following cURL command: curl -i \"http://127.0.0.1:2113/streams/%24settings\" \\ --user admin:changeit \\ -H \"Content-Type: application/vnd.eventstore.events+json\" \\ -d $'[{ \"eventId\": \"7c314750-05e1-439f-b2eb-f5b0e019be72\", \"eventType\": \"update-default-acl\", \"data\": { \"$userStreamAcl\" : { \"$r\" : [\"$admin\", \"$ops\", \"service-a\", \"service-b\"], \"$w\" : [\"$admin\", \"$ops\", \"service-a\", \"service-b\"], \"$d\" : [\"$admin\", \"$ops\"], \"$mr\" : [\"$admin\", \"$ops\"], \"$mw\" : [\"$admin\", \"$ops\"] }, \"$systemStreamAcl\" : { \"$r\" : \"$admins\", \"$w\" : \"$admins\", \"$d\" : \"$admins\", \"$mr\" : \"$admins\", \"$mw\" : \"$admins\" } } }]' The $userStreamAcl controls the default ACL for user streams, while all system streams use the $systemStreamAcl as the default. Note The $w in $userStreamAcl also applies to the ability to create a stream. Members of $admins always have access to everything, you cannot remove this permission. When you set a permission on a stream, it overrides the default values. However, it's not necessary to specify all permissions on a stream. It's only necessary to specify those which differ from the default. Example Note All these examples assume you have created a user named ouro . The examples also assume the password is ouroboros . { \"$userStreamAcl\": { \"$r\": \"$all\", \"$w\": \"ouro\", \"$d\": \"ouro\", \"$mr\": \"ouro\", \"$mw\": \"ouro\" }, \"$systemStreamAcl\": { \"$r\": \"$admins\", \"$w\": \"$admins\", \"$d\": \"$admins\", \"$mr\": \"$admins\", \"$mw\": \"$admins\" } } This default ACL gives ouro and $admins create and write permissions on all streams, while everyone else can read from them. Be careful allowing default access to system streams to non-admins as they would also have access to $settings unless you specifically override it. Request Response .NET API [ { \"eventId\": \"7c314750-05e1-439f-b2eb-f5b0e019be72\", \"eventType\": \"update-default-acl\", \"data\": { \"$userStreamAcl\": { \"$r\": \"$all\", \"$w\": \"ouro\", \"$d\": \"ouro\", \"$mr\": \"ouro\", \"$mw\": \"ouro\" }, \"$systemStreamAcl\": { \"$r\": \"$admins\", \"$w\": \"$admins\", \"$d\": \"$admins\", \"$mr\": \"$admins\", \"$mw\": \"$admins\" } } } ] curl -i -d @override-default.json http://127.0.0.1:2113/streams/%24settings/metadata --user admin:changeit -H \"Content-Type: application/vnd.eventstore.events+json\" Warning You should not copy/paste the UUID in the command line above but generate a new one or not provide one (you will be redirected to a URI with one as described in writing events in the HTTP API). HTTP/1.1 201 Created Access-Control-Allow-Methods: GET, POST, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Location: http://127.0.0.1:2113/streams/%24%24%24users/0 Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Thu, 23 Aug 2018 10:35:19 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 <!-- TODO: Refactor into demo application --> StreamMetadata metadata = StreamMetadata.Build() .SetCustomPropertyWithValueAsRawJsonString(\"customRawJson\", @\"{ \"\"$userStreamAcl\"\": { \"\"$r\"\": \"\"$all\"\", \"\"$w\"\": \"\"ouro\"\", \"\"$d\"\": \"\"ouro\"\", \"\"$mr\"\": \"\"ouro\"\", \"\"$mw\"\": \"\"ouro\"\" }, \"\"$systemStreamAcl\"\": { \"\"$r\"\": \"\"$admins\"\", \"\"$w\"\": \"\"$admins\"\", \"\"$d\"\": \"\"$admins\"\", \"\"$mr\"\": \"\"$admins\"\", \"\"$mw\"\": \"\"$admins\"\" } }}\"); conn.SetStreamMetadataAsync(\"%24settings\", ExpectedVersion.Any, metadata, adminCredentials); If you try to access the $settings stream as an unauthorized user, Event Store returns a 401 response. Request Response curl -i http://127.0.0.1:2113/streams/%24settings -u ouro:ouroboros HTTP/1.1 401 Unauthorized Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTo, ES-ExpectedVersion Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position WWW-Authenticate: Basic realm=\"ES\" Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Mon, 02 Mar 2015 15:21:27 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 If you wanted to give ouro access by default to system streams, POST the following JSON: { \"$userStreamAcl\": { \"$r\": \"$all\", \"$w\": \"ouro\", \"$d\": \"ouro\", \"$mr\": \"ouro\", \"$mw\": \"ouro\" }, \"$systemStreamAcl\": { \"$r\": [\"$admins\", \"ouro\"], \"$w\": \"$admins\", \"$d\": \"$admins\", \"$mr\": \"$admins\", \"$mw\": \"$admins\" } } At which point ouro can read system streams by default: Request Response curl -i http://127.0.0.1:2113/streams/%24settings -u ouro:ouroboros HTTP/1.1 200 OK Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTo, ES-ExpectedVersion Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position Cache-Control: max-age=0, no-cache, must-revalidate Vary: Accept ETag: \"1;-1296467268\" Content-Type: application/atom+xml; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Mon, 02 Mar 2015 15:25:17 GMT Content-Length: 1286 Keep-Alive: timeout=15,max=100 You can also limit ACLs on particular streams which are then merged with the default ACLs. { \"$acl\": { \"$r\": [\"reader\", \"also-reader\"] } } If you add the above to a stream's ACL, then it overrides the read permission on that stream to allow reader and also-reader to read streams, but not ouro , resulting in the effective ACL below. { \"$acl\": { \"$r\": [\"reader\", \"also-reader\"], \"$w\": \"ouro\", \"$d\": \"ouro\", \"$mr\": \"ouro\", \"$mw\": \"ouro\" } } Warning Caching is allowed on a stream if you have enabled it to be visible to $all . This is as a performance optimization to avoid having to set cache=private on all data. If people are bookmarking your URIs and they were cached by an intermediary then they may still be accessible after you change the permissions from $all . While clients should not be bookmarking URIs in this way, it's an important consideration."
  },
  "server/setting-up-varnish-in-linux/index.html": {
    "href": "server/setting-up-varnish-in-linux/index.html",
    "title": "Setting up Varnish in Linux | Event Store",
    "keywords": "Setting up Varnish in Linux Note This guide uses the latest Ubuntu LTS (18.04) You use a reverse proxy to limit access to Event Store without breaking HTTP caching (authenticate to the proxy not to Event Store itself). Since Event Store runs HTTP only on the loopback adapter, users must enter through the reverse proxy to reach Event Store. This document provides a brief guide on how to install Event Store with the varnish reverse proxy in a Linux environment. For more information on how to properly configure varnish for your requirements, read the Varnish documentation . Ben Clark's Gist contains a varnish configuration that includes basic authentication as well as some other niceties such as adding headers for hits/misses. Install Varnish sudo apt-get update sudo apt-get install varnish Configure Varnish Open /etc/default/varnish and edit the section that looks like the below to the port with the port you want to run on: DAEMON_OPTS=\"-a :80 \\ -T localhost:6082 \\ -f /etc/varnish/default.vcl \\ -S /etc/varnish/secret \\ -s malloc,256m\" Open /etc/varnish/default.vcl and edit the backend section to match Event Store: backend default { .host = \"127.0.0.1\"; .port = \"2114\"; } Finally use sudo service varnish restart to restart varnish and Event Store should be running with a reverse proxy in front of it. If you want to check the status of varnish, use varnishstat ."
  },
  "server/ports-and-networking/index.html": {
    "href": "server/ports-and-networking/index.html",
    "title": "Ports and networking | Event Store",
    "keywords": "Ports and networking Single node If you run Event Store as a single node, it only uses two ports. The first port is the external HTTP port, and the default value is 2113 . Event Store uses this port for both the client HTTP APIs and for the management HTTP interface. The second port used is the TCP interface for clients connecting over the client API, and the default for the port is 1113 . Event Store in Windows tries to add access via http.sys automatically for the 2113 port. You should ensure that these ports are open and allowed via a firewall. Cluster node When running in cluster mode the networking for Event Store is more complex. Cluster mode requires 4 ports to run. The ports are for internal HTTP, internal TCP, external HTTP, and external TCP. <!-- TODO: And they are? --> The internal and external interfaces allow for separation of traffic. The internal network is where cluster communications runs, while the external interfaces is where client communications runs. This separation allows for more secure setups such as putting internal communications on a different network than external client communications. For example, you might want to allow clients over HTTP to talk directly to Event Store, and you can move internal communications to a separate network to ensure the management interface and internal operations are not accessible to external traffic. The external TCP and HTTP ports are similar to the HTTP and TCP ports of a single node deploy. Event Store runs client requests over the HTTP API through the external HTTP port. You can run without the management API on the external interface (internal only). The external and the internal interfaces support the gossip protocol. You can control whether the admin interface is available on the external HTTP interface using the admin-on-ext option . You can control whether gossip is enabled on external interfaces with the gossip-on-ext option (you normally want it enabled). You configure the internal TCP and HTTP ports in the same way as the external. All internal communications for the cluster happen over these interfaces. Elections and internal gossip happen over HTTP. Replication and forwarding of client requests happens over the TCP channel. When setting up a cluster the nodes must be able to reach each other over both the internal HTTP channel and the internal TCP channel. You should ensure that these ports are open on firewalls on the machines and between the machines. Heartbeat timeouts Event Store uses heartbeats over all TCP connections to discover dead clients and nodes. Setting heartbeat timeouts requires thought. Set them too short and you receive false positives, set them too long and discovery of dead clients and nodes is slower. Each heartbeat has two points of configuration. The first is the 'interval', this represents how often the system should consider a heartbeat. Event Store doesn't send a heartbeat for every interval. Event Store sends heartbeat requests if it has not heard from a node within the configured interval. On a busy cluster, you may never see any heartbeats. The second point of configuration is the 'timeout'. This determines how long Event Store waits for a client or node to respond to a heartbeat request. Different environments need different values for these settings. While low numbers work well on a LAN they tend to not work well in the cloud. The defaults are likely fine on a LAN, for the cloud, consider setting: An interval of 5000ms. A timeout of 1000ms. Tip If in doubt, choose higher numbers. This adds a small period of time to discover a dead client or node and is better than the alternative, which is false positives. Advertise as Due to NAT, or other reasons a node may not be bound to the address it is reachable from other nodes. For example, the machine has an IP address of 192.168.1.13, but the node is visible to other nodes as 10.114.12.112. The option advertise-as allows you to tell the node that even though it is bound to a given address it should not gossip that address. Instead it uses the address that you tell it to use. In the example above you would configure\" --ext-ip 192.168.1.13 --advertise-as 10.114.12.112 Or use the equivalent configuration via environment variables or a configuration file."
  },
  "server/metadata-and-reserved-names/index.html": {
    "href": "server/metadata-and-reserved-names/index.html",
    "title": "Metadata and reserved names | Event Store",
    "keywords": "Metadata and reserved names Stream metadata Every stream in Event Store has metadata stream associated with it, prefixed by $$ , so the metadata stream from a stream called foo is $$foo . Event Store allows you to change some values in the metadata, and you can write your own data into stream metadata that you can refer to in your code. Reserved names All internal data used by Event Store is prefixed with a $ character (for example $maxCount on a stream's metadata). Because of this you should not use names with a $ prefix as event names, metadata keys, or stream names, except where detailed below. The supported internal settings are: Name Description $maxAge Sets a sliding window based on dates. When data reaches a certain age it disappears automatically from the stream and is considered eligible for scavenging. This value is set as an integer representing the number of seconds. This value must be >=1. $maxCount Sets a sliding window based on the number of items in the stream. When data reaches a certain length it disappears automatically from the stream and is considered eligible for scavenging. This value is set as an integer representing the count of items. This value must be >= 1. $cacheControl This controls the cache of the head of a stream. Most URIs in a stream are infinitely cacheable but the head by default will not cache. It may be preferable in some situations to set a small amount of caching on the head to allow intermediaries to handle polls (say 10 seconds). The argument is an integer representing the seconds to cache. This value must be >= 1. Note If you set both $maxAge and $maxCount then events will become eligible for scavenging when either criteria is met. For example, if you set $maxAge to 10 and $maxCount to 50,000, events will be marked as eligible for scavenging after either 10 seconds, or 50,000 events, have passed. Deleted items will only be removed once the scavenge process runs. Security access control lists are also included in the $acl section of the stream metadata. Name Description $r The list of users with read permissions $w The list of users with write permissions $d The list of users with delete permissions $mw The list of users with write permissions to stream metadata $mr The list of users with read permissions to stream metadata You can find more details on access control lists can here . Event metadata Every event in Event Store has metadata associated with it. Event Store allows you to change some values in the metadata, and you can write your own data into event metadata that you can refer to in your code. All names starting with $ are reserved space for internal use. The currently supported reserved internal names are: $correlationId The application level correlation ID associated with this message. $causationId The application level causation ID associated with this message. Projections honor both the correlationId and causationId patterns for any events it produces internally (linkTo/emit/etc)."
  },
  "server/index.html": {
    "href": "server/index.html",
    "title": "Running Event Store | Event Store",
    "keywords": "Running Event Store Event Store runs as a server that clients can connect to either over HTTP or using one of the client APIs . You can run both the open source and commercial versions as either a single node or a highly available cluster of nodes. We distribute an open source version of Event Store as a console application. There are separate distributions for Windows on .NET and Linux/macOS on Mono. Install and run Event Store Note Unless you pass a database option with --db , Event Store writes to a new database created in the host system's temporary files path each time it is started. For more information on Command Line Arguments read this guide . Windows Linux Docker Kubernetes macOS The prerequisites for installing on Windows are: NET Framework 4.0+ Event Store has Chocolatey packages available that you can install with the following command: choco install eventstore-oss You can also download a binary, unzip the archive and run from the folder location with an administrator console. The following command starts Event Store with the database stored at the path ./db and the logs in ./logs . You can view further command line arguments in the server docs . EventStore.ClusterNode.exe --db ./db --log ./logs Event Store runs in an administration context because it starts an HTTP server through http.sys . For permanent or production instances you need to provide an ACL such as: netsh http add urlacl url=http://+:2113/ user=DOMAIN\\username For more information, refer to Microsoft's add urlacl documentation . To build Event Store from source, refer to the Event Store README . The prerequisites for installing on Linux are: We recommend Mono 5.16.0 , but other versions may also work. Event Store has pre-built packages available for Debian-based distributions , manual instructions for distributions that use RPM , or you can build from source . The final package name to install is eventstore-oss . If you installed from a pre-built package, start Event Store with: sudo systemctl start eventstore When you install the Event Store package, the service doesn't start by default. This is to allow you to change the configuration, located at /etc/eventstore/eventstore.conf and to prevent creating a default database. Tip To start Event Store on port 80 as a service, refer to Configuring your installation Tip We recommend that when using Linux you set the 'open file limit' to a high number. The precise value depends on your use case, but at least between 30,000 and 60,000 . Event Store has a Docker image available for any platform that supports Docker. Pull the Docker image: docker pull eventstore/eventstore Run the container: docker run --name eventstore-node -it -p 2113:2113 -p 1113:1113 eventstore/eventstore Refer to the image overview for more information. Event Store has a Helm chart available for installing Event Store on Kubernetes clusters: helm repo add eventstore https://eventstore.github.io/EventStore.Charts helm repo update helm install -n eventstore eventstore/eventstore Note Read this guide for more details on how to use the helm chart. Read this guide for more details on using Kubernetes with AKS and this guide for more details on using Kubernetes with GKE. Event Store has a macOS package you can download and install, and we maintain a Homebrew Cask formula you can install: brew cask install eventstore In each case you can run Event Store with the eventstore command, and stop it with Ctrl+c . To use the default database location you need to use sudo , or you can change the location with the --db parameter. To build Event Store from source, refer to the Event Store README . Solving 503 errors from the Admin UI There is a known issue with the .NET HTTPListener class (which Event Store uses) and bad URL ACL registrations, which can cause servers to return 503 errors for every request. If you see this, you can issue the following commands: netsh http show urlacl Look for an entry on the port you're trying to use ( 2113 unless you've specified a custom port), then issue: netsh http delete urlacl <the entry you just found> For example: netsh http delete urlacl http://+:2113/ These steps should resolve the issue. Shutting down an Event Store node Event Store is designed to be safe by default, and it is expected that it will be shut down using kill -9 . It is also possible to initiate a shutdown via the Admin UI, by clicking on the Shutdown Server button located on the Admin page. This may be useful if you do not have console access to the node or need to script initiating a shutdown. Securing Event Store To secure Event Store, you can bind the server to the localhost interface and install a reverse proxy such as nginx or Varnish on the public IP. Read this guide for an example of setting up Event Store with Varnish. The reverse proxy is your public interface. Internally it handles the authentication and route requests to Event Store. Event Store is only accessible through the localhost adapter and is not exposed publicly. The locally running reverse proxy is allowed to cache responses, and because of this, reverse proxies are more performant than calling Event Store directly. Even if you use a reverse proxy, you can support external authentication from Event Store itself. You do this by enabling the ES-TrustedAuth trusted intermediary option in your configuration. This allows the intermediary to write a header with the user information that Event Store uses."
  },
  "server/deleting-streams-and-events/index.html": {
    "href": "server/deleting-streams-and-events/index.html",
    "title": "Deleting streams and events | Event Store",
    "keywords": "Deleting streams and events Meta data in Event Store defines whether an event is deleted or not. You can use stream metadata such as TruncateBefore , MaxAge and MaxCount to filter events considered deleted. When reading a stream, the index checks the stream's metadata to determine whether any of its events have been deleted. $all bypasses the index, meaning that it does not check the metadata to determine whether events exist or not. As such, events that have been deleted are still be readable until a scavenge has removed them. There are requirements for a scavenge to successfully remove events, for more information about this, read the scavenging guide . Warning The last event in a stream is always kept as a record of the last event number in the stream. Soft delete and TruncateBefore TruncateBefore and $tb considers any event with an event number lower than its value as deleted. For example, if you had the following events in a stream : 0@test-stream 1@test-stream 2@test-stream 3@test-stream If you set the TruncateBefore or $tb value to 3, a read of the stream would result in only reading the last event: 3@test-stream A Soft delete makes use of TruncateBefore and $tb . When you delete a stream, its TruncateBefore or $tb is set to the streams current last event number. When you read a soft deleted stream, the read returns a StreamNotFound or 404 result. After deleting the stream, you are able to write to it again, continuing from where it left off. For example, if you soft deleted the above example stream, the TruncateBefore or $tb is set to 3 (the stream's current event number). If you were to write to the stream again, the next event is written with event number 4. Only events from event number 4 onwards are visible when you read this stream. Max count and Max age Max count ( $maxCount and MaxCount ) limits the number of events that you can read from a stream. If you try to read a stream that has a max count of 5, you are only able to read the last 5 events, regardless of how many events are in the stream. Max age ( $maxAge and MaxAge ) specifies the number of seconds an event can live for. The age is calculated at the time of the read. So if you read a stream with a MaxAge of 3 minutes and one of the events in the stream has existed for 4 minutes at the time of the read, it is not returned. Hard delete A hard delete writes a tombstone event to the stream, permanently deleting it. You cannot recreate the stream, or write to it again. Tombstone events are written with the event type $streamDeleted . When you read a hard deleted stream, the read returns a StreamDeleted or 410 result. The events in the deleted stream are liable to be removed in a scavenge, but the tombstone event remains. Warning A hard delete of a stream is permanent. You cannot write to the stream or recreate it. As such, you should generally soft delete streams unless you have a specific need to permanently delete the stream. Deleted events and projections If you are intending on using projections and deleting streams, there are some things to take into consideration: Due to the nature of $all , projections using fromAll read any deleted events that have not been scavenged. They also receive any tombstone events from hard deletes. Projections that read from a specific stream receive that stream's metadata events. You can filter these out by ignoring events with an event type $metadata ."
  },
  "reference/reliability/index.html": {
    "href": "reference/reliability/index.html",
    "title": "Reliability | Event Store",
    "keywords": "Reliability You should look at reliability from a holistic perspective. Event Store treats data transactionally with full durability assurances, but this doesn't help you if the hardware on your machine does not support it. Many consumer grade disks (and SSDs especially) lie about durability to appear faster. This is fine until you have a power outage and lose information. These issues do not just affect Event Store. Other vendors and projects have created tests to check whether you may be losing data. We recommend running one of these tests against your production environment. You can check the state of your drives on Linux by using the following command: sudo hdparm -I {drive} For example, check /dev/sda to see if caching is enabled on your drive. Be wary though, just because caching is disabled does not mean that all writes are fully durable. If you are running Linux you might want to consider adding the following to /etc/hdparm.conf : /dev/yourdrive { write_cache = off } If you are running the clustered version of Event Store you may wish to allow these unlikely events to happen. The drives run faster with caching enabled and it's unlikely that you would lose three machines at the same time with corruption. If this were to happen you can truncate your data and re-replicate from the other nodes."
  },
  "reference/internal-architectural-overview/index.html": {
    "href": "reference/internal-architectural-overview/index.html",
    "title": "Internal architectural overview | Event Store",
    "keywords": "Internal architectural overview <!-- TODO: Overview image or intro? --> Messaging The architecture style of Event Store is SEDA (Staged Event Driven Architecture) . Messages flow forward through queues internally, including the transaction file, which is also a queue. There are communication endpoints that flow forward through series of queues to be processed. All operations are purely asynchronous. The core processing runs on a single thread reading requests off of a single concurrent queue. Messages first flow through a state machine that represents the state of the node. In a distributed scenario a node is not always allowed to write (slaves forward writes, not write themselves), or if the node is still initializing its not allowed to read. Each request is handled by a state machine that manages the lifecycle of that request including time outs and acknowledgements throughout the cluster. Because of this architecture, the main monitoring points of Event Store is the status of the queues. You can view the status in the health area of the admin interface or through the HTTP API. It's also periodically written to a special $statistics-node:port stream. <!-- TODO: Which endpoint --> <!-- TODO: IMAGE(s)--> The most common queue to be slow is the storage writer as it writes to storage in a durable fashion. It uses fsync and flushfile buffers to ensure that data is persisted to disk and survives, say, a power outage on the machine. The storage writer is capable of writing more than 15,000 transactions to disk per second on the open source single node version. Transaction file Event Store provides durable storage including handling cases where the power may be turned off to a machine through the use of a commit log. The commit log is a conceptual constantly appending file (though it is not implemented this way <!-- TODO: This is confusing, link to more details? --> ). Every write to Event Store appends to this file. The commit log is built not as one large file but as a series of small files implemented with an abstraction called a 'TFChunk'. For all files it writes, Event Store always writes sequentially, except for checkpoints, although there is a non-performing sequential version of checkpoints. This results in seeks not being necessary for writes. While less of a problem with SSDs, this can drastically help with performance of spindle drives. It also allows for the possibility to store data for Event Store (both indexes and the transaction file) on write once media. Entire TFChunks are cached by loading the entire chunk into unmanaged memory. Most of the memory usage by Event Store is unmanaged. It's rare to see it use more than a few hundred megabytes in managed heaps. Even in these scenarios most of the memory is in the large object heap (LOH) and point to native types such as byte[] to put a minimum load possible on the garbage collector. Scavenging The chunks in the transaction file are periodically scavenged to remove deleted or old data, and depending on stream rules such as $maxCount in the stream metadata, can be compacted. This process generates new chunks and switches them out atomically, deleting them once they are no longer in use by readers. This gives the benefit that, once completed, TFChunks are immutable. This includes the current chunk. Since it's only written to sequentially it never seeks back to overwrite something. Every record in the log has an ID. The ID is the logical position at which the record was originally written to disk. This is useful as an identifier, as in a scenario where you are not deleting you know exactly where the record is stored. When you begin scavenging this location can move. As part of the process of scavenging a TFChunk, a map is written of remappings from the original IDs. This is crucial because index points back to these IDs. This map allows the index and the TFChunks to be scavenged independently. If, during the scavenge process, the overhead of the map outweighs the benefit of the scavenge the scavenge is not performed. Chunks that are completed also have an MD5 checksum to validate the data inside of them since disks do occasionally go bad or mangle data. This checksum is checked periodically to validate that the data is not corrupted. Index Event Store only has one index. You should use projections for building application level indexes. The index is immutable. Queries executed against Event Store are always to get an event represented as a sequence number inside of a stream. The index is optimized for this purpose. Each record in the index is 16 bytes: 4 bytes for the hash of the stream ID. 4 bytes for the sequence number. 8 bytes for the original position the record had in the log. This identifier of a record is useful as you can avoid additional lookups when writing the record to disk, this can change due to scavenging of the transaction file. As transactions are written to the transaction file, where an in-memory index is appended. A query hits the in memory index. The in-memory index is implemented as a hash of sorted lists with a fine grained lock on the stream. When there are enough items in the in-memory index, the index is flushed to disk (known as a 'PTable' or 'Persistent Table'). A PTable is a sorted group of index entries (remember that they are only 16 bytes each). A binary search across the PTables is used to search. The search function has been memoized by storing midpoints in memory. Mid point caching reduces the number of seeks from log(n) by the depth to which midpoints are filled and often all are in memory. Index rebuilds You can copy indexes from machine to machine providing the data structure is the same. This guide explains how the index rebuild process works when you add new nodes to a cluster, or backup and restore an index. TFiles make up a transaction log, but conceptually they are one continuous file. Event Store breaks them up into many files instead of one big file for operational reasons such as incremental back ups. This mechanism also tends to play better with the filesystem. Rebuilding an index requires starting from position 0 in this large continuous file and then moving forward indexing every item one at a time. Rebuilds on a new node When Event Store starts on a blank machine there are no persistent indexes, there is only a memtable (in memory index). There is a limit to how many items the memory index can store (1 million). When an index hits this number, the index is then moved to a disk based format known as a PTable. Event Store stores what the position was in the TFile for what the PTable represents. In a single index file example it may be 0,12345678 meaning the index covers all transactions between positions 0 and 12345678 . When Event Store loads the index, it calculates the position that the persistent index covers, in this example, 12345678 . After loading the index, Event Store then knows that the index covers all events before positions 12345678 , and does not need to take them into account. Event Store then rebuilds the memory index from position 12345678 up to the current, which you can see in log output when Event Store starts. PTables get merged into larger PTables over time. During this operation they are scavenged for items to be removed. The merging of N PTables to one larger PTable is a linear operation as they are all sorted. Once written to disk, PTables are immutable and have like TFchunks MD5 checksums. Unlike a failure in a TFChunk checksum, if a problem is found within the index it is simply rebuilt. Backup and restore When it comes to restoring Event Store from a backup, Event Store loads the persistent indexes, and finds out the highest logical position covered in the index. Event Store then creates a memtable from that point forward, this process is asynchronous and does not hold up start up."
  },
  "http-api/optional-http-headers/expected-version/index.html": {
    "href": "http-api/optional-http-headers/expected-version/index.html",
    "title": "Optional HTTP Headers: Expected Version | Event Store",
    "keywords": "Optional HTTP Headers: Expected Version When you write to a stream you often want to use Expected Version to allow for optimistic concurrency with a stream. You commonly use this for a domain object projection. i.e., \"A write can succeed if I have seen everyone else's writes.\" You set ExpectedVersion with the syntax ES-ExpectedVersion: # , where # is an integer version number. There are other special values available: 0 , the stream should exist but be empty when writing. -1 , the stream should not exist when writing. -2 , the write should not conflict with anything and should always succeed. -4 , the stream or a metadata stream should exist when writing. If the ExpectedVersion does not match the version of the stream, Event Store returns an HTTP 400 Wrong expected EventNumber response. This response contains the current version of the stream in an ES-CurrentVersion header. In the following cURL command ExpectedVersion is not set, and it appends or create/append to the stream. Request Response curl -i -d \"@event.json\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/json\" -H \"ES-EventType: SomeEvent\" -H \"ES-EventId: C322E299-CB73-4B47-97C5-5054F920746E\" HTTP/1.1 201 Created Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER Access-Control-Allow-Origin: * Location: http://127.0.0.1:2113/streams/newstream/0 Content-Type: text/plain; charset: utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 28 Jun 2013 12:17:59 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 The stream 'newstream' has one event. If you append with an expected version of '3', you receive an error. Request Response curl -i -d @event-version.json \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/vnd.eventstore.events+json\" -H \"ES-ExpectedVersion: 3\" HTTP/1.1 400 Wrong expected EventNumber Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion ES-CurrentVersion: 0 Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Tue, 14 Aug 2018 14:08:44 GMT Content-Length: 0 Connection: close You can see from the ES-CurrentVersion header above that the stream is at version 0. Appending with an expected version of 0 works. The expected version is always the version of the last event known in the stream. Request Response curl -i -d @event-version.json \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/vnd.eventstore.events+json\" -H \"ES-CurrentVersion: 0\" HTTP/1.1 201 Created Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Location: http://127.0.0.1:2113/streams/newstream/2 Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Tue, 14 Aug 2018 10:02:08 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100"
  },
  "http-api/optional-http-headers/eventtype/index.html": {
    "href": "http-api/optional-http-headers/eventtype/index.html",
    "title": "Optional HTTP Headers: EventType | Event Store",
    "keywords": "Optional HTTP Headers: EventType When you write to a stream and don't the application/vnd.eventstore.events+json/+xml media type you must specify an event type with the event that you are posting. This isn't required with the custom media type as it's specified within the format itself. You use the ES-EventType header as follows. Request Response curl -i -d \"@event.json\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/json\" -H \"ES-EventType: SomeEvent\" -H \"ES-EventId: C322E299-CB73-4B47-97C5-5054F920746E\" HTTP/1.1 201 Created Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER Access-Control-Allow-Origin: * Location: http://127.0.0.1:2113/streams/newstream/0 Content-Type: text/plain; charset: utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 28 Jun 2013 12:17:59 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 If you view the event in the UI or with cURL it has the EventType of SomeEvent : <!-- TODO: Does this make sense? If I can't use the custom medi type --> Request Response curl -i http://127.0.0.1:2113/streams/newstream/0 -H \"accept:application/vnd.eventstore.atom+json\" { \"title\": \"0@newstream\", \"id\": \"http://127.0.0.1:2113/streams/newstream/0\", \"updated\": \"2018-08-27T08:27:58.986756Z\", \"author\": { \"name\": \"EventStore\" }, \"summary\": \"SomeEvent\", \"content\": { \"eventStreamId\": \"newstream\", \"eventNumber\": 0, \"eventType\": \"SomeEvent\", \"eventId\": \"c322e299-cb73-4b47-97c5-5054f920746e\", \"data\": { \"a\": \"1\" }, \"metadata\": \"\" }, \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream/0\", \"relation\": \"edit\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/0\", \"relation\": \"alternate\" } ] }"
  },
  "server/deploy-kubernetes-gke/index.html": {
    "href": "server/deploy-kubernetes-gke/index.html",
    "title": "Deploy with Kubernetes to Google Cloud GKE | Event Store",
    "keywords": "Deploy with Kubernetes to Google Cloud GKE This guide is to show how to use the official Event Store Helm Chart to interactively deploy an Event Store Cluster in Kubernetes Google Cloud GKE service. Prerequisites Install the following utilities in your development machine. Kubectl Helm Google Cloud SDK Configuration steps Login in your Google Cloud account using the gcloud cli, this prompts you to login using any browser and copy/paste a key back in to the cli: gcloud auth login --no-launch-browser Set the region , and the project id from above: gcloud config set compute/region <regionname> gcloud config set project <projectid> Enable the Kubernetes Engine API for your project, by visiting the https://console.cloud.google.com/apis/library/container.googleapis.com?project={project-id} page. Create a Kubernetes Cluster in your account, the following command does not specify the number of nodes and uses the default of 3:. gcloud container clusters create <clustername> --zone <zonename> We recommend kubectl for managing resources in the Kubernetes cluster. Set the current context for kubectl and merge it with any existing configuration in your existing config file: gcloud beta container clusters get-credentials <clustername> --zone <zonename> --project <projectid> On the server side Helm relies on a service account called Tiller, and you need to configure this account for Role Base Access as Google Cloud GKE enables it by default. To configure RBAC follow these instructions . In Summary you need to create a special deployment with the Tiller user settings before running the helm init command. You can then check if the 'tiller-deploy-xxxx' pod is running kubectl -n kube-system get pod Deploy Event Store cluster with Helm It is possible to specify a lot of options to customise your Event Store deployment. The setting used in this guide is \"Persistent Volume\", that allows you to deploy a Persistent Volume Claim . This Claim is an abstraction that requires Kubernetes to set up one persistent volume per each Event Store node and assign an id to it. These volumes are then reused by the cluster, for example, we want to upgrade the version of the Cluster and retain the data. If we dont specify an existing volume then the volumes are dynamically created. helm repo add eventstore <https://eventstore.github.io/EventStore.Charts> helm repo update helm install -n eventstore eventstore/eventstore --set persistence.enabled=true Google Cloud GKE sets the authentication to use RBAC by default. Because of this, to reach your Event Store cluster you have to set up access for anonymous users. This is something you would only do for a test environment using the following command: kubectl create clusterrolebinding cluster-system-anonymous --clusterrole=cluster-admin --user=system:anonymous Upgrade the cluster with a newer version Verify your current Event Store cluster: helm status eventstore Fork the official Helm Chart Event Store repository and change the version of the image in the chart values.yaml . And run the command in the same directory as the chart: helm upgrade eventstore . --set persistence.enabled=true The upgrade command upgrades all the pods one by one without downtime and attaches the existing volumes to the new pods during the upgrade. Rollback to a previous version To rollback the upgrade, first use the following command to display the history: helm history eventstore And then the following command to rollback to a specific revision: helm rollback eventstore 1 Delete resources gcloud container clusters delete <clustername> --zone <zonename> Then login in to the Google Cloud Web UI, and in the Kubernetes Engine view delete the Kubernetes Cluster using the bin icon."
  },
  "server/deploy-kubernetes-aks/index.html": {
    "href": "server/deploy-kubernetes-aks/index.html",
    "title": "Deploy with Kubernetes to Azure Cloud AKS | Event Store",
    "keywords": "Deploy with Kubernetes to Azure Cloud AKS This guide is to show how to use the official Event Store Helm Chart to interactively deploy an Event Store Cluster in Kubernetes Azure Cloud AKS service. Prerequisites Install the following utilities in your development machine. Kubectl Helm The Azure CLI Configuration steps Login in your Azure Cloud account using the az cli, this triggers 2 factor authentication that launches your default browser to select account credentials. az login Create a new resource group: az group create -n {resourcegroupname} -l {location-compatible-with-aks} Create a Kubernetes cluster with 3 nodes. This command accept parameters such as the version of Kubernetes you want installed. For this tutorial we use the default options. az aks create -n {clustername} -g {resourcegroupname} -c 3 The command (after some delay) returns a JSON object with details of the new Kubernetes cluster. Use the command below to return a list of all Kubernetes clusters in your Azure account: az aks list -o table We recommend kubectl for managing resources in the Kubernetes cluster. Set the current context for kubectl and merge it with any existing configuration in your existing config file: az aks get-credentials -n {clustername} -g {groupname} Get the list of nodes using kubectl: kubectl get nodes To use the Kubernetes dashboard you need to change the Role Base Access Control enabled by default on Azure AKS. Create a rbac-config.yaml file containing the following yaml: apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: name: kubernetes-dashboard labels: k8s-app: kubernetes-dashboard roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: kubernetes-dashboard namespace: kube-system Create a deployment for this ClusterRoleBinding object kubectl create -f ./rbac-config.yaml To access the dashboard you can now use the browse command. This command is a wrapper around the proxy command of kubectl. It creates a local web server with a tunnel to the cluster hosted in Azure AKS web server az aks browse -n {clustername} -g {groupname} Deploy Event Store cluster with Helm Helm is the package manager for Kubernetes. After you've created a new Kubernetes cluster you need to configure Helm for your local helm CLI to connect to a configured service account on the server side. The service account used by Helm is called Tiller. Give Tiller access to the cluster and initialise it with the following commands: kubectl -n kube-system create serviceaccount tiller kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller helm init --service-account tiller You can then check if the tiller-deploy-xxxx pod is running kubectl -n kube-system get pod Now deploy the Event Store cluster using the official Helm Chart with the following commands: helm repo add eventstore https://eventstore.github.io/EventStore.Charts helm repo update helm install -n eventstore eventstore/eventstore --set persistence.enabled=true The Event Store cluster is now deployed and available in a couple of minutes. The default cluster size in the Helm Chart is set to 3 so this results in a 3 node Event Store cluster over the 3 nodes Kubernetes cluster. The setting persistence.enable=true uses a PersistentVolumeClaim on your Kubernetes cluster to claim dynamically persistent storage volumes. You can configure this to use statically defined volumes if required. Upgrade the Event Store cluster with a newer version Verify your current Event Store cluster helm status eventstore Fork the official Helm Chart Event Store repository and change the version of the image in the chart values.yaml . Then run the command in the same directory as the chart: helm upgrade eventstore . --set persistence.enabled=true The upgrade command silently upgrades all the pods one by one without downtime. Helm takes care of attaching the existing volumes to the new pods during the upgrade. Rollback to a previous version To rollback to a previous version, first use the following command to display the history helm history eventstore And the following command to rollback to a specific revision helm rollback eventstore 1 Delete resources To delete all resources associated with the EventStore installation use the following command: az aks delete -n {clustername} -g {groupname} az group delete -n {groupname}"
  },
  "server/cluster-without-manager-nodes/index.html": {
    "href": "server/cluster-without-manager-nodes/index.html",
    "title": "Setting up a cluster using only database nodes (OSS) | Event Store",
    "keywords": "Setting up a cluster using only database nodes (OSS) <!-- TODO: Needs Linux instructions --> High availability Event Store allows you to run more than one node as a cluster. There are two modes available for clustering: With database nodes only (open source and commercial) With manager nodes and database nodes (commercial only) This document covers setting up Event Store with only database nodes. Tip When setting up a cluster, you generally want an odd number of nodes as Event Store uses a quorum based algorithm to handle high availability. We recommended you define an odd number of nodes to avoid split brain problems. Common values for the ClusterSize setting are three or five (to have a majority of two nodes and a majority of three nodes). Next Steps Read here for more information on the roles available for nodes in an Event Store cluster. Running on the same machine To start, set up three nodes running on a single machine. Run each of the commands below in its own console window. You either need admin privileges or have ACLs setup with IIS if running under Windows. Unix-like operating systems need no configuration. Replace \"127.0.0.1\" with whatever IP address you want to run on. EventStore.ClusterNode.exe --mem-db --log .\\logs\\log1 --int-ip 127.0.0.1 --ext-ip 127.0.0.1 --int-tcp-port=1111 --ext-tcp-port=1112 --int-http-port=1113 --ext-http-port=1114 --cluster-size=3 --discover-via-dns=false --gossip-seed=127.0.0.1:2113,127.0.0.1:3113 EventStore.ClusterNode.exe --mem-db --log .\\logs\\log2 --int-ip 127.0.0.1 --ext-ip 127.0.0.1 --int-tcp-port=2111 --ext-tcp-port=2112 --int-http-port=2113 --ext-http-port=2114 --cluster-size=3 --discover-via-dns=false --gossip-seed=127.0.0.1:1113,127.0.0.1:3113 EventStore.ClusterNode.exe --mem-db --log .\\logs\\log3 --int-ip 127.0.0.1 --ext-ip 127.0.0.1 --int-tcp-port=3111 --ext-tcp-port=3112 --int-http-port=3113 --ext-http-port=3114 --cluster-size=3 --discover-via-dns=false --gossip-seed=127.0.0.1:1113,127.0.0.1:2113 You should now have three nodes running together in a cluster. If you kill one of the nodes, it continues running. This binds to the loopback interface. To access Event Store from outside your machine, specify a different IP address for the --ext-ip parameter. Running on separate machines Most important is to understand the \"gossip seeds\". You are instructing seed locations for when the node first starts and needs to begin gossiping. Any node can be a seed. By giving each node the other nodes you ensure that there is always another node to gossip with, if a quorum can be built. If you want to move this to run on three machines, change the IPs on the command line to something like this: EventStore.ClusterNode.exe --mem-db --log c:\\dbs\\cluster\\log1 --int-ip 192.168.0.1 --ext-ip 192.168.0.1 --int-tcp-port=1111 --ext-tcp-port=1112 --int-http-port=2113 --ext-http-port=2114 --cluster-size=3 --discover-via-dns=false --gossip-seed=192.168.0.2:2113,192.168.0.3:2113 EventStore.ClusterNode.exe --mem-db --log c:\\dbs\\cluster\\log2 --int-ip 192.168.0.2 --ext-ip 192.168.0.2 --int-tcp-port=1111 --ext-tcp-port=1112 --int-http-port=2113 --ext-http-port=2114 --cluster-size=3 --discover-via-dns=false --gossip-seed=192.168.0.1:2113,192.168.0.3:2113 EventStore.ClusterNode.exe --mem-db --log c:\\dbs\\cluster\\log3 --int-ip 192.168.0.3 --ext-ip 192.168.0.3 --int-tcp-port=1111 --ext-tcp-port=1112 --int-http-port=2113 --ext-http-port=2114 --cluster-size=3 --discover-via-dns=false --gossip-seed=192.168.0.1:2113,192.168.0.2:2113 Using DNS Entering the commands above into each node is tedious and error-prone (especially as the replica set counts change). Another configuration option is to create a DNS entry that points to all the nodes in the cluster and then specify that DNS entry with the appropriate port: EventStore.ClusterNode.exe --log c:\\dbs\\cluster\\log1 --int-ip 192.168.0.1 --ext-ip 192.168.0.1 --int-tcp-port=1111 --ext-tcp-port=1112 --int-http-port=2113 --ext-http-port=2114 --cluster-size=3 --cluster-dns mydomain.com --cluster-gossip-port=2113 EventStore.ClusterNode.exe --mem-db --log c:\\dbs\\cluster\\log2 --int-ip 192.168.0.2 --ext-ip 192.168.0.2 --int-tcp-port=1111 --ext-tcp-port=1112 --int-http-port=2113 --ext-http-port=2114 --cluster-size=3 --cluster-dns mydomain.com --cluster-gossip-port=2113 EventStore.ClusterNode.exe --mem-db --log c:\\dbs\\cluster\\log3 --int-ip 192.168.0.3 --ext-ip 192.168.0.3 --int-tcp-port=1111 --ext-tcp-port=1112 --int-http-port=2113 --ext-http-port=2114 --cluster-size=3 --cluster-dns mydomain.com --cluster-gossip-port=2113 Note You can also use the method above for HTTP clients to avoid using a load balancer and fall back to round robin DNS for many deployments. Internal vs. external networks You can optionally segregate all Event Store communications to different networks. For example, internal networks for tasks like replication, and external networks for communication between clients. You can place these communications on segregated networks which is often a good idea for both performance and security purposes. To setup an internal network, use the command line parameters provided above, but prefixed with int- . All communications channels also support enabling SSL for the connections. HTTP clients If you want to use the HTTP API, then you should add a load balancer in front of the three nodes. It does not matter which node receives a request as the requests the node are forwarded to the request internally. With this setup, you can lose any one machine with no data loss. Native TCP clients You can connect to the cluster using the native TCP interface. The client APIs support switching between nodes internally. As such if you have a master failover the connection automatically handle retries on another node. To set up a connection as above, provide gossip seeds to the connection. The client then uses the gossip seeds to begin gossiping information about the cluster. EventStoreConnection.Create( ConnectionSettings.Create().KeepReconnecting(), ClusterSettings.Create() .WithGossipTimeoutOf(TimeSpan.FromMilliseconds(500)) .WithGossipSeeds(new [] { new IPEndPoint(IPAddress.Parse(\"192.168.0.1\"), 2113), new IPEndPoint(IPAddress.Parse(\"192.168.0.2\"), 2113), new IPEndPoint(IPAddress.Parse(\"192.168.0.3\"), 2113) })); As in the example above, you can also use DNS to avoid manually specifying the seeds. You add the nodes to a DNS record and then specify that DNS entry to the connection to locate nodes. EventStoreConnection.Create(ConnectionSettings.Create() .KeepReconnecting(), ClusterSettings.Create() .SetClusterDns(\"mycluster.com\")) .SetGossipPort(2113) The connection automatically reconnects during node failures. You can control this behaviour with options on the ConnectionSettings such as limiting retry attempts or frequency. The connection and durable subscription even manage a subscription during node failures, you will not receive duplicated messages over your durable subscription. Tip For those using the closed source version of Event Store GossipPort is an alias for ManagerPort as the closed source version includes a node manager on each physical node. This allows for controlling many virtual nodes on a machine with easy configuration. The manager also acts as a supervisor for the nodes."
  },
  "server/cluster-with-manager-nodes/index.html": {
    "href": "server/cluster-with-manager-nodes/index.html",
    "title": "Setting up a cluster with manager nodes | Event Store",
    "keywords": "Setting up a cluster with manager nodes <!-- TODO: How much of this is also relevant to OSS? --> High availability Event Store allows you to run more than one node as a cluster. There are two modes available for clustering: With database nodes only (open source and commercial) With manager nodes and database nodes (commercial only) This document covers setting up Event Store with manager nodes and database nodes. Tip When setting up a cluster, you generally want an odd number of nodes as Event Store uses a quorum based algorithm to handle high availability. We recommended you define an odd number of nodes to avoid split brain problems. Common values for the ClusterSize setting are three or five (to have a majority of two nodes and a majority of three nodes). Next Steps Read here for more information on the roles available for nodes in an Event Store cluster. Manager nodes Each physical (or virtual) machine in an Event Store cluster typically runs one manager node and one database node. It's also possible to have multiple database nodes per physical machine, running under one manager node. Manager nodes have a number of responsibilities: They are responsible for starting the database nodes and supervising them to ensure they rest in case of a crash or termination owing to abnormal circumstances. Event Store calls this the watchdog service. They communicate with other manager nodes to find cluster state, and relay that information to the database nodes under management. They provide a known endpoint for clients to connect to and discover cluster information. When running on Windows, manager nodes run as Windows services. Configuring nodes Each database or manager node can have a variety of configuration sources . Each source has a priority and determines running configuration by evaluating each source and applying the option from the source with the highest priority. From lowest to highest priority, the sources of configuration are: Default settings. Settings specified in a configuration file written using YAML. Settings specified in environment variables. Settings specified as command line options to the node. You can check the configuration of a node by passing the -WhatIf flag to the process. Typical deployment topologies Event Store clusters follow a \"shared nothing\" philosophy, meaning that clustering requires no shared disks for clustering to work. Instead, several database nodes store your data to ensure it isn't lost in case of a drive failure or a node crashing. Event Store uses a quorum-based replication model, in which a majority of nodes in the cluster must acknowledge that they committed a write to disk before acknowledging the write to the client. This means that to be able to tolerate the failure of n nodes, the cluster must be of size (2n + 1) . A three-database-node cluster can continue to accept writes if one node is unavailable. A five-database-node cluster can continue to accept writes if two nodes are unavailable, and so forth. A typical deployment topology consists of three physical machines, each running one manager node and one database node. Each of the physical machines may have two network interfaces, one for communicating with other cluster members, and one for serving clients. Although it may be preferable in some situations to run over two separate networks. It's also possible to use different TCP ports on one interface. Cluster gossip Event Store uses a quorum-based replication model. When working normally, a cluster has one database node known as a master, and the remaining nodes are slaves. The master node is responsible for coordinating writes while it is the master. Database nodes use a consensus algorithm to determine which database node should be master and which should be slaves. Event Store bases the decision as to which node should be the master on a number of factors ( some of which are configurable ). For database nodes to have this information available to them, the nodes gossip with other nodes in the cluster. Gossip runs over the internal (and optionally the external) HTTP interfaces of database nodes, and over both internal and external interfaces of manager nodes. Discovering cluster members Manager and database nodes need to know about one another to gossip. To start this process, you provide gossip seeds or the addresses where it can find other nodes, to each node. When running with manager nodes, it normally uses the following approach: On each physical machine, configure the database node(s) with a gossip seed of the internal HTTP interface of the manager running on the same physical machine. Configure the managers to discover other managers in one of two ways: via a DNS entry and a well-known gossip port. via a list of other managers' addresses. The preferred method is via a DNS entry. To set this up, create a DNS entry for the cluster with an A record pointing to each member of the cluster. Each manager looks up other nodes in the cluster during the startup process based on the DNS name. Since DNS only provides information about addresses, you need to use a consistent TCP port across the cluster for gossip. <!-- TODO: Should this be more practical? --> Example 1 - a three-machine cluster This example shows the configuration for a three node cluster, running in the typical setup of one manager node and one database node per physical machine, with cluster discovery via DNS. Each machine has one network interface, therefore uses different ports for the internal and external traffic. All nodes, in this case, are running Windows, so the manager nodes run as Windows services. The important points for writing configuration files are: Node IP Addresses: 192.168.1.11, 192.168.1.12 and 192.168.13 TCP ports: (defaults): Manager Nodes: Internal HTTP: 30777 External HTTP: 30778 Database Nodes: Internal TCP: 1112 External TCP: 1113 Internal HTTP: 2112 External HTTP: 2113 DNS Entry Name: cluster1.eventstore.local To configure the cluster correctly, there are a number of steps to follow: Set up a DNS entry named cluster1.eventstore.local with an A record for each node. Write the database node configuration file for each machine. Write the manager node configuration file for each machine. Write the watchdog configuration file for each machine. Deploy Event Store and the configuration files to each machine. ( Windows-specific ) Add HTTP URL ACL entries to allow starting HTTP servers on the required HTTP ports. ( Windows-specific ) Install the manager as a service and start the service. ( Linux-specific ) Configure the manager as a daemon. DNS entry It depends on which DNS server you use, but the eventual lookup should read: $ nslookup cluster1.eventstore.local Server: 192.168.1.2 Address: 192.168.1.2#53 Name: cluster.eventstore.local Address: 192.168.1.11 Name: cluster.eventstore.local Address: 192.168.1.12 Name: cluster.eventstore.local Address: 192.168.1.13 Database node configuration All three nodes are similar in configuration. The important configuration points are the: IP Addresses for internal and external interfaces. The ports for each endpoint. The location of the database file. The size of the cluster The endpoints from which to seed gossip (in this case the local manager). We assume that Event Store stores data on the _D:_ drive. You write the configuration files in YAML, and is the following for the first node: Filename: database.yaml Db: d:\\es-data IntIp: 192.168.1.11 ExtIp: 192.168.1.11 IntTcpPort: 1112 IntHttpPort: 2112 ExtTcpPort: 1113 ExtHttpPort: 2113 DiscoverViaDns: false GossipSeed: ['192.168.1.11:30777'] ClusterSize: 3 For each following node, the IP Addresses change, as does the gossip seed, since it is the manager running on the same physical machine as each node. Manager configuration Again, all three nodes are similar in configuration. The important configuration points are the: IP addresses for the internal and external interfaces. The ports for the HTTP endpoints. The log location. The DNS information about other nodes. Another important configuration item is which database nodes the manager is responsible for starting. You define this in a separate file (the watchdog configuration), the path to which you specify as WatchdogConfig in the manager configuration. You write the configuration files in YAML, and is the following for the first node: Filename: manager.yaml IntIp: 192.168.1.11 ExtIp: 192.168.1.11 IntHttpPort: 30777 ExtHttpPort: 30778 DiscoverViaDns: true ClusterDns: cluster1.eventstore.local ClusterGossipPort: 30777 EnableWatchdog: true WatchdogConfig: c:\\EventStore-Config\\watchdog.esconfig Log: d:\\manager-log Watchdog configuration The watchdog configuration file details which database nodes the manager is responsible for starting and supervising. Unlike the other configuration files, the manager configuration uses a custom format instead of YAML. Each node for which the manager is responsible has one line in the file, which starts with a # symbol and then details the command line options given to the database node when it starts it. Under normal circumstances, this is the path to the database node's configuration file. For the first node in the example cluster, the watchdog configuration file reads as follows: # --config c:\\EventStore-Config\\database.yaml Deploying Event Store software and configuration With configuration files for each node written, you can now deploy Event Store and the configuration. Although it's possible to use relative paths when writing configuration files, it's preferable to use absolute paths to reduce the potential for confusion. In this example, Event Store is deployed on each node in _c:\\EventStore-HA-v_, and the configuration files for that node are deployed into _C:\\EventStore-Config_. No installation process is necessary, you unzip the packaged distribution into your preferred location. Adding HTTP ACL entries for HTTP servers (Windows-specific) <!-- TODO: Check this --> To allow for non-elevated users to run HTTP servers on Windows, you must add entries to the access control list using netsh . By default, the manager node runs as NT AUTHORITY\\Local Service , so this is the user who must have permission to run the HTTP server. The commands used to add these entries on node one are as follows (Run as an elevated user): # Database Node Internal HTTP Interface netsh http add urlacl url=http://192.168.1.11:2112/ user=\"NT AUTHORITY\\LOCAL SERVICE\" # Database Node External HTTP Interface netsh http add urlacl url=http://192.168.1.11:2113/ user=\"NT AUTHORITY\\LOCAL SERVICE\" # Manager Node Internal HTTP Interface netsh http add urlacl url=http://192.168.1.11:30777/ user=\"NT AUTHORITY\\LOCAL SERVICE\" # Manager Node External HTTP Interface netsh http add urlacl url=http://192.168.1.11:30778/ user=\"NT AUTHORITY\\LOCAL SERVICE\" Configure the manager node as a service (Windows-specific) You can install manager nodes as a Windows service so they can start on boot rather than running in interactive mode. Each manager service is given an instance name, which becomes the name of the service (and part of the description for easy identification). The service is installed by default with a startup type of \"Automatic (Delayed Start)\". Installing the service To install the manager node on machine 1, use the following command: C:\\EventStore-HA-v\\> EventStore.WindowsManager.exe install -InstanceName es-cluster1 -ManagerConfig C:\\EventStore-Config\\manager.yaml The service is then visible in the services list, with a description of \"Event Store Manager (es-cluster1)\". Uninstalling the service To uninstall the manager node service, use the following command (where the instance name matches the name used during installation). C:\\EventStore-HA-v\\> EventStore.WindowsManager.exe uninstall -InstanceName es-cluster1 Manually starting and stopping the service To start the manager node use the net start es-cluster1 command. To stop the manager node use the net stop es-cluster1 command."
  },
  "server/caching/index.html": {
    "href": "server/caching/index.html",
    "title": "Caching | Event Store",
    "keywords": "Caching As there are large differences between running Event Store in development and production, it's important to understand how caching works. Most of the URIs that Event Store emits are immutable (including the UI and Atom Feeds). An Atom feed has a URI that represents an event, e.g., /streams/foo/0 , representing 'event 0'. The data for event 0 never changes. If this stream is open to public reads then the URI is set to be 'cachable' for long periods of time. You can see a similar example in reading a feed. If a stream has 50 events in it, the feed page 20/forward/10 never changes, it will always be events 20-30. Internally Event Store controls serving the right URIs by using rel links with feeds (for example prev / next ). This caching behaviour is great for performance in a production environment and we recommended you use it, but in a developer environment it can become confusing. For example, what happens if you started a database, wrote /streams/foo/0 and performed a GET request? The GET request is cachable and now in your cache. Since this is a development environment, you shutdown Event Store and delete the database. You then restart Event Store and write a different event to /streams/foo/0 . You open your browser and inspect the /streams/foo/0 stream, and you see the event written before you deleted the database. To avoid this during development it's best to run Event Store with the --disable-http-caching command line option. This disables all caching and solve the issue."
  },
  "server/configuring/index.html": {
    "href": "server/configuring/index.html",
    "title": "Configuring your Event Store installation | Event Store",
    "keywords": "Configuring your Event Store installation <!-- I envisage this file growing. Possibly some material from other server docs could be moved here (there's an issue out there about tidying up this section) and I imagine other config questions may come up in future --> Linux Start Event Store as a service on a custom port Follow the instructions in Getting started to install an Event Store package. Do not start Event Store. Find your inet address. For example: #Retrieve your IP address ifconfig #Output eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192.168.1.68 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::d12:27b9:96c2:c00e prefixlen 64 scopeid 0xfd<compat,link,site,host> Edit your Event Store config: #Open the file sudo nano /etc/eventstore/eventstore.conf #Add the following extIp: <your inet address> ExtHttpPort: 80 ExtHttpPrefixes: http://*:80/ AddInterfacePrefixes: false Allow the Event Store executable to bind to a port lower than 1024: sudo setcap CAP_NET_BIND_SERVICE=+eip /usr/bin/eventstored Start the Event Store service as normal: sudo systemctl start eventstore"
  },
  "server/64-bit-index/index.html": {
    "href": "server/64-bit-index/index.html",
    "title": "Rebuilding indexes | Event Store",
    "keywords": "Rebuilding indexes As of version 3.9.0 all future indexes use 64-bit hashes instead of 32-bit hashes. Event Store automatically transitions your indexes from 32-bit to 64-bit by writing all new indexes as 64-bit indexes during the merge process. If you prefer to use only 64-bit indexes immediately you can force this change. For a small database, delete the index folder in your database folder, and let it rebuild (this might take a while) If you have a large database, or it's stored in remote storage, and you can't lose downtime, you can run this operation offline on another node with the following steps: Take a back up . Restore the backup to fast local disks. Delete the index folder from back up. Run Event Store with a cluster size 3 to prevent other writes. It will rebuild the index. Restore the index back to a node ( index folder). Let Event Store catch up from master. Repeat the restore for other nodes. For other indices, your index will change to 64-bit due to the merging process that occurs over time."
  },
  "http-api/swagger.html": {
    "href": "http-api/swagger.html",
    "title": "HTTP API | Event Store",
    "keywords": "HTTP API"
  },
  "http-api/swagger/Shutdown a node.html": {
    "href": "http-api/swagger/Shutdown a node.html",
    "title": "Shutdown a node | Event Store",
    "keywords": "Shutdown a node Issues a shut down command to a node. Request POST /admin/shutdown Responses Status Code Description Samples 200 OK"
  },
  "dotnet-api/code/EventStore.ClientAPI.EventStoreSubscription.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.EventStoreSubscription.html",
    "title": "Class EventStoreSubscription | Event Store",
    "keywords": "Class EventStoreSubscription Represents a subscription to a single stream or to the stream of all events in the Event Store. Inheritance System.Object EventStoreSubscription Implements System.IDisposable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public abstract class EventStoreSubscription : IDisposable Fields LastCommitPosition The last commit position seen on the subscription (if this is a subscription to all events). Declaration public readonly long LastCommitPosition Field Value Type System.Int64 LastEventNumber The last event number seen on the subscription (if this is a subscription to a single stream). Declaration public readonly long? LastEventNumber Field Value Type System.Nullable < System.Int64 > Properties IsSubscribedToAll True if this subscription is to all streams. Declaration public bool IsSubscribedToAll { get; } Property Value Type System.Boolean StreamId The name of the stream to which the subscription is subscribed. Declaration public string StreamId { get; } Property Value Type System.String Methods Close() Unsubscribes from the stream. Declaration public void Close() Dispose() Unsubscribes from the stream. Declaration public void Dispose() Unsubscribe() Unsubscribes from the stream Declaration public abstract void Unsubscribe() Implements System.IDisposable"
  },
  "dotnet-api/code/EventStore.ClientAPI.UserManagement.UsersManager.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.UserManagement.UsersManager.html",
    "title": "Class UsersManager | Event Store",
    "keywords": "Class UsersManager API for managing users in Event Store through C# code. Communicates with Event Store over the RESTful API. All methods in this class are asynchronous. Inheritance System.Object UsersManager Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.UserManagement Assembly : EventStore.ClientAPI.dll Syntax public class UsersManager Constructors UsersManager(ILogger, EndPoint, TimeSpan, Boolean, IHttpClient) Creates a new instance of UsersManager . Declaration public UsersManager(ILogger log, EndPoint httpEndPoint, TimeSpan operationTimeout, bool tlsTerminatedEndpoint = false, IHttpClient client = null) Parameters Type Name ILogger log System.Net.EndPoint httpEndPoint System.TimeSpan operationTimeout System.Boolean tlsTerminatedEndpoint IHttpClient client Methods ChangePasswordAsync(String, String, String, UserCredentials) Change a users password. Declaration public Task ChangePasswordAsync(string login, string oldPassword, string newPassword, UserCredentials userCredentials = null) Parameters Type Name System.String login System.String oldPassword System.String newPassword UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A task representing the operation. CreateUserAsync(String, String, String[], String, UserCredentials) Create a new user. Declaration public Task CreateUserAsync(string login, string fullName, string[] groups, string password, UserCredentials userCredentials = null) Parameters Type Name System.String login System.String fullName System.String [] groups System.String password UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A task representing the operation. DeleteUserAsync(String, UserCredentials) Deletes a user. Declaration public Task DeleteUserAsync(string login, UserCredentials userCredentials = null) Parameters Type Name System.String login UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A task representing the operation. DisableAsync(String, UserCredentials) Disables a user Declaration public Task DisableAsync(string login, UserCredentials userCredentials = null) Parameters Type Name System.String login UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A task representing the operation. EnableAsync(String, UserCredentials) Enables a user Declaration public Task EnableAsync(string login, UserCredentials userCredentials = null) Parameters Type Name System.String login UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A task representing the operation. GetCurrentUserAsync(UserCredentials) Gets the current users details Declaration public Task<UserDetails> GetCurrentUserAsync(UserCredentials userCredentials) Parameters Type Name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < UserDetails > A UserDetails object for the currently logged in user. GetUserAsync(String, UserCredentials) Gets a users details. Declaration public Task<UserDetails> GetUserAsync(string login, UserCredentials userCredentials) Parameters Type Name System.String login UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < UserDetails > A UserDetails object for the user ListAllAsync(UserCredentials) Lists all users. Declaration public Task<List<UserDetails>> ListAllAsync(UserCredentials userCredentials = null) Parameters Type Name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < System.Collections.Generic.List < UserDetails >> String of JSON containing user full names and logins. ResetPasswordAsync(String, String, UserCredentials) Reset a users password. Declaration public Task ResetPasswordAsync(string login, string newPassword, UserCredentials userCredentials = null) Parameters Type Name System.String login System.String newPassword UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A task representing the operation. UpdateUserAsync(String, String, String[], UserCredentials) Update an existing user. Declaration public Task UpdateUserAsync(string login, string fullName, string[] groups, UserCredentials userCredentials = null) Parameters Type Name System.String login System.String fullName System.String [] groups UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A task representing the operation."
  },
  "dotnet-api/code/EventStore.ClientAPI.UserManagement.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.UserManagement.html",
    "title": "Namespace EventStore.ClientAPI.UserManagement | Event Store",
    "keywords": "Namespace EventStore.ClientAPI.UserManagement Classes RelLink UserDetails Provides the details for a user. UsersManager API for managing users in Event Store through C# code. Communicates with Event Store over the RESTful API. All methods in this class are asynchronous."
  },
  "dotnet-api/code/EventStore.ClientAPI.EventStorePersistentSubscriptionBase.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.EventStorePersistentSubscriptionBase.html",
    "title": "Class EventStorePersistentSubscriptionBase | Event Store",
    "keywords": "Class EventStorePersistentSubscriptionBase Represents a persistent subscription connection. Inheritance System.Object EventStorePersistentSubscriptionBase EventStorePersistentSubscription Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public abstract class EventStorePersistentSubscriptionBase Fields DefaultBufferSize The default buffer size for the persistent subscription Declaration public const int DefaultBufferSize = 10 Field Value Type System.Int32 Methods Acknowledge(ResolvedEvent) Acknowledge that a message have completed processing (this will tell the server it has been processed) Declaration public void Acknowledge(ResolvedEvent event) Parameters Type Name ResolvedEvent event Remarks There is no need to ack a message if you have Auto Ack enabled Acknowledge(IEnumerable<ResolvedEvent>) Acknowledge that a message have completed processing (this will tell the server it has been processed) Declaration public void Acknowledge(IEnumerable<ResolvedEvent> events) Parameters Type Name System.Collections.Generic.IEnumerable < ResolvedEvent > events Remarks There is no need to ack a message if you have Auto Ack enabled Acknowledge(IEnumerable<Guid>) Acknowledge a group of messages by event id (this will tell the server it has been processed) Declaration public void Acknowledge(IEnumerable<Guid> events) Parameters Type Name System.Collections.Generic.IEnumerable < System.Guid > events Remarks There is no need to ack a message if you have Auto Ack enabled Acknowledge(Guid) Acknowledge a message by event id (this will tell the server it has been processed) Declaration public void Acknowledge(Guid eventId) Parameters Type Name System.Guid eventId Remarks There is no need to ack a message if you have Auto Ack enabled Fail(ResolvedEvent, PersistentSubscriptionNakEventAction, String) Mark a message failed processing. The server will be take action based upon the action paramter Declaration public void Fail(ResolvedEvent event, PersistentSubscriptionNakEventAction action, string reason) Parameters Type Name ResolvedEvent event PersistentSubscriptionNakEventAction action System.String reason Fail(IEnumerable<ResolvedEvent>, PersistentSubscriptionNakEventAction, String) Mark nmessages that have failed processing. The server will take action based upon the action parameter Declaration public void Fail(IEnumerable<ResolvedEvent> events, PersistentSubscriptionNakEventAction action, string reason) Parameters Type Name System.Collections.Generic.IEnumerable < ResolvedEvent > events PersistentSubscriptionNakEventAction action System.String reason Stop(TimeSpan) Disconnects this client from the persistent subscriptions. Declaration public void Stop(TimeSpan timeout) Parameters Type Name System.TimeSpan timeout Exceptions Type Condition System.TimeoutException"
  },
  "dotnet-api/code/EventStore.ClientAPI.StreamCheckpoint.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.StreamCheckpoint.html",
    "title": "Class StreamCheckpoint | Event Store",
    "keywords": "Class StreamCheckpoint This class contains constants to be used when setting up subscriptions using the IEventStoreConnection.SubscribeToStreamFrom method on IEventStoreConnection . Inheritance System.Object StreamCheckpoint Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public static class StreamCheckpoint Fields StreamStart Indicates that a catch-up subscription should receive all events in the stream. Declaration public static long? StreamStart Field Value Type System.Nullable < System.Int64 >"
  },
  "dotnet-api/code/EventStore.ClientAPI.Internal.PersistentSubscriptionUpdateResult.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Internal.PersistentSubscriptionUpdateResult.html",
    "title": "Class PersistentSubscriptionUpdateResult | Event Store",
    "keywords": "Class PersistentSubscriptionUpdateResult A Persistent Subscription Create Result is the result of a single operation updating a persistent subscription in the event store Inheritance System.Object PersistentSubscriptionUpdateResult Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.Internal Assembly : EventStore.ClientAPI.dll Syntax public class PersistentSubscriptionUpdateResult Fields Status The PersistentSubscriptionUpdateResult representing the status of this create attempt Declaration public readonly PersistentSubscriptionUpdateStatus Status Field Value Type PersistentSubscriptionUpdateStatus"
  },
  "dotnet-api/code/EventStore.ClientAPI.EventStoreAllCatchUpSubscription.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.EventStoreAllCatchUpSubscription.html",
    "title": "Class EventStoreAllCatchUpSubscription | Event Store",
    "keywords": "Class EventStoreAllCatchUpSubscription A catch-up subscription to all events in the Event Store. Inheritance System.Object EventStoreCatchUpSubscription EventStoreAllCatchUpSubscription Inherited Members EventStoreCatchUpSubscription.IsSubscribedToAll EventStoreCatchUpSubscription.StreamId EventStoreCatchUpSubscription.SubscriptionName EventStoreCatchUpSubscription.Log EventStoreCatchUpSubscription.ReadBatchSize EventStoreCatchUpSubscription.MaxPushQueueSize EventStoreCatchUpSubscription.EventAppeared EventStoreCatchUpSubscription.Verbose EventStoreCatchUpSubscription.ShouldStop EventStoreCatchUpSubscription.Stop(TimeSpan) EventStoreCatchUpSubscription.Stop() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class EventStoreAllCatchUpSubscription : EventStoreCatchUpSubscription Properties LastProcessedPosition The last position processed on the subscription. Declaration public Position LastProcessedPosition { get; } Property Value Type Position Methods ReadEventsTillAsync(IEventStoreConnection, Boolean, UserCredentials, Nullable<Int64>, Nullable<Int64>) Read events until the given position async. Declaration protected override Task ReadEventsTillAsync(IEventStoreConnection connection, bool resolveLinkTos, UserCredentials userCredentials, long? lastCommitPosition, long? lastEventNumber) Parameters Type Name IEventStoreConnection connection System.Boolean resolveLinkTos UserCredentials userCredentials System.Nullable < System.Int64 > lastCommitPosition System.Nullable < System.Int64 > lastEventNumber Returns Type Description System.Threading.Tasks.Task Overrides EventStoreCatchUpSubscription.ReadEventsTillAsync(IEventStoreConnection, Boolean, UserCredentials, Nullable<Int64>, Nullable<Int64>) TryProcessAsync(ResolvedEvent) Try to process a single ResolvedEvent . Declaration protected override Task TryProcessAsync(ResolvedEvent e) Parameters Type Name ResolvedEvent e Returns Type Description System.Threading.Tasks.Task Overrides EventStoreCatchUpSubscription.TryProcessAsync(ResolvedEvent)"
  },
  "dotnet-api/code/EventStore.ClientAPI.StreamEventsSlice.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.StreamEventsSlice.html",
    "title": "Class StreamEventsSlice | Event Store",
    "keywords": "Class StreamEventsSlice A stream events slice represents the result of a single read operation to Event Store. Inheritance System.Object StreamEventsSlice Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class StreamEventsSlice Fields Events The events read represented as ResolvedEvent . Declaration public readonly ResolvedEvent[] Events Field Value Type ResolvedEvent [] FromEventNumber The starting point (represented as a sequence number) of the read operation. Declaration public readonly long FromEventNumber Field Value Type System.Int64 IsEndOfStream A boolean representing whether or not this is the end of the stream. Declaration public readonly bool IsEndOfStream Field Value Type System.Boolean LastEventNumber The last event number in the stream. Declaration public readonly long LastEventNumber Field Value Type System.Int64 NextEventNumber The next event number that can be read. Declaration public readonly long NextEventNumber Field Value Type System.Int64 ReadDirection The direction of read request. Declaration public readonly ReadDirection ReadDirection Field Value Type ReadDirection Status The SliceReadStatus representing the status of this read attempt. Declaration public readonly SliceReadStatus Status Field Value Type SliceReadStatus Stream The name of the stream to read. Declaration public readonly string Stream Field Value Type System.String"
  },
  "dotnet-api/code/EventStore.ClientAPI.EventStorePersistentSubscription.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.EventStorePersistentSubscription.html",
    "title": "Class EventStorePersistentSubscription | Event Store",
    "keywords": "Class EventStorePersistentSubscription Represents a persistent subscription connection. Inheritance System.Object EventStorePersistentSubscriptionBase EventStorePersistentSubscription Inherited Members EventStorePersistentSubscriptionBase.DefaultBufferSize EventStorePersistentSubscriptionBase.Acknowledge(ResolvedEvent) EventStorePersistentSubscriptionBase.Acknowledge(IEnumerable<ResolvedEvent>) EventStorePersistentSubscriptionBase.Acknowledge(Guid) EventStorePersistentSubscriptionBase.Acknowledge(IEnumerable<Guid>) EventStorePersistentSubscriptionBase.Fail(ResolvedEvent, PersistentSubscriptionNakEventAction, String) EventStorePersistentSubscriptionBase.Fail(IEnumerable<ResolvedEvent>, PersistentSubscriptionNakEventAction, String) EventStorePersistentSubscriptionBase.Stop(TimeSpan) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class EventStorePersistentSubscription : EventStorePersistentSubscriptionBase"
  },
  "dotnet-api/code/EventStore.ClientAPI.StreamMetadata.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.StreamMetadata.html",
    "title": "Class StreamMetadata | Event Store",
    "keywords": "Class StreamMetadata A class representing stream metadata with strongly typed properties for system values and a dictionary-like interface for custom values. Inheritance System.Object StreamMetadata Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class StreamMetadata Fields Acl The access control list for the stream. Declaration public readonly StreamAcl Acl Field Value Type StreamAcl CacheControl The amount of time for which the stream head is cachable. Declaration public readonly TimeSpan? CacheControl Field Value Type System.Nullable < System.TimeSpan > MaxAge The maximum age of events allowed in the stream. Declaration public readonly TimeSpan? MaxAge Field Value Type System.Nullable < System.TimeSpan > MaxCount The maximum number of events allowed in the stream. Declaration public readonly long? MaxCount Field Value Type System.Nullable < System.Int64 > TruncateBefore The event number from which previous events can be scavenged. This is used to implement soft-deletion of streams. Declaration public readonly long? TruncateBefore Field Value Type System.Nullable < System.Int64 > Properties CustomKeys An enumerable of the keys in the user-provided metadata. Declaration public IEnumerable<string> CustomKeys { get; } Property Value Type System.Collections.Generic.IEnumerable < System.String > CustomMetadataAsRawJsons An enumerable of key-value pairs of keys to JSON text for user-provider metadata. Declaration public IEnumerable<KeyValuePair<string, string>> CustomMetadataAsRawJsons { get; } Property Value Type System.Collections.Generic.IEnumerable < System.Collections.Generic.KeyValuePair < System.String , System.String >> Methods AsJsonBytes() Returns a byte array representing the stream metadata as JSON encoded as UTF8 with no byte order mark. Declaration public byte[] AsJsonBytes() Returns Type Description System.Byte [] Byte array representing the stream metadata. AsJsonString() Returns a JSON string representing the stream metadata. Declaration public string AsJsonString() Returns Type Description System.String A string representing the stream metadata. Build() Creates a StreamMetadataBuilder for building a new StreamMetadata . Declaration public static StreamMetadataBuilder Build() Returns Type Description StreamMetadataBuilder An instance of StreamMetadataBuilder . Copy() Creates a StreamMetadataBuilder initialized with the values of this StreamMetadata Declaration public StreamMetadataBuilder Copy() Returns Type Description StreamMetadataBuilder An instance of StreamMetadataBuilder . Create(Nullable<Int64>, Nullable<TimeSpan>, Nullable<Int64>, Nullable<TimeSpan>, StreamAcl) Creates a StreamMetadata with the specified parameters. Declaration public static StreamMetadata Create(long? maxCount = default(long? ), TimeSpan? maxAge = default(TimeSpan? ), long? truncateBefore = default(long? ), TimeSpan? cacheControl = default(TimeSpan? ), StreamAcl acl = null) Parameters Type Name System.Nullable < System.Int64 > maxCount System.Nullable < System.TimeSpan > maxAge System.Nullable < System.Int64 > truncateBefore System.Nullable < System.TimeSpan > cacheControl StreamAcl acl Returns Type Description StreamMetadata FromJsonBytes(Byte[]) Builds a StreamMetadata object from a byte array containing stream metadata. Declaration public static StreamMetadata FromJsonBytes(byte[] json) Parameters Type Name System.Byte [] json Returns Type Description StreamMetadata GetValue<T>(String) Get a value of type T for the given key from the custom metadata. This method will throw an System.ArgumentException if the key is not found. Declaration public T GetValue<T>(string key) Parameters Type Name System.String key Returns Type Description T Value of type T for the key. Type Parameters Name Description T The type of the value. GetValueAsRawJsonString(String) Gets a string containing raw JSON value for the given key. Declaration public string GetValueAsRawJsonString(string key) Parameters Type Name System.String key Returns Type Description System.String String containing raw JSON value for the key. Exceptions Type Condition System.ArgumentException If the key does not exist. TryGetValue<T>(String, out T) Tries to get a value of type T for the given key from the custom metadata, and if it exists returns true from the method and gives the value as an out parameter. Declaration public bool TryGetValue<T>(string key, out T value) Parameters Type Name System.String key T value Returns Type Description System.Boolean True if the key exists, false otherwise. Type Parameters Name Description T The type of the value. TryGetValueAsRawJsonString(String, out String) Tries to get a string containing raw JSON value for the given key. Declaration public bool TryGetValueAsRawJsonString(string key, out string value) Parameters Type Name System.String key System.String value Returns Type Description System.Boolean True if the key exists, false otherwise."
  },
  "dotnet-api/code/EventStore.ClientAPI.Projections.ProjectionDetails.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Projections.ProjectionDetails.html",
    "title": "Class ProjectionDetails | Event Store",
    "keywords": "Class ProjectionDetails Provides the details for a projection. Inheritance System.Object ProjectionDetails Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.Projections Assembly : EventStore.ClientAPI.dll Syntax public sealed class ProjectionDetails Constructors ProjectionDetails(Int64, Int64, Int64, String, Int32, Int32, Int32, String, String, String, String, String, Single, String, Int64, Uri, Uri, Uri, Uri, Uri, Uri, String, Int64, Int32, Int32) create a new ProjectionDetails class. Declaration public ProjectionDetails(long coreProcessingTime, long version, long epoch, string effectiveName, int writesInProgress, int readsInProgress, int partitionsCached, string status, string stateReason, string name, string mode, string position, float progress, string lastCheckpoint, long eventsProcessedAfterRestart, Uri statusUrl, Uri stateUrl, Uri resultUrl, Uri queryUrl, Uri enableCommandUrl, Uri disableCommandUrl, string checkpointStatus, long bufferedEvents, int writePendingEventsBeforeCheckpoint, int writePendingEventsAfterCheckpoint) Parameters Type Name System.Int64 coreProcessingTime System.Int64 version System.Int64 epoch System.String effectiveName System.Int32 writesInProgress System.Int32 readsInProgress System.Int32 partitionsCached System.String status System.String stateReason System.String name System.String mode System.String position System.Single progress System.String lastCheckpoint System.Int64 eventsProcessedAfterRestart System.Uri statusUrl System.Uri stateUrl System.Uri resultUrl System.Uri queryUrl System.Uri enableCommandUrl System.Uri disableCommandUrl System.String checkpointStatus System.Int64 bufferedEvents System.Int32 writePendingEventsBeforeCheckpoint System.Int32 writePendingEventsAfterCheckpoint Fields BufferedEvents The projection BufferedEvents Declaration public readonly long BufferedEvents Field Value Type System.Int64 CheckpointStatus The projection CheckpointStatus Declaration public readonly string CheckpointStatus Field Value Type System.String CoreProcessingTime The CoreProcessingTime Declaration public readonly long CoreProcessingTime Field Value Type System.Int64 DisableCommandUrl The projection DisableCommandUrl Declaration public readonly Uri DisableCommandUrl Field Value Type System.Uri EffectiveName The projection EffectiveName Declaration public readonly string EffectiveName Field Value Type System.String EnableCommandUrl The projection EnableCommandUrl Declaration public readonly Uri EnableCommandUrl Field Value Type System.Uri Epoch The Epoch Declaration public readonly long Epoch Field Value Type System.Int64 EventsProcessedAfterRestart The projection EventsProcessedAfterRestart Declaration public readonly long EventsProcessedAfterRestart Field Value Type System.Int64 LastCheckpoint LastCheckpoint Declaration public readonly string LastCheckpoint Field Value Type System.String Mode The projection Mode Declaration public readonly string Mode Field Value Type System.String Name The projection Name Declaration public readonly string Name Field Value Type System.String PartitionsCached The projection PartitionsCached Declaration public readonly int PartitionsCached Field Value Type System.Int32 Position The projection Position Declaration public readonly string Position Field Value Type System.String Progress The projection Progress Declaration public readonly float Progress Field Value Type System.Single QueryUrl The projection QueryUrl Declaration public readonly Uri QueryUrl Field Value Type System.Uri ReadsInProgress The projection ReadsInProgress Declaration public readonly int ReadsInProgress Field Value Type System.Int32 ResultUrl The projection ResultUrl Declaration public readonly Uri ResultUrl Field Value Type System.Uri StateReason The projection StateReason Declaration public readonly string StateReason Field Value Type System.String StateUrl The projection StateUrl Declaration public readonly Uri StateUrl Field Value Type System.Uri Status The projection Status Declaration public readonly string Status Field Value Type System.String StatusUrl The projection StatusUrl Declaration public readonly Uri StatusUrl Field Value Type System.Uri Version The projection version Declaration public readonly long Version Field Value Type System.Int64 WritePendingEventsAfterCheckpoint The projection WritePendingEventsAfterCheckpoint Declaration public readonly int WritePendingEventsAfterCheckpoint Field Value Type System.Int32 WritePendingEventsBeforeCheckpoint The projection WritePendingEventsBeforeCheckpoint Declaration public readonly int WritePendingEventsBeforeCheckpoint Field Value Type System.Int32 WritesInProgress The projection WritesInProgress Declaration public readonly int WritesInProgress Field Value Type System.Int32"
  },
  "dotnet-api/code/EventStore.ClientAPI.CatchUpSubscriptionSettings.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.CatchUpSubscriptionSettings.html",
    "title": "Class CatchUpSubscriptionSettings | Event Store",
    "keywords": "Class CatchUpSubscriptionSettings Settings for EventStoreCatchUpSubscription . Inheritance System.Object CatchUpSubscriptionSettings Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class CatchUpSubscriptionSettings Constructors CatchUpSubscriptionSettings(Int32, Int32, Boolean, Boolean, String) Constructs a CatchUpSubscriptionSettings object. Declaration public CatchUpSubscriptionSettings(int maxLiveQueueSize, int readBatchSize, bool verboseLogging, bool resolveLinkTos, string subscriptionName = \"\") Parameters Type Name System.Int32 maxLiveQueueSize System.Int32 readBatchSize System.Boolean verboseLogging System.Boolean resolveLinkTos System.String subscriptionName Fields Default Returns default settings. Declaration public static readonly CatchUpSubscriptionSettings Default Field Value Type CatchUpSubscriptionSettings MaxLiveQueueSize The maximum amount of events to cache when processing from a live subscription. Going above this value will drop the subscription. Declaration public readonly int MaxLiveQueueSize Field Value Type System.Int32 ReadBatchSize The number of events to read per batch when reading the history. Declaration public readonly int ReadBatchSize Field Value Type System.Int32 ResolveLinkTos Whether to resolve link events. Declaration public readonly bool ResolveLinkTos Field Value Type System.Boolean SubscriptionName The name of the subscription. Declaration public readonly string SubscriptionName Field Value Type System.String VerboseLogging Enables verbose logging on the subscription. Declaration public readonly bool VerboseLogging Field Value Type System.Boolean"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.CommandNotExpectedException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.CommandNotExpectedException.html",
    "title": "Class CommandNotExpectedException | Event Store",
    "keywords": "Class CommandNotExpectedException Exception thrown if an unexpected command is received. Inheritance System.Object System.Exception EventStoreConnectionException CommandNotExpectedException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class CommandNotExpectedException : EventStoreConnectionException, ISerializable Constructors CommandNotExpectedException(String) Constructs a new CommandNotExpectedException . Declaration public CommandNotExpectedException(string unexpectedCommand) Parameters Type Name System.String unexpectedCommand CommandNotExpectedException(String, String) Constructs a new CommandNotExpectedException . Declaration public CommandNotExpectedException(string expected, string actual) Parameters Type Name System.String expected System.String actual Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.Projections.ProjectionConfig.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Projections.ProjectionConfig.html",
    "title": "Class ProjectionConfig | Event Store",
    "keywords": "Class ProjectionConfig Provides the configuration for a projection. Inheritance System.Object ProjectionConfig Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.Projections Assembly : EventStore.ClientAPI.dll Syntax public sealed class ProjectionConfig Constructors ProjectionConfig(Boolean, Boolean, Int32, Int32, Int32, Int32, Int32, Int32) create a new ProjectionConfig class. Declaration public ProjectionConfig(bool emitEnabled, bool trackEmittedStreams, int checkpointAfterMs, int checkpointHandledThreshold, int checkpointUnhandledBytesThreshold, int pendingEventsThreshold, int maxWriteBatchLength, int maxAllowedWritesInFlight) Parameters Type Name System.Boolean emitEnabled System.Boolean trackEmittedStreams System.Int32 checkpointAfterMs System.Int32 checkpointHandledThreshold System.Int32 checkpointUnhandledBytesThreshold System.Int32 pendingEventsThreshold System.Int32 maxWriteBatchLength System.Int32 maxAllowedWritesInFlight Fields CheckpointAfterMs Minimum time (in ms) after which to write a projection checkpoint. Declaration public readonly int CheckpointAfterMs Field Value Type System.Int32 CheckpointHandledThreshold Number of events that a projection can handle before attempting to write a checkpoint. Declaration public readonly int CheckpointHandledThreshold Field Value Type System.Int32 CheckpointUnhandledBytesThreshold Number of bytes a projection can process before attempting to write a checkpoint. Declaration public readonly int CheckpointUnhandledBytesThreshold Field Value Type System.Int32 EmitEnabled Whether this projection can emit events using emit() or linkTo(). Declaration public readonly bool EmitEnabled Field Value Type System.Boolean MaxAllowedWritesInFlight Maximum number of concurrent writes to allow for a projection. Declaration public readonly int MaxAllowedWritesInFlight Field Value Type System.Int32 MaxWriteBatchLength Maximum number of events the projection can write in a batch at a time. Declaration public readonly int MaxWriteBatchLength Field Value Type System.Int32 PendingEventsThreshold Number of events that can be pending before the projection is temporarily paused. Declaration public readonly int PendingEventsThreshold Field Value Type System.Int32 TrackEmittedStreams Whether this projection tracks emitted streams. This enables you to delete a projection and all the streams that it has created. Declaration public readonly bool TrackEmittedStreams Field Value Type System.Boolean"
  },
  "dotnet-api/code/EventStore.ClientAPI.EventReadStatus.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.EventReadStatus.html",
    "title": "Enum EventReadStatus | Event Store",
    "keywords": "Enum EventReadStatus Enumeration representing the status of a single event read operation. Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public enum EventReadStatus Fields Name Description NoStream The stream was not found. NotFound The event was not found. StreamDeleted The stream previously existed but was deleted. Success The read operation was successful."
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.ServerErrorException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.ServerErrorException.html",
    "title": "Class ServerErrorException | Event Store",
    "keywords": "Class ServerErrorException Exception thrown if a server-side error occurs during an operation. Inheritance System.Object System.Exception EventStoreConnectionException ServerErrorException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class ServerErrorException : EventStoreConnectionException, ISerializable Constructors ServerErrorException() Constructs a new instance of ServerErrorException . Declaration public ServerErrorException() ServerErrorException(SerializationInfo, StreamingContext) Constructs a new instance of ServerErrorException . Declaration protected ServerErrorException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context ServerErrorException(String) Constructs a new instance of ServerErrorException . Declaration public ServerErrorException(string message) Parameters Type Name System.String message ServerErrorException(String, Exception) Constructs a new instance of ServerErrorException . Declaration public ServerErrorException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.ClientConnectionEventArgs.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ClientConnectionEventArgs.html",
    "title": "Class ClientConnectionEventArgs | Event Store",
    "keywords": "Class ClientConnectionEventArgs Event Arguments for the event raised when an IEventStoreConnection is connected to or disconnected from an Event Store server. Inheritance System.Object System.EventArgs ClientConnectionEventArgs Inherited Members System.EventArgs.Empty System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class ClientConnectionEventArgs : EventArgs Constructors ClientConnectionEventArgs(IEventStoreConnection, IPEndPoint) Constructs a new instance of ClientConnectionEventArgs . Declaration public ClientConnectionEventArgs(IEventStoreConnection connection, IPEndPoint remoteEndPoint) Parameters Type Name IEventStoreConnection connection System.Net.IPEndPoint remoteEndPoint Properties Connection The IEventStoreConnection responsible for raising the event. Declaration public IEventStoreConnection Connection { get; } Property Value Type IEventStoreConnection RemoteEndPoint The endpoint of the Event Store server to or from which the connection was connected or disconnected. Declaration public IPEndPoint RemoteEndPoint { get; } Property Value Type System.Net.IPEndPoint"
  },
  "dotnet-api/code/EventStore.ClientAPI.ClientErrorEventArgs.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ClientErrorEventArgs.html",
    "title": "Class ClientErrorEventArgs | Event Store",
    "keywords": "Class ClientErrorEventArgs Event Arguments for the event raised when an error occurs on an IEventStoreConnection . Inheritance System.Object System.EventArgs ClientErrorEventArgs Inherited Members System.EventArgs.Empty System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class ClientErrorEventArgs : EventArgs Constructors ClientErrorEventArgs(IEventStoreConnection, Exception) Constructs a new instance of ClientErrorEventArgs . Declaration public ClientErrorEventArgs(IEventStoreConnection connection, Exception exception) Parameters Type Name IEventStoreConnection connection System.Exception exception Properties Connection The IEventStoreConnection responsible for raising the event. Declaration public IEventStoreConnection Connection { get; } Property Value Type IEventStoreConnection Exception The thrown exception, if one was raised. Declaration public Exception Exception { get; } Property Value Type System.Exception"
  },
  "dotnet-api/code/EventStore.ClientAPI.ConnectionSettingsBuilder.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ConnectionSettingsBuilder.html",
    "title": "Class ConnectionSettingsBuilder | Event Store",
    "keywords": "Class ConnectionSettingsBuilder Used to build a connection settings (fluent API) Inheritance System.Object ConnectionSettingsBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class ConnectionSettingsBuilder Methods Build() Convert the mutable ConnectionSettingsBuilder object to an immutable ConnectionSettings object. Declaration public ConnectionSettings Build() Returns Type Description ConnectionSettings EnableVerboseLogging() Turns on verbose EventStoreConnection internal logic logging. By contains default information about connection, disconnection and errors, but you can customize output. Declaration public ConnectionSettingsBuilder EnableVerboseLogging() Returns Type Description ConnectionSettingsBuilder FailOnNoServerResponse() Marks that no response from server should cause an error on the request. Declaration public ConnectionSettingsBuilder FailOnNoServerResponse() Returns Type Description ConnectionSettingsBuilder KeepReconnecting() Allows infinite reconnection attempts. Declaration public ConnectionSettingsBuilder KeepReconnecting() Returns Type Description ConnectionSettingsBuilder KeepRetrying() Allows infinite operation retry attempts. Declaration public ConnectionSettingsBuilder KeepRetrying() Returns Type Description ConnectionSettingsBuilder LimitAttemptsForOperationTo(Int32) Limits the number of operation attempts. Declaration public ConnectionSettingsBuilder LimitAttemptsForOperationTo(int limit) Parameters Type Name System.Int32 limit Returns Type Description ConnectionSettingsBuilder LimitConcurrentOperationsTo(Int32) Limits the number of concurrent operations that this connection can have. Declaration public ConnectionSettingsBuilder LimitConcurrentOperationsTo(int limit) Parameters Type Name System.Int32 limit Returns Type Description ConnectionSettingsBuilder LimitOperationsQueueTo(Int32) Sets the limit for number of outstanding operations. Declaration public ConnectionSettingsBuilder LimitOperationsQueueTo(int limit) Parameters Type Name System.Int32 limit Returns Type Description ConnectionSettingsBuilder LimitReconnectionsTo(Int32) Limits the number of reconnections this connection can try to make. Declaration public ConnectionSettingsBuilder LimitReconnectionsTo(int limit) Parameters Type Name System.Int32 limit Returns Type Description ConnectionSettingsBuilder LimitRetriesForOperationTo(Int32) Limits the number of operation retries. Declaration public ConnectionSettingsBuilder LimitRetriesForOperationTo(int limit) Parameters Type Name System.Int32 limit Returns Type Description ConnectionSettingsBuilder PerformOnAnyNode() Allow for writes to be forwarded and read requests served locally if node is not master (cluster version only). Declaration public ConnectionSettingsBuilder PerformOnAnyNode() Returns Type Description ConnectionSettingsBuilder PerformOnMasterOnly() Requires all write and read requests to be served only by master (cluster version only). Declaration public ConnectionSettingsBuilder PerformOnMasterOnly() Returns Type Description ConnectionSettingsBuilder PreferRandomNode() Whether to randomly choose a node that's alive from the known nodes. Declaration public ConnectionSettingsBuilder PreferRandomNode() Returns Type Description ConnectionSettingsBuilder A DnsClusterSettingsBuilder for further configuration. PreferSlaveNode() Whether to prioritize choosing a slave node that's alive from the known nodes. Declaration public ConnectionSettingsBuilder PreferSlaveNode() Returns Type Description ConnectionSettingsBuilder A DnsClusterSettingsBuilder for further configuration. SetClusterDns(String) Sets the DNS name under which cluster nodes are listed. Declaration public ConnectionSettingsBuilder SetClusterDns(string clusterDns) Parameters Type Name System.String clusterDns Returns Type Description ConnectionSettingsBuilder A DnsClusterSettingsBuilder for further configuration. Exceptions Type Condition System.ArgumentNullException If clusterDns is null or empty. SetClusterGossipPort(Int32) Sets the well-known port on which the cluster gossip is taking place. If you are using the commercial edition of Event Store HA, with Manager nodes in place, this should be the port number of the External HTTP port on which the managers are running. If you are using the open source edition of Event Store HA, this should be the External HTTP port that the nodes are running on. If you cannot use a well-known port for this across all nodes, you can instead use gossip seed discovery and set the System.Net.IPEndPoint of some seed nodes instead. Declaration public ConnectionSettingsBuilder SetClusterGossipPort(int clusterGossipPort) Parameters Type Name System.Int32 clusterGossipPort Returns Type Description ConnectionSettingsBuilder A DnsClusterSettingsBuilder for further configuration. SetDefaultUserCredentials(UserCredentials) Sets the default UserCredentials used for this connection. If user credentials are not given for an operation, these credentials will be used. Declaration public ConnectionSettingsBuilder SetDefaultUserCredentials(UserCredentials userCredentials) Parameters Type Name UserCredentials userCredentials Returns Type Description ConnectionSettingsBuilder SetGossipSeedEndPoints(GossipSeed[]) Sets gossip seed endpoints for the client. Declaration public ConnectionSettingsBuilder SetGossipSeedEndPoints(params GossipSeed[] gossipSeeds) Parameters Type Name GossipSeed [] gossipSeeds Returns Type Description ConnectionSettingsBuilder A ClusterSettingsBuilder for further configuration. Exceptions Type Condition System.ArgumentException If no gossip seeds are specified. SetGossipSeedEndPoints(Boolean, IPEndPoint[]) Sets gossip seed endpoints for the client. note This should be the external HTTP endpoint of the server, as it is required for the client to exchange gossip with the server. The standard port is 2113. If the server requires a specific Host header to be sent as part of the gossip request, use the overload of this method taking GossipSeed instead. Declaration public ConnectionSettingsBuilder SetGossipSeedEndPoints(bool seedOverTls, params IPEndPoint[] gossipSeeds) Parameters Type Name System.Boolean seedOverTls System.Net.IPEndPoint [] gossipSeeds Returns Type Description ConnectionSettingsBuilder A ClusterSettingsBuilder for further configuration. Exceptions Type Condition System.ArgumentException If no gossip seeds are specified. SetGossipSeedEndPoints(IPEndPoint[]) Sets gossip seed endpoints for the client. note This should be the external HTTP endpoint of the server, as it is required for the client to exchange gossip with the server. The standard port is 2113. If the server requires a specific Host header to be sent as part of the gossip request, use the overload of this method taking GossipSeed instead. Declaration public ConnectionSettingsBuilder SetGossipSeedEndPoints(params IPEndPoint[] gossipSeeds) Parameters Type Name System.Net.IPEndPoint [] gossipSeeds Returns Type Description ConnectionSettingsBuilder A ClusterSettingsBuilder for further configuration. Exceptions Type Condition System.ArgumentException If no gossip seeds are specified. SetGossipTimeout(TimeSpan) Sets the period after which gossip times out if none is received. Declaration public ConnectionSettingsBuilder SetGossipTimeout(TimeSpan timeout) Parameters Type Name System.TimeSpan timeout Returns Type Description ConnectionSettingsBuilder A DnsClusterSettingsBuilder for further configuration. SetHeartbeatInterval(TimeSpan) Sets how often heartbeats should be expected on the connection (lower values detect broken sockets faster). Declaration public ConnectionSettingsBuilder SetHeartbeatInterval(TimeSpan interval) Parameters Type Name System.TimeSpan interval Returns Type Description ConnectionSettingsBuilder SetHeartbeatTimeout(TimeSpan) Sets how long to wait without heartbeats before determining a connection to be dead (must be longer than heartbeat interval). Declaration public ConnectionSettingsBuilder SetHeartbeatTimeout(TimeSpan timeout) Parameters Type Name System.TimeSpan timeout Returns Type Description ConnectionSettingsBuilder SetMaxDiscoverAttempts(Int32) Sets the maximum number of attempts for discovery. Declaration public ConnectionSettingsBuilder SetMaxDiscoverAttempts(int maxDiscoverAttempts) Parameters Type Name System.Int32 maxDiscoverAttempts Returns Type Description ConnectionSettingsBuilder A DnsClusterSettingsBuilder for further configuration. Exceptions Type Condition System.ArgumentOutOfRangeException If maxDiscoverAttempts is less than or equal to 0. SetOperationTimeoutTo(TimeSpan) Sets the operation timeout duration. Declaration public ConnectionSettingsBuilder SetOperationTimeoutTo(TimeSpan operationTimeout) Parameters Type Name System.TimeSpan operationTimeout Returns Type Description ConnectionSettingsBuilder SetQueueTimeoutTo(TimeSpan) Sets the maximum permitted time a request may be queued awaiting transmission; if exceeded an OperationExpiredException is thrown. Declaration public ConnectionSettingsBuilder SetQueueTimeoutTo(TimeSpan queueTimeout) Parameters Type Name System.TimeSpan queueTimeout Returns Type Description ConnectionSettingsBuilder SetReconnectionDelayTo(TimeSpan) Sets the delay between reconnection attempts. Declaration public ConnectionSettingsBuilder SetReconnectionDelayTo(TimeSpan reconnectionDelay) Parameters Type Name System.TimeSpan reconnectionDelay Returns Type Description ConnectionSettingsBuilder SetTimeoutCheckPeriodTo(TimeSpan) Sets how often timeouts should be checked for. Declaration public ConnectionSettingsBuilder SetTimeoutCheckPeriodTo(TimeSpan timeoutCheckPeriod) Parameters Type Name System.TimeSpan timeoutCheckPeriod Returns Type Description ConnectionSettingsBuilder UseConsoleLogger() Configures the connection to output log messages to the console. Declaration public ConnectionSettingsBuilder UseConsoleLogger() Returns Type Description ConnectionSettingsBuilder UseCustomHttpClient(IHttpClient) Declaration public ConnectionSettingsBuilder UseCustomHttpClient(IHttpClient client) Parameters Type Name IHttpClient client Returns Type Description ConnectionSettingsBuilder UseCustomLogger(ILogger) Configures the connection to output log messages to the given ILogger . You should implement this interface using another library such as NLog or log4net. Declaration public ConnectionSettingsBuilder UseCustomLogger(ILogger logger) Parameters Type Name ILogger logger Returns Type Description ConnectionSettingsBuilder UseDebugLogger() Configures the connection to output log messages to the listeners configured on System.Diagnostics.Debug . Declaration public ConnectionSettingsBuilder UseDebugLogger() Returns Type Description ConnectionSettingsBuilder UseFileLogger(String) Configures the connection to output log messages to a file. Declaration public ConnectionSettingsBuilder UseFileLogger(string filename) Parameters Type Name System.String filename Returns Type Description ConnectionSettingsBuilder UseSslConnection(String, Boolean) Uses a SSL connection over TCP. This should generally be used with authentication. Declaration public ConnectionSettingsBuilder UseSslConnection(string targetHost, bool validateServer) Parameters Type Name System.String targetHost System.Boolean validateServer Returns Type Description ConnectionSettingsBuilder WithConnectionTimeoutOf(TimeSpan) Sets the timeout for attempting to connect to a server before aborting and attempting a reconnect. Declaration public ConnectionSettingsBuilder WithConnectionTimeoutOf(TimeSpan timeout) Parameters Type Name System.TimeSpan timeout Returns Type Description ConnectionSettingsBuilder Operators Implicit(ConnectionSettingsBuilder to ConnectionSettings) Convert the mutable ConnectionSettingsBuilder object to an immutable ConnectionSettings object. Declaration public static implicit operator ConnectionSettings(ConnectionSettingsBuilder builder) Parameters Type Name ConnectionSettingsBuilder builder Returns Type Description ConnectionSettings An immutable ConnectionSettings object with the values specified by the builder."
  },
  "http-api/swagger/Scavenge a node.html": {
    "href": "http-api/swagger/Scavenge a node.html",
    "title": "Scavenge a node | Event Store",
    "keywords": "Scavenge a node Scavenge reclaims disk space by rewriting database chunks, minus the events to delete, and then deleting the old chunks. Request POST /admin/scavenge[?startFromChunk&threads] Parameters Name Type Value Notes startFromChunk integer The chunk ID to start the scavenge operation from. threads integer 1 The number of threads to run the scavenge operation on (max 4). Responses Status Code Description Samples 200 OK 401 Unauthorized"
  },
  "http-api/swagger/Stop a scavenge.html": {
    "href": "http-api/swagger/Stop a scavenge.html",
    "title": "Stop a scavenge | Event Store",
    "keywords": "Stop a scavenge Stop a running scavenge operation. Request DELETE /admin/scavenge/{scavengeId} Parameters Name Type Value Notes *scavengeId integer The scavenge ID Responses Status Code Description Samples 200 OK 401 Unauthorized"
  },
  "http-api/swagger/Merge Indexes.html": {
    "href": "http-api/swagger/Merge Indexes.html",
    "title": "Merge Indexes | Event Store",
    "keywords": "Merge Indexes Manually merge indexes after a scavenge operation Request DELETE /admin/mergeindexes Responses Status Code Description Samples 200 OK 401 Unauthorized"
  },
  "http-api/swagger/Get info for node.html": {
    "href": "http-api/swagger/Get info for node.html",
    "title": "Get info for node | Event Store",
    "keywords": "Get info for node Returns information about node. Request GET /info Responses Status Code Description Samples 200 OK 401 Unauthorized"
  },
  "http-api/swagger/Get configuration for node.html": {
    "href": "http-api/swagger/Get configuration for node.html",
    "title": "Get configuration for node | Event Store",
    "keywords": "Get configuration for node Returns configuration details about node. Request GET /info/options Responses Status Code Description Samples 200 OK 401 Unauthorized"
  },
  "http-api/swagger/Read a stream.html": {
    "href": "http-api/swagger/Read a stream.html",
    "title": "Read a stream | Event Store",
    "keywords": "Read a stream Read a stream, receiving a standard AtomFeed document as a response. Request GET /streams/{stream}[?embed] Parameters Name Type Value Notes *stream string The stream ID embed string Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Write to a stream.html": {
    "href": "http-api/swagger/Write to a stream.html",
    "title": "Write to a stream | Event Store",
    "keywords": "Write to a stream Write to a stream. Request POST /streams/{stream} Parameters Name Type Value Notes *stream string The name of the stream *stream data object Name Type Notes body object Event data Stream events to create ES-ExpectedVersion integer Expected stream version ES-EventType string The event type associated to a posted body ES-EventId integer Event ID associated to a posted body ES-RequiresMaster boolean Wether to run on a master node Responses Status Code Description Samples 201 New stream created 307 Temporary Redirect 400 Write request body invalid"
  },
  "http-api/swagger/Delete a stream.html": {
    "href": "http-api/swagger/Delete a stream.html",
    "title": "Delete a stream | Event Store",
    "keywords": "Delete a stream Delete specified stream Request DELETE /streams/{stream} Parameters Name Type Value Notes *stream string The stream ID to delete Responses Status Code Description Samples 204 Stream deleted"
  },
  "http-api/swagger/Alternative stream URL.html": {
    "href": "http-api/swagger/Alternative stream URL.html",
    "title": "Alternative stream URL | Event Store",
    "keywords": "Alternative stream URL A URL generated by Event Store if you don't supply an ID when creating a stream. You then use this URL to post events to. Request POST /streams/{stream}/incoming/{guid} Parameters Name Type Value Notes *stream string The name of the stream *guid string Autogenerated UUID Responses Status Code Description Samples 200 New event created 400 Bad request"
  },
  "http-api/swagger/Read stream event.html": {
    "href": "http-api/swagger/Read stream event.html",
    "title": "Read stream event | Event Store",
    "keywords": "Read stream event Reads a single event from a stream. Request GET /streams/{stream}/{event}[?embed] Parameters Name Type Value Notes *stream string The stream ID *event string The event ID embed string Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Get {n} events.html": {
    "href": "http-api/swagger/Get {n} events.html",
    "title": "Get {n} events | Event Store",
    "keywords": "Get {n} events Paginate backwards though stream events by a specified amount. Request GET /streams/{stream}/{event}/{count}[?embed] Parameters Name Type Value Notes *stream string The stream ID *event string The event ID *count integer How many events to skip backwards from in the request. embed string Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Page back through events.html": {
    "href": "http-api/swagger/Page back through events.html",
    "title": "Page back through events | Event Store",
    "keywords": "Page back through events Paginate backwards though stream events by a specified amount. Request GET /streams/{stream}/{event}/backward/{count}[?embed] Parameters Name Type Value Notes *stream string The stream ID *event string The event ID *count integer How many events to skip backwards from in the request. embed string Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Page forward through events.html": {
    "href": "http-api/swagger/Page forward through events.html",
    "title": "Page forward through events | Event Store",
    "keywords": "Page forward through events Paginate forwards though stream events by a specified amount. Request GET /streams/{stream}/{event}/forward/{count}[?embed] Parameters Name Type Value Notes *stream string The stream ID *event string The event ID *count integer How many events to skip forwards in the request. embed string Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Read stream metadata.html": {
    "href": "http-api/swagger/Read stream metadata.html",
    "title": "Read stream metadata | Event Store",
    "keywords": "Read stream metadata Returns metadata of a stream, typically information associated with an event that is not part of the event. Request GET /streams/{stream}/metadata[?embed] Parameters Name Type Value Notes *stream string The stream ID embed string Responses Status Code Description Samples 200 OK"
  },
  "http-api/swagger/Update stream metadata.html": {
    "href": "http-api/swagger/Update stream metadata.html",
    "title": "Update stream metadata | Event Store",
    "keywords": "Update stream metadata Update the metadata of a stream. Request POST /streams/{stream}/metadata Parameters Name Type Value Notes *stream string The name of the stream streamMetadataItem object Name Type Notes eventId string Alphanumeric ID eventType string The type of event data Metadata object Responses Status Code Description Samples 201 New stream created 400 Bad request"
  },
  "http-api/swagger/Get all events.html": {
    "href": "http-api/swagger/Get all events.html",
    "title": "Get all events | Event Store",
    "keywords": "Get all events Returns all events from all streams, you must provide user details. Request GET /streams/$all[?embed] Parameters Name Type Value Notes embed string Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Get all subscriptions.html": {
    "href": "http-api/swagger/Get all subscriptions.html",
    "title": "Get all subscriptions | Event Store",
    "keywords": "Get all subscriptions Returns all subscriptions from all streams. Request GET /subscriptions Responses Status Code Description Samples 200 New persistant subscription 400 bad input parameter"
  },
  "http-api/swagger/Get subscription stream information.html": {
    "href": "http-api/swagger/Get subscription stream information.html",
    "title": "Get subscription stream information | Event Store",
    "keywords": "Get subscription stream information Needed Request GET /subscriptions/{stream} Parameters Name Type Value Notes *stream string The stream name Responses Status Code Description Samples 200 OK"
  },
  "http-api/swagger/Get subscription information.html": {
    "href": "http-api/swagger/Get subscription information.html",
    "title": "Get subscription information | Event Store",
    "keywords": "Get subscription information Needed Request GET /subscriptions/{stream}/{subscription}/info Parameters Name Type Value Notes *stream string The stream the persistent subscription is on *subscription string The name of the subscription group Responses Status Code Description Samples 200 OK"
  },
  "http-api/swagger/Get a stream.html": {
    "href": "http-api/swagger/Get a stream.html",
    "title": "Get a stream | Event Store",
    "keywords": "Get a stream Read a specified stream by a persistent subscription. Request GET /subscriptions/{stream}/{subscription}[?embed] Parameters Name Type Value Notes *stream string The stream the persistent subscription is on *subscription string The name of the subscription group embed string Needed Responses Status Code Description Samples 200 OK"
  },
  "http-api/swagger/Update subscription.html": {
    "href": "http-api/swagger/Update subscription.html",
    "title": "Update subscription | Event Store",
    "keywords": "Update subscription You can edit the settings of an existing subscription while it is running. This will drop the current subscribers and will reset the subscription internally. Request POST /subscriptions/{stream}/{subscription} Parameters Name Type Value Notes *stream string The stream the persistent subscription is on *subscription string The name of the subscription group subscriptionItem object Name Type Notes ResolveLinkTos boolean Whether to resolve link events startFrom integer Which event position in the stream the subscription should start from extraStatistics boolean Whether to track latency statistics on this subscription checkPointAfterMilliseconds integer The amount of time to try to checkpoint after liveBufferSize integer The size of the buffer (in-memory) listening to live messages as they happen before paging occurs readBatchSize integer The number of events to read per batch when reading the history bufferSize integer The number of events to cache when paging through history maxCheckPointCount integer The maximum number of messages not checkpointed before forcing a checkpoint maxRetryCount integer The maximum number of retries (due to timeout) before a message is considered to be parked maxSubscriberCount integer The maximum number of TCP subscribers allowed messageTimeoutMilliseconds integer The amount of time after which to consider a message as timedout and retried minCheckPointCount integer The minimum number of messages to write to a checkpoint namedConsumerStrategy string The strategy to use for distributing events to client consumers Subscription to create Responses Status Code Description Samples 200 Subscription updated"
  },
  "http-api/swagger/Create subscription.html": {
    "href": "http-api/swagger/Create subscription.html",
    "title": "Create subscription | Event Store",
    "keywords": "Create subscription Before interacting with a subscription group, you need to create one. You will receive an error if you attempt to create a subscription group more than once. This requires admin permissions . Request PUT /subscriptions/{stream}/{subscription} Parameters Name Type Value Notes *stream string The stream the persistent subscription is on *subscription string The name of the subscription group subscriptionItem object Name Type Notes ResolveLinkTos boolean Whether to resolve link events startFrom integer Which event position in the stream the subscription should start from extraStatistics boolean Whether to track latency statistics on this subscription checkPointAfterMilliseconds integer The amount of time to try to checkpoint after liveBufferSize integer The size of the buffer (in-memory) listening to live messages as they happen before paging occurs readBatchSize integer The number of events to read per batch when reading the history bufferSize integer The number of events to cache when paging through history maxCheckPointCount integer The maximum number of messages not checkpointed before forcing a checkpoint maxRetryCount integer The maximum number of retries (due to timeout) before a message is considered to be parked maxSubscriberCount integer The maximum number of TCP subscribers allowed messageTimeoutMilliseconds integer The amount of time after which to consider a message as timedout and retried minCheckPointCount integer The minimum number of messages to write to a checkpoint namedConsumerStrategy string The strategy to use for distributing events to client consumers Subscription to create Responses Status Code Description Samples 200 Subscription created"
  },
  "http-api/swagger/Delete subscription.html": {
    "href": "http-api/swagger/Delete subscription.html",
    "title": "Delete subscription | Event Store",
    "keywords": "Delete subscription Deletes a subscription Request DELETE /subscriptions/{stream}/{subscription} Parameters Name Type Value Notes *stream string The stream the persistent subscription is on *subscription string The name of the subscription group Responses Status Code Description Samples 200 OK"
  },
  "http-api/swagger/Get {n} subscription events.html": {
    "href": "http-api/swagger/Get {n} subscription events.html",
    "title": "Get {n} subscription events | Event Store",
    "keywords": "Get {n} subscription events Reads a stream via a persistent subscription and return a specific number of events Request GET /subscriptions/{stream}/{subscription}/{count}[?embed] Parameters Name Type Value Notes *stream string The stream the persistent subscription is on *subscription string The name of the subscription group *count integer How many events to return for the request. embed string Responses Status Code Description Samples 200 OK"
  },
  "http-api/swagger/Acknowledge a single message.html": {
    "href": "http-api/swagger/Acknowledge a single message.html",
    "title": "Acknowledge a single message | Event Store",
    "keywords": "Acknowledge a single message Clients must acknowledge (or not acknowledge) messages in the competing consumer model. If the client fails to respond in the given timeout period, the message will be retried. You should use the rel links in the feed for acknowledgements not bookmark URIs as they are subject to change in future versions. Request POST /subscriptions/{stream}/{subscription}/ack/{messageid} Parameters Name Type Value Notes *stream string The stream the persistent subscription is on *subscription string The name of the subscription group *messageid string The id of the message that needs to be acked Responses Status Code Description Samples 200 New persistant subscription 400 bad input parameter"
  },
  "http-api/swagger/Acknowledge multiple messages.html": {
    "href": "http-api/swagger/Acknowledge multiple messages.html",
    "title": "Acknowledge multiple messages | Event Store",
    "keywords": "Acknowledge multiple messages Clients must acknowledge (or not acknowledge) messages in the competing consumer model. If the client fails to respond in the given timeout period, the message will be retried. You should use the rel links in the feed for acknowledgements not bookmark URIs as they are subject to change in future versions. Request POST /subscriptions/{stream}/{subscription}/ack[?ids] Parameters Name Type Value Notes *stream string The stream the persistent subscription is on *subscription string The name of the subscription group ids string The ids of the messages that need to be acked separated by commas Responses Status Code Description Samples 200 New persistant subscription 400 bad input parameter"
  },
  "http-api/swagger/Don't acknowledge a single message.html": {
    "href": "http-api/swagger/Don't acknowledge a single message.html",
    "title": "Don't acknowledge a single message | Event Store",
    "keywords": "Don't acknowledge a single message Clients must acknowledge (or not acknowledge) messages in the competing consumer model. If the client fails to respond in the given timeout period, the message will be retried. You should use the rel links in the feed for acknowledgements not bookmark URIs as they are subject to change in future versions. Request POST /subscriptions/{stream}/{subscription}/nack/{messageid}[?action] Parameters Name Type Value Notes *stream string The stream the persistent subscription is on *subscription string The name of the subscription group *messageid string The id of the message that needs to be nacked action string Park - Don't retry the message, park it until a request is sent to reply the parked messages Retry - Retry the message Skip - Discard the message Stop - Stop the subscription Responses Status Code Description Samples 200 New persistant subscription 400 bad input parameter"
  },
  "http-api/swagger/Don't acknowledge multiple messages.html": {
    "href": "http-api/swagger/Don't acknowledge multiple messages.html",
    "title": "Don't acknowledge multiple messages | Event Store",
    "keywords": "Don't acknowledge multiple messages Clients must acknowledge (or not acknowledge) messages in the competing consumer model. If the client fails to respond in the given timeout period, the message will be retried. You should use the rel links in the feed for acknowledgements not bookmark URIs as they are subject to change in future versions. Request POST /subscriptions/{stream}/{subscription}/nack[?ids&action] Parameters Name Type Value Notes *stream string The stream the persistent subscription is on *subscription string The name of the subscription group ids string The ids of the messages that need to be nacked separated by commas action string Park - Don't retry the message, park it until a request is sent to reply the parked messages Retry - Retry the message Skip - Discard the message Stop - Stop the subscription Responses Status Code Description Samples 200 New persistant subscription 400 bad input parameter"
  },
  "http-api/swagger/Replay previously parked messages.html": {
    "href": "http-api/swagger/Replay previously parked messages.html",
    "title": "Replay previously parked messages | Event Store",
    "keywords": "Replay previously parked messages Replay any previously parked messages in a stream that were parked by a negative acknowledgement action. Request POST /subscriptions/{stream}/{subscription}/replayParked Parameters Name Type Value Notes *stream string The stream the persistent subscription is on *subscription string The name of the subscription group Responses Status Code Description Samples 200 OK"
  },
  "http-api/swagger/Get all users.html": {
    "href": "http-api/swagger/Get all users.html",
    "title": "Get all users | Event Store",
    "keywords": "Get all users Returns all users defined in Event Store. Request GET /users/ Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Create a user.html": {
    "href": "http-api/swagger/Create a user.html",
    "title": "Create a user | Event Store",
    "keywords": "Create a user Create a new user. Request POST /users/ Parameters Name Type Value Notes userItem object Name Type Notes LoginName string The new users login name. FullName string The full name for the new user. Groups array The groups the new user is a member of. Password string The password for the new user. User to create Responses Status Code Description Samples 201 New user created 400 Bad request 401 Unauthorized"
  },
  "http-api/swagger/Get a user.html": {
    "href": "http-api/swagger/Get a user.html",
    "title": "Get a user | Event Store",
    "keywords": "Get a user Returns the user currently authenticated with the API, or the user specified. Request GET /users/{login} Parameters Name Type Value Notes *login string The user passed to the API call. Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "dotnet-api/code/EventStore.ClientAPI.RawStreamMetadataResult.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.RawStreamMetadataResult.html",
    "title": "Struct RawStreamMetadataResult | Event Store",
    "keywords": "Struct RawStreamMetadataResult Represents stream metadata as a series of properties for system data and a byte array for user metadata. Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public struct RawStreamMetadataResult Constructors RawStreamMetadataResult(String, Boolean, Int64, Byte[]) Constructs a new instance of RawStreamMetadataResult . Declaration public RawStreamMetadataResult(string stream, bool isStreamDeleted, long metastreamVersion, byte[] streamMetadata) Parameters Type Name System.String stream System.Boolean isStreamDeleted System.Int64 metastreamVersion System.Byte [] streamMetadata Fields IsStreamDeleted True if the stream is soft-deleted. Declaration public readonly bool IsStreamDeleted Field Value Type System.Boolean MetastreamVersion The version of the metadata format. Declaration public readonly long MetastreamVersion Field Value Type System.Int64 Stream The name of the stream. Declaration public readonly string Stream Field Value Type System.String StreamMetadata A byte array containing user-specified metadata. Declaration public readonly byte[] StreamMetadata Field Value Type System.Byte []"
  },
  "dotnet-api/code/EventStore.ClientAPI.ResolvedEvent.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ResolvedEvent.html",
    "title": "Struct ResolvedEvent | Event Store",
    "keywords": "Struct ResolvedEvent A structure representing a single event or an resolved link event. Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public struct ResolvedEvent : IResolvedEvent Fields Event The event, or the resolved link event if this ResolvedEvent is a link event. Declaration public readonly RecordedEvent Event Field Value Type RecordedEvent Link The link event if this ResolvedEvent is a link event. Declaration public readonly RecordedEvent Link Field Value Type RecordedEvent OriginalPosition The logical position of the OriginalEvent . Declaration public readonly Position? OriginalPosition Field Value Type System.Nullable < Position > Properties IsResolved Indicates whether this ResolvedEvent is a resolved link event. Declaration public bool IsResolved { get; } Property Value Type System.Boolean OriginalEvent Returns the event that was read or which triggered the subscription. If this ResolvedEvent represents a link event, the Link will be the OriginalEvent , otherwise it will be the event. Declaration public RecordedEvent OriginalEvent { get; } Property Value Type RecordedEvent OriginalEventNumber The event number in the stream of the OriginalEvent . Declaration public long OriginalEventNumber { get; } Property Value Type System.Int64 OriginalStreamId The stream name of the OriginalEvent . Declaration public string OriginalStreamId { get; } Property Value Type System.String"
  },
  "dotnet-api/code/EventStore.ClientAPI.StreamMetadataBuilder.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.StreamMetadataBuilder.html",
    "title": "Class StreamMetadataBuilder | Event Store",
    "keywords": "Class StreamMetadataBuilder Builder for StreamMetadata . Inheritance System.Object StreamMetadataBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class StreamMetadataBuilder Properties CustomPropertyKeys All existing custom property keys. Declaration public IEnumerable<string> CustomPropertyKeys { get; } Property Value Type System.Collections.Generic.IEnumerable < System.String > Remarks Returns a copy of the key list so it's safe to enumerate whilst removing custom properties. Methods Build() Builds a StreamMetadata from a StreamMetadataBuilder . Declaration public StreamMetadata Build() Returns Type Description StreamMetadata RemoveCustomProperty(String) Removes a custom property. Declaration public StreamMetadataBuilder RemoveCustomProperty(string key) Parameters Type Name System.String key Returns Type Description StreamMetadataBuilder The builder. SetCacheControl(TimeSpan) Sets the amount of time for which the stream head is cachable. Declaration public StreamMetadataBuilder SetCacheControl(TimeSpan cacheControl) Parameters Type Name System.TimeSpan cacheControl Returns Type Description StreamMetadataBuilder The builder. SetCustomProperty(String, Boolean) Sets a custom metadata property. Declaration public StreamMetadataBuilder SetCustomProperty(string key, bool value) Parameters Type Name System.String key System.Boolean value Returns Type Description StreamMetadataBuilder The builder. SetCustomProperty(String, Decimal) Sets a custom metadata property. Declaration public StreamMetadataBuilder SetCustomProperty(string key, decimal value) Parameters Type Name System.String key System.Decimal value Returns Type Description StreamMetadataBuilder The builder. SetCustomProperty(String, Double) Sets a custom metadata property. Declaration public StreamMetadataBuilder SetCustomProperty(string key, double value) Parameters Type Name System.String key System.Double value Returns Type Description StreamMetadataBuilder The builder. SetCustomProperty(String, Int32) Sets a custom metadata property. Declaration public StreamMetadataBuilder SetCustomProperty(string key, int value) Parameters Type Name System.String key System.Int32 value Returns Type Description StreamMetadataBuilder The builder. SetCustomProperty(String, Int64) Sets a custom metadata property. Declaration public StreamMetadataBuilder SetCustomProperty(string key, long value) Parameters Type Name System.String key System.Int64 value Returns Type Description StreamMetadataBuilder The builder. SetCustomProperty(String, Nullable<Boolean>) Sets a custom metadata property. Declaration public StreamMetadataBuilder SetCustomProperty(string key, bool? value) Parameters Type Name System.String key System.Nullable < System.Boolean > value Returns Type Description StreamMetadataBuilder The builder. SetCustomProperty(String, Nullable<Decimal>) Sets a custom metadata property. Declaration public StreamMetadataBuilder SetCustomProperty(string key, decimal? value) Parameters Type Name System.String key System.Nullable < System.Decimal > value Returns Type Description StreamMetadataBuilder The builder. SetCustomProperty(String, Nullable<Double>) Sets a custom metadata property. Declaration public StreamMetadataBuilder SetCustomProperty(string key, double? value) Parameters Type Name System.String key System.Nullable < System.Double > value Returns Type Description StreamMetadataBuilder The builder. SetCustomProperty(String, Nullable<Int32>) Sets a custom metadata property. Declaration public StreamMetadataBuilder SetCustomProperty(string key, int? value) Parameters Type Name System.String key System.Nullable < System.Int32 > value Returns Type Description StreamMetadataBuilder The builder. SetCustomProperty(String, Nullable<Int64>) Sets a custom metadata property. Declaration public StreamMetadataBuilder SetCustomProperty(string key, long? value) Parameters Type Name System.String key System.Nullable < System.Int64 > value Returns Type Description StreamMetadataBuilder The builder. SetCustomProperty(String, Nullable<Single>) Sets a custom metadata property. Declaration public StreamMetadataBuilder SetCustomProperty(string key, float? value) Parameters Type Name System.String key System.Nullable < System.Single > value Returns Type Description StreamMetadataBuilder The builder. SetCustomProperty(String, Single) Sets a custom metadata property. Declaration public StreamMetadataBuilder SetCustomProperty(string key, float value) Parameters Type Name System.String key System.Single value Returns Type Description StreamMetadataBuilder The builder. SetCustomProperty(String, String) Sets a custom metadata property. Declaration public StreamMetadataBuilder SetCustomProperty(string key, string value) Parameters Type Name System.String key System.String value Returns Type Description StreamMetadataBuilder The builder. SetCustomPropertyWithValueAsRawJsonString(String, String) Sets a custom metadata property to a string of raw JSON. Declaration public StreamMetadataBuilder SetCustomPropertyWithValueAsRawJsonString(string key, string rawJson) Parameters Type Name System.String key System.String rawJson Returns Type Description StreamMetadataBuilder The builder. SetDeleteRole(String) Sets a single role name with delete permission for the stream. Declaration public StreamMetadataBuilder SetDeleteRole(string role) Parameters Type Name System.String role Returns Type Description StreamMetadataBuilder The builder. SetDeleteRoles(String[]) Sets role names with delete permission for the stream. Declaration public StreamMetadataBuilder SetDeleteRoles(string[] roles) Parameters Type Name System.String [] roles Returns Type Description StreamMetadataBuilder The builder. SetMaxAge(TimeSpan) Sets the maximum age of events allowed in the stream. Declaration public StreamMetadataBuilder SetMaxAge(TimeSpan maxAge) Parameters Type Name System.TimeSpan maxAge Returns Type Description StreamMetadataBuilder The builder. SetMaxCount(Int64) Sets the maximum number of events allowed in the stream. Declaration public StreamMetadataBuilder SetMaxCount(long maxCount) Parameters Type Name System.Int64 maxCount Returns Type Description StreamMetadataBuilder The builder. SetMetadataReadRole(String) Sets a single role name with metadata read permission for the stream. Declaration public StreamMetadataBuilder SetMetadataReadRole(string role) Parameters Type Name System.String role Returns Type Description StreamMetadataBuilder The builder. SetMetadataReadRoles(String[]) Sets role names with metadata read permission for the stream. Declaration public StreamMetadataBuilder SetMetadataReadRoles(string[] roles) Parameters Type Name System.String [] roles Returns Type Description StreamMetadataBuilder The builder. SetMetadataWriteRole(String) Sets a single role name with metadata write permission for the stream. Declaration public StreamMetadataBuilder SetMetadataWriteRole(string role) Parameters Type Name System.String role Returns Type Description StreamMetadataBuilder The builder. SetMetadataWriteRoles(String[]) Sets role names with metadata write permission for the stream. Declaration public StreamMetadataBuilder SetMetadataWriteRoles(string[] roles) Parameters Type Name System.String [] roles Returns Type Description StreamMetadataBuilder The builder. SetReadRole(String) Sets a single role name with read permission for the stream. Declaration public StreamMetadataBuilder SetReadRole(string role) Parameters Type Name System.String role Returns Type Description StreamMetadataBuilder The builder. SetReadRoles(String[]) Sets role names with read permission for the stream. Declaration public StreamMetadataBuilder SetReadRoles(string[] roles) Parameters Type Name System.String [] roles Returns Type Description StreamMetadataBuilder The builder. SetTruncateBefore(Int64) Sets the event number from which previous events can be scavenged. Declaration public StreamMetadataBuilder SetTruncateBefore(long truncateBefore) Parameters Type Name System.Int64 truncateBefore Returns Type Description StreamMetadataBuilder The builder. SetWriteRole(String) Sets a single role name with write permission for the stream. Declaration public StreamMetadataBuilder SetWriteRole(string role) Parameters Type Name System.String role Returns Type Description StreamMetadataBuilder The builder. SetWriteRoles(String[]) Sets role names with write permission for the stream. Declaration public StreamMetadataBuilder SetWriteRoles(string[] roles) Parameters Type Name System.String [] roles Returns Type Description StreamMetadataBuilder The builder. Operators Implicit(StreamMetadataBuilder to StreamMetadata) Builds a StreamMetadata from a StreamMetadataBuilder . Declaration public static implicit operator StreamMetadata(StreamMetadataBuilder builder) Parameters Type Name StreamMetadataBuilder builder Returns Type Description StreamMetadata A StreamMetadata ."
  },
  "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptions.PersistentSubscriptionsManager.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptions.PersistentSubscriptionsManager.html",
    "title": "Class PersistentSubscriptionsManager | Event Store",
    "keywords": "Class PersistentSubscriptionsManager API for managing persistent subscriptions in Event Store through C# code. Communicates with Event Store over the RESTful API. Inheritance System.Object PersistentSubscriptionsManager Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.PersistentSubscriptions Assembly : EventStore.ClientAPI.dll Syntax public class PersistentSubscriptionsManager Constructors PersistentSubscriptionsManager(ILogger, EndPoint, TimeSpan, String) Creates a new instance of PersistentSubscriptionsManager . Declaration public PersistentSubscriptionsManager(ILogger log, EndPoint httpEndPoint, TimeSpan operationTimeout, string httpSchema = \"http\") Parameters Type Name ILogger log System.Net.EndPoint httpEndPoint System.TimeSpan operationTimeout System.String httpSchema Methods Describe(String, String, UserCredentials) Gets the details of the persistent subscription subscriptionName on stream . Declaration public Task<PersistentSubscriptionDetails> Describe(string stream, string subscriptionName, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.String subscriptionName UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < PersistentSubscriptionDetails > A PersistentSubscriptionDetails object representing the persistent subscription subscriptionName on stream . List(UserCredentials) Asynchronously lists all persistent subscriptions. Declaration public Task<List<PersistentSubscriptionDetails>> List(UserCredentials userCredentials = null) Parameters Type Name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < System.Collections.Generic.List < PersistentSubscriptionDetails >> List of all the PersistentSubscriptionDetails items containing persistent subscription details. List(String, UserCredentials) Asynchronously lists all persistent subscriptions subscribed to stream . Declaration public Task<List<PersistentSubscriptionDetails>> List(string stream, UserCredentials userCredentials = null) Parameters Type Name System.String stream UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < System.Collections.Generic.List < PersistentSubscriptionDetails >> List of all the PersistentSubscriptionDetails items containing persistent subscription details on stream . ReplayParkedMessages(String, String, UserCredentials) Replays all parked messages for a particular persistent subscription subscriptionName on stream . Declaration public Task ReplayParkedMessages(string stream, string subscriptionName, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.String subscriptionName UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A task representing the operation."
  },
  "dotnet-api/code/EventStore.ClientAPI.EventStoreStreamCatchUpSubscription.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.EventStoreStreamCatchUpSubscription.html",
    "title": "Class EventStoreStreamCatchUpSubscription | Event Store",
    "keywords": "Class EventStoreStreamCatchUpSubscription A catch-up subscription to a single stream in the Event Store. Inheritance System.Object EventStoreCatchUpSubscription EventStoreStreamCatchUpSubscription Inherited Members EventStoreCatchUpSubscription.IsSubscribedToAll EventStoreCatchUpSubscription.StreamId EventStoreCatchUpSubscription.SubscriptionName EventStoreCatchUpSubscription.Log EventStoreCatchUpSubscription.ReadBatchSize EventStoreCatchUpSubscription.MaxPushQueueSize EventStoreCatchUpSubscription.EventAppeared EventStoreCatchUpSubscription.Verbose EventStoreCatchUpSubscription.ShouldStop EventStoreCatchUpSubscription.Stop(TimeSpan) EventStoreCatchUpSubscription.Stop() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class EventStoreStreamCatchUpSubscription : EventStoreCatchUpSubscription Properties LastProcessedEventNumber The last event number processed on the subscription. Declaration public long LastProcessedEventNumber { get; } Property Value Type System.Int64 Methods ReadEventsTillAsync(IEventStoreConnection, Boolean, UserCredentials, Nullable<Int64>, Nullable<Int64>) Read events until the given event number async. Declaration protected override Task ReadEventsTillAsync(IEventStoreConnection connection, bool resolveLinkTos, UserCredentials userCredentials, long? lastCommitPosition, long? lastEventNumber) Parameters Type Name IEventStoreConnection connection System.Boolean resolveLinkTos UserCredentials userCredentials System.Nullable < System.Int64 > lastCommitPosition System.Nullable < System.Int64 > lastEventNumber Returns Type Description System.Threading.Tasks.Task Overrides EventStoreCatchUpSubscription.ReadEventsTillAsync(IEventStoreConnection, Boolean, UserCredentials, Nullable<Int64>, Nullable<Int64>) TryProcessAsync(ResolvedEvent) Try to process a single ResolvedEvent . Declaration protected override Task TryProcessAsync(ResolvedEvent e) Parameters Type Name ResolvedEvent e Returns Type Description System.Threading.Tasks.Task Overrides EventStoreCatchUpSubscription.TryProcessAsync(ResolvedEvent)"
  },
  "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptionSettings.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptionSettings.html",
    "title": "Class PersistentSubscriptionSettings | Event Store",
    "keywords": "Class PersistentSubscriptionSettings Represents the settings for a EventStore.ClientAPI.PersistentEventStoreSubscription . You should not use this directly, but instead created via a PersistentSubscriptionSettingsBuilder . Inheritance System.Object PersistentSubscriptionSettings Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class PersistentSubscriptionSettings Fields CheckPointAfter The amount of time to try to checkpoint after. Declaration public readonly TimeSpan CheckPointAfter Field Value Type System.TimeSpan ExtraStatistics Whether to track latency statistics on this subscription. Declaration public readonly bool ExtraStatistics Field Value Type System.Boolean HistoryBufferSize The number of events to cache when paging through history. Declaration public int HistoryBufferSize Field Value Type System.Int32 LiveBufferSize The size of the buffer (in-memory) listening to live messages as they happen before paging occurs. Declaration public int LiveBufferSize Field Value Type System.Int32 MaxCheckPointCount The maximum number of messages not checkpointed before forcing a checkpoint. Declaration public readonly int MaxCheckPointCount Field Value Type System.Int32 MaxRetryCount The maximum number of retries (due to timeout) before a message is considered to be parked. Declaration public int MaxRetryCount Field Value Type System.Int32 MaxSubscriberCount The maximum number of subscribers allowed. Declaration public readonly int MaxSubscriberCount Field Value Type System.Int32 MessageTimeout The amount of time after which to consider a message as timedout and retried. Declaration public readonly TimeSpan MessageTimeout Field Value Type System.TimeSpan MinCheckPointCount The minimum number of messages to write to a checkpoint. Declaration public readonly int MinCheckPointCount Field Value Type System.Int32 NamedConsumerStrategy The strategy to use for distributing events to client consumers. See SystemConsumerStrategies for system supported strategies. Declaration public string NamedConsumerStrategy Field Value Type System.String ReadBatchSize The number of events read at a time when paging through history. Declaration public int ReadBatchSize Field Value Type System.Int32 ResolveLinkTos Whether the EventStore.ClientAPI.PersistentEventStoreSubscription should resolve linkTo events to their linked events. Declaration public readonly bool ResolveLinkTos Field Value Type System.Boolean StartFrom Which event position in the stream the subscription should start from. Declaration public readonly long StartFrom Field Value Type System.Int64 Methods Create() Creates a new PersistentSubscriptionSettingsBuilder object Declaration public static PersistentSubscriptionSettingsBuilder Create() Returns Type Description PersistentSubscriptionSettingsBuilder a new PersistentSubscriptionSettingsBuilder object"
  },
  "dotnet-api/code/EventStore.ClientAPI.StreamMetadataResult.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.StreamMetadataResult.html",
    "title": "Struct StreamMetadataResult | Event Store",
    "keywords": "Struct StreamMetadataResult Represents stream metadata as a series of properties for system data and a StreamMetadata object for user metadata. Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public struct StreamMetadataResult Constructors StreamMetadataResult(String, Boolean, Int64, StreamMetadata) Constructs a new instance of StreamMetadataResult . Declaration public StreamMetadataResult(string stream, bool isStreamDeleted, long metastreamVersion, StreamMetadata streamMetadata) Parameters Type Name System.String stream System.Boolean isStreamDeleted System.Int64 metastreamVersion StreamMetadata streamMetadata Fields IsStreamDeleted True if the stream is soft-deleted. Declaration public readonly bool IsStreamDeleted Field Value Type System.Boolean MetastreamVersion The version of the metadata format. Declaration public readonly long MetastreamVersion Field Value Type System.Int64 Stream The name of the stream. Declaration public readonly string Stream Field Value Type System.String StreamMetadata A StreamMetadata containing user-specified metadata. Declaration public readonly StreamMetadata StreamMetadata Field Value Type StreamMetadata"
  },
  "dotnet-api/code/EventStore.ClientAPI.EventData.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.EventData.html",
    "title": "Class EventData | Event Store",
    "keywords": "Class EventData Represents an event to be written. Inheritance System.Object EventData Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public sealed class EventData Constructors EventData(Guid, String, Boolean, Byte[], Byte[]) Constructs a new EventData . Declaration public EventData(Guid eventId, string type, bool isJson, byte[] data, byte[] metadata) Parameters Type Name System.Guid eventId System.String type System.Boolean isJson System.Byte [] data System.Byte [] metadata Fields Data The raw bytes of the event data. Declaration public readonly byte[] Data Field Value Type System.Byte [] EventId The ID of the event, used as part of the idempotent write check. Declaration public readonly Guid EventId Field Value Type System.Guid IsJson Flag indicating whether the data and metadata are JSON. Declaration public readonly bool IsJson Field Value Type System.Boolean Metadata The raw bytes of the event metadata. Declaration public readonly byte[] Metadata Field Value Type System.Byte [] Type The name of the event type. It is strongly recommended that these use lowerCamelCase if projections are to be used. Declaration public readonly string Type Field Value Type System.String"
  },
  "dotnet-api/code/EventStore.ClientAPI.Common.SystemEventTypes.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Common.SystemEventTypes.html",
    "title": "Class SystemEventTypes | Event Store",
    "keywords": "Class SystemEventTypes Constants for System event types Inheritance System.Object SystemEventTypes Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.Common Assembly : EventStore.ClientAPI.dll Syntax public static class SystemEventTypes Fields LinkTo event type for linkTo Declaration public const string LinkTo = \"$>\" Field Value Type System.String Settings event type for the system settings Declaration public const string Settings = \"$settings\" Field Value Type System.String StatsCollection event type for statistics Declaration public const string StatsCollection = \"$statsCollected\" Field Value Type System.String StreamDeleted event type for stream deleted Declaration public const string StreamDeleted = \"$streamDeleted\" Field Value Type System.String StreamMetadata event type for stream metadata Declaration public const string StreamMetadata = \"$metadata\" Field Value Type System.String"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.ClusterException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.ClusterException.html",
    "title": "Class ClusterException | Event Store",
    "keywords": "Class ClusterException Exception thrown if cluster discovery fails. Inheritance System.Object System.Exception EventStoreConnectionException ClusterException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class ClusterException : EventStoreConnectionException, ISerializable Constructors ClusterException() Constructs a new ClusterException . Declaration public ClusterException() ClusterException(SerializationInfo, StreamingContext) Constructs a new ClusterException . Declaration protected ClusterException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context ClusterException(String) Constructs a new ClusterException . Declaration public ClusterException(string message) Parameters Type Name System.String message ClusterException(String, Exception) Constructs a new ClusterException . Declaration public ClusterException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.ClientOperations.PersistentSubscriptionDeletedException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ClientOperations.PersistentSubscriptionDeletedException.html",
    "title": "Class PersistentSubscriptionDeletedException | Event Store",
    "keywords": "Class PersistentSubscriptionDeletedException Thrown when the persistent subscription has been deleted to subscribers connected to it Inheritance System.Object System.Exception PersistentSubscriptionDeletedException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.ClientOperations Assembly : EventStore.ClientAPI.dll Syntax public class PersistentSubscriptionDeletedException : Exception, ISerializable Constructors PersistentSubscriptionDeletedException() Constructs a PersistentSubscriptionDeletedException Declaration public PersistentSubscriptionDeletedException() Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptionSettingsBuilder.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptionSettingsBuilder.html",
    "title": "Class PersistentSubscriptionSettingsBuilder | Event Store",
    "keywords": "Class PersistentSubscriptionSettingsBuilder Builds a PersistentSubscriptionSettings object. Inheritance System.Object PersistentSubscriptionSettingsBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class PersistentSubscriptionSettingsBuilder Methods Build() Builds a PersistentSubscriptionSettings object from a PersistentSubscriptionSettingsBuilder . Declaration public PersistentSubscriptionSettings Build() Returns Type Description PersistentSubscriptionSettings CheckPointAfter(TimeSpan) Sets that the backend should try to checkpoint the subscription after some period of time. Note that if the increment of the checkpoint would be below the minimum the stream will not be checkpointed at this time. Declaration public PersistentSubscriptionSettingsBuilder CheckPointAfter(TimeSpan time) Parameters Type Name System.TimeSpan time Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder Remarks It is important to tweak checkpointing for high performance streams as they cause writes to happen back in the system. There is a trade off between the number of writes that can happen in varying failure scenarios and the frequency of writing out the checkpoints within the system. Normally settings such as once per second with a minimum of 5-10 messages and a high max to checkpoint should be a good compromise for most streams though you may want to change this if you for instance are doing hundreds of messages/second through the subscription. DoNotResolveLinkTos() Sets the option to not resolve linktos on events that are found for this subscription. Declaration public PersistentSubscriptionSettingsBuilder DoNotResolveLinkTos() Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder DontTimeoutMessages() Sets the timeout timespan to about 30k years. If you need larger please let us know. Declaration public PersistentSubscriptionSettingsBuilder DontTimeoutMessages() Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder MaximumCheckPointCountOf(Int32) Sets the largest increment the subscription will checkpoint. If this value is reached the subscription will immediately write a checkpoint. As such this value should normally be reasonably large so as not to cause too many writes to occur in the subscription Declaration public PersistentSubscriptionSettingsBuilder MaximumCheckPointCountOf(int count) Parameters Type Name System.Int32 count Returns Type Description PersistentSubscriptionSettingsBuilder Remarks It is important to tweak checkpointing for high performance streams as they cause writes to happen back in the system. There is a trade off between the number of writes that can happen in varying failure scenarios and the frequency of writing out the checkpoints within the system. Normally settings such as once per second with a minimum of 5-10 messages and a high max to checkpoint should be a good compromise for most streams though you may want to change this if you for instance are doing hundreds of messages/second through the subscription. MinimumCheckPointCountOf(Int32) Sets the minimum checkpoint count. The subscription will not increment a checkpoint below this value eg if there is one item to checkpoint and it is set to five it will not checkpoint Declaration public PersistentSubscriptionSettingsBuilder MinimumCheckPointCountOf(int count) Parameters Type Name System.Int32 count Returns Type Description PersistentSubscriptionSettingsBuilder Remarks It is important to tweak checkpointing for high performance streams as they cause writes to happen back in the system. There is a trade off between the number of writes that can happen in varying failure scenarios and the frequency of writing out the checkpoints within the system. Normally settings such as once per second with a minimum of 5-10 messages and a high max to checkpoint should be a good compromise for most streams though you may want to change this if you for instance are doing hundreds of messages/second through the subscription. PreferDispatchToSingle() If set the subscription will prefer if possible to dispatch only to a single of the connected clients. If however the buffer limits are reached on that client it will begin sending to other clients. Declaration public PersistentSubscriptionSettingsBuilder PreferDispatchToSingle() Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder PreferRoundRobin() If set the subscription will prefer if possible to round robin between the clients that are connected. Declaration public PersistentSubscriptionSettingsBuilder PreferRoundRobin() Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder ResolveLinkTos() Sets the option to resolve linktos on events that are found for this subscription. Declaration public PersistentSubscriptionSettingsBuilder ResolveLinkTos() Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder StartFrom(Int64) Sets that the subscription should start from a specified location of the stream. Declaration public PersistentSubscriptionSettingsBuilder StartFrom(long position) Parameters Type Name System.Int64 position Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder StartFromBeginning() Sets that the subscription should start from the beginning of the stream. Declaration public PersistentSubscriptionSettingsBuilder StartFromBeginning() Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder StartFromCurrent() Sets that the subscription should start from where the stream is when the subscription is first connected. Declaration public PersistentSubscriptionSettingsBuilder StartFromCurrent() Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder WithBufferSizeOf(Int32) Sets the size of the read batch used when paging in history for the subscription sizes should not be too big ... Declaration public PersistentSubscriptionSettingsBuilder WithBufferSizeOf(int count) Parameters Type Name System.Int32 count Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder WithExtraStatistics() Sets the option to include further latency statistics. These statistics have a cost and should not be used in high performance situations. Declaration public PersistentSubscriptionSettingsBuilder WithExtraStatistics() Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder WithLiveBufferSizeOf(Int32) Sets the size of the live buffer for the subscription. This is the buffer used to cache messages while sending messages as they happen. The count is in terms of the number of messages to cache. Declaration public PersistentSubscriptionSettingsBuilder WithLiveBufferSizeOf(int count) Parameters Type Name System.Int32 count Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder WithMaxRetriesOf(Int32) Sets the number of times a message should be retried before being considered a bad message Declaration public PersistentSubscriptionSettingsBuilder WithMaxRetriesOf(int count) Parameters Type Name System.Int32 count Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder WithMaxSubscriberCountOf(Int32) Sets the maximum number of subscribers allowed to connect. Declaration public PersistentSubscriptionSettingsBuilder WithMaxSubscriberCountOf(int count) Parameters Type Name System.Int32 count Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder WithMessageTimeoutOf(TimeSpan) Sets the timeout for a message (will be retried if an ack is not received within this timespan) Declaration public PersistentSubscriptionSettingsBuilder WithMessageTimeoutOf(TimeSpan timeout) Parameters Type Name System.TimeSpan timeout Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder WithNamedConsumerStrategy(String) Sets the consumer strategy for distributing event to clients. See SystemConsumerStrategies for system supported strategies. Declaration public PersistentSubscriptionSettingsBuilder WithNamedConsumerStrategy(string namedConsumerStrategy) Parameters Type Name System.String namedConsumerStrategy Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder WithReadBatchOf(Int32) Sets the size of the read batch used when paging in history for the subscription sizes should not be too big ... Declaration public PersistentSubscriptionSettingsBuilder WithReadBatchOf(int count) Parameters Type Name System.Int32 count Returns Type Description PersistentSubscriptionSettingsBuilder A new PersistentSubscriptionSettingsBuilder Operators Implicit(PersistentSubscriptionSettingsBuilder to PersistentSubscriptionSettings) Builds a PersistentSubscriptionSettings object from a PersistentSubscriptionSettingsBuilder . Declaration public static implicit operator PersistentSubscriptionSettings(PersistentSubscriptionSettingsBuilder builder) Parameters Type Name PersistentSubscriptionSettingsBuilder builder Returns Type Description PersistentSubscriptionSettings"
  },
  "dotnet-api/code/EventStore.ClientAPI.ClientAuthenticationFailedEventArgs.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ClientAuthenticationFailedEventArgs.html",
    "title": "Class ClientAuthenticationFailedEventArgs | Event Store",
    "keywords": "Class ClientAuthenticationFailedEventArgs Event Arguments for the event raised when an IEventStoreConnection fails to authenticate against an Event Store server. Inheritance System.Object System.EventArgs ClientAuthenticationFailedEventArgs Inherited Members System.EventArgs.Empty System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class ClientAuthenticationFailedEventArgs : EventArgs Constructors ClientAuthenticationFailedEventArgs(IEventStoreConnection, String) Constructs a new instance of ClientAuthenticationFailedEventArgs . Declaration public ClientAuthenticationFailedEventArgs(IEventStoreConnection connection, string reason) Parameters Type Name IEventStoreConnection connection System.String reason Properties Connection The IEventStoreConnection responsible for raising the event. Declaration public IEventStoreConnection Connection { get; } Property Value Type IEventStoreConnection Reason A reason for authentication failure, if known. Declaration public string Reason { get; } Property Value Type System.String"
  },
  "dotnet-api/code/EventStore.ClientAPI.Projections.QueryManager.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Projections.QueryManager.html",
    "title": "Class QueryManager | Event Store",
    "keywords": "Class QueryManager API for executing queries in the Event Store through C# code. Communicates with the Event Store over the RESTful API. Inheritance System.Object QueryManager Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.Projections Assembly : EventStore.ClientAPI.dll Syntax public class QueryManager Constructors QueryManager(ILogger, EndPoint, TimeSpan, TimeSpan, IHttpClient) Creates a new instance of QueryManager . Declaration public QueryManager(ILogger log, EndPoint httpEndPoint, TimeSpan projectionOperationTimeout, TimeSpan queryTimeout, IHttpClient client = null) Parameters Type Name ILogger log System.Net.EndPoint httpEndPoint System.TimeSpan projectionOperationTimeout System.TimeSpan queryTimeout IHttpClient client Methods ExecuteAsync(String, String, TimeSpan, TimeSpan, UserCredentials) Asynchronously executes a query. Declaration public Task<string> ExecuteAsync(string name, string query, TimeSpan initialPollingDelay, TimeSpan maximumPollingDelay, UserCredentials userCredentials = null) Parameters Type Name System.String name System.String query System.TimeSpan initialPollingDelay System.TimeSpan maximumPollingDelay UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < System.String > String of JSON containing query result. Remarks Creates a new transient projection and polls its status until it is Completed."
  },
  "dotnet-api/code/EventStore.ClientAPI.Common.SystemMetadata.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Common.SystemMetadata.html",
    "title": "Class SystemMetadata | Event Store",
    "keywords": "Class SystemMetadata Constants for information in stream metadata Inheritance System.Object SystemMetadata Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.Common Assembly : EventStore.ClientAPI.dll Syntax public static class SystemMetadata Fields Acl The acl definition in metadata Declaration public const string Acl = \"$acl\" Field Value Type System.String AclDelete to delete a stream Declaration public const string AclDelete = \"$d\" Field Value Type System.String AclMetaRead to read metadata Declaration public const string AclMetaRead = \"$mr\" Field Value Type System.String AclMetaWrite to write metadata Declaration public const string AclMetaWrite = \"$mw\" Field Value Type System.String AclRead to read from a stream Declaration public const string AclRead = \"$r\" Field Value Type System.String AclWrite to write to a stream Declaration public const string AclWrite = \"$w\" Field Value Type System.String CacheControl Sets the cache control in seconds for the head of the stream. Declaration public const string CacheControl = \"$cacheControl\" Field Value Type System.String MaxAge The definition of the MaxAge value assigned to stream metadata Setting this allows all events older than the limit to be deleted Declaration public const string MaxAge = \"$maxAge\" Field Value Type System.String MaxCount The definition of the MaxCount value assigned to stream metadata setting this allows all events with a sequence less than current -maxcount to be deleted Declaration public const string MaxCount = \"$maxCount\" Field Value Type System.String SystemStreamAcl the system stream defaults acl stream Declaration public const string SystemStreamAcl = \"$systemStreamAcl\" Field Value Type System.String TruncateBefore The definition of the Truncate Before value assigned to stream metadata setting this allows all events prior to the integer value to be deleted Declaration public const string TruncateBefore = \"$tb\" Field Value Type System.String UserStreamAcl The user default acl stream Declaration public const string UserStreamAcl = \"$userStreamAcl\" Field Value Type System.String"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.PersistentSubscriptionCommandFailedException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.PersistentSubscriptionCommandFailedException.html",
    "title": "Class PersistentSubscriptionCommandFailedException | Event Store",
    "keywords": "Class PersistentSubscriptionCommandFailedException Exception thrown if a persistent subscription command fails. Inheritance System.Object System.Exception EventStoreConnectionException PersistentSubscriptionCommandFailedException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class PersistentSubscriptionCommandFailedException : EventStoreConnectionException, ISerializable Constructors PersistentSubscriptionCommandFailedException() Constructs a new PersistentSubscriptionCommandFailedException . Declaration public PersistentSubscriptionCommandFailedException() PersistentSubscriptionCommandFailedException(Int32, String) Constructs a new PersistentSubscriptionCommandFailedException . Declaration public PersistentSubscriptionCommandFailedException(int httpStatusCode, string message) Parameters Type Name System.Int32 httpStatusCode System.String message PersistentSubscriptionCommandFailedException(String, Exception) Constructs a new PersistentSubscriptionCommandFailedException . Declaration public PersistentSubscriptionCommandFailedException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Properties HttpStatusCode The HTTP status code returned by the server. Declaration public int HttpStatusCode { get; } Property Value Type System.Int32 Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.CannotEstablishConnectionException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.CannotEstablishConnectionException.html",
    "title": "Class CannotEstablishConnectionException | Event Store",
    "keywords": "Class CannotEstablishConnectionException Exception thrown if an EventStoreConnection is unable to establish a connection to an Event Store server. Inheritance System.Object System.Exception EventStoreConnectionException CannotEstablishConnectionException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class CannotEstablishConnectionException : EventStoreConnectionException, ISerializable Constructors CannotEstablishConnectionException() Constructs a new CannotEstablishConnectionException . Declaration public CannotEstablishConnectionException() CannotEstablishConnectionException(SerializationInfo, StreamingContext) Constructs a new CannotEstablishConnectionException . Declaration protected CannotEstablishConnectionException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context CannotEstablishConnectionException(String) Constructs a new CannotEstablishConnectionException . Declaration public CannotEstablishConnectionException(string message) Parameters Type Name System.String message CannotEstablishConnectionException(String, Exception) Constructs a new CannotEstablishConnectionException . Declaration public CannotEstablishConnectionException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.Common.SystemConsumerStrategies.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Common.SystemConsumerStrategies.html",
    "title": "Class SystemConsumerStrategies | Event Store",
    "keywords": "Class SystemConsumerStrategies System supported consumer strategies for use with persistent subscriptions. Inheritance System.Object SystemConsumerStrategies Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.Common Assembly : EventStore.ClientAPI.dll Syntax public static class SystemConsumerStrategies Fields DispatchToSingle Distributes events to a single client until it is full. Then round robin to the next client. Declaration public const string DispatchToSingle = \"DispatchToSingle\" Field Value Type System.String Pinned Distribute events of the same streamId to the same client until it disconnects on a best efforts basis. Designed to be used with indexes such as the category projection. Declaration public const string Pinned = \"Pinned\" Field Value Type System.String RoundRobin Distribute events to each client in a round robin fashion. Declaration public const string RoundRobin = \"RoundRobin\" Field Value Type System.String"
  },
  "dotnet-api/code/EventStore.ClientAPI.IEventStoreConnection.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.IEventStoreConnection.html",
    "title": "Interface IEventStoreConnection | Event Store",
    "keywords": "Interface IEventStoreConnection Maintains a full duplex connection to Event Store. Inherited Members System.IDisposable.Dispose() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public interface IEventStoreConnection : IDisposable Remarks An IEventStoreConnection operates differently than a SqlConnection. Normally when using an IEventStoreConnection you want to keep the connection open for a much longer of time than when you use a SqlConnection. If you prefer the usage pattern of using(new Connection()) .. then you would likely want to create a FlyWeight on top of the EventStoreConnection . Another difference is that with the IEventStoreConnection all operations are handled in a full async manner (even if you call the synchronous behaviors). Many threads can use an IEventStoreConnection at the same time or a single thread can make many asynchronous requests. To get the best performance out of the connection it is generally recommended to use it in this way. Properties ConnectionName Gets the name of this connection. A connection name is useful for disambiguation in log files. Declaration string ConnectionName { get; } Property Value Type System.String Settings A ConnectionSettings object is an immutable representation of the settings for an IEventStoreConnection . Declaration ConnectionSettings Settings { get; } Property Value Type ConnectionSettings Methods AppendToStreamAsync(String, Int64, EventData[]) Appends events asynchronously to a stream. Declaration Task<WriteResult> AppendToStreamAsync(string stream, long expectedVersion, params EventData[] events) Parameters Type Name System.String stream System.Int64 expectedVersion EventData [] events Returns Type Description System.Threading.Tasks.Task < WriteResult > A System.Threading.Tasks.Task<TResult> containing the results of the write operation. Remarks When appending events to a stream the ExpectedVersion choice can make a large difference in the observed behavior. For example, if no stream exists and ExpectedVersion.Any is used, a new stream will be implicitly created when appending. TODO: Link above and below? There are also differences in idempotency between different types of calls. If you specify an ExpectedVersion aside from ExpectedVersion.Any, Event Store will give you an idempotency guarantee. If using ExpectedVersion.Any, Event Store will do its best to provide idempotency but does not guarantee idempotency. AppendToStreamAsync(String, Int64, UserCredentials, EventData[]) Appends events asynchronously to a stream. Declaration Task<WriteResult> AppendToStreamAsync(string stream, long expectedVersion, UserCredentials userCredentials, params EventData[] events) Parameters Type Name System.String stream System.Int64 expectedVersion UserCredentials userCredentials EventData [] events Returns Type Description System.Threading.Tasks.Task < WriteResult > A System.Threading.Tasks.Task<TResult> containing the results of the write operation. Remarks When appending events to a stream the ExpectedVersion choice can make a large difference in the observed behavior. For example, if no stream exists and ExpectedVersion.Any is used, a new stream will be implicitly created when appending. There are also differences in idempotency between different types of calls. If you specify an ExpectedVersion aside from ExpectedVersion.Any, Event Store will give you an idempotency guarantee. If using ExpectedVersion.Any, Event Store will do its best to provide idempotency but does not guarantee idempotency. AppendToStreamAsync(String, Int64, IEnumerable<EventData>, UserCredentials) Appends events asynchronously to a stream. Declaration Task<WriteResult> AppendToStreamAsync(string stream, long expectedVersion, IEnumerable<EventData> events, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.Int64 expectedVersion System.Collections.Generic.IEnumerable < EventData > events UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < WriteResult > A System.Threading.Tasks.Task<TResult> containing the results of the write operation. Remarks When appending events to a stream the ExpectedVersion choice can make a large difference in the observed behavior. For example, if no stream exists and ExpectedVersion.Any is used, a new stream will be implicitly created when appending. There are also differences in idempotency between different types of calls. If you specify an ExpectedVersion aside from ExpectedVersion.Any, Event Store will give you an idempotency guarantee. If using ExpectedVersion.Any, Event Store will do its best to provide idempotency but does not guarantee idempotency. Close() Closes this IEventStoreConnection . Declaration void Close() ConditionalAppendToStreamAsync(String, Int64, IEnumerable<EventData>, UserCredentials) Appends events asynchronously to a stream if the stream version matches the expectedVersion . Declaration Task<ConditionalWriteResult> ConditionalAppendToStreamAsync(string stream, long expectedVersion, IEnumerable<EventData> events, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.Int64 expectedVersion System.Collections.Generic.IEnumerable < EventData > events UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < ConditionalWriteResult > A System.Threading.Tasks.Task<TResult> describing if the operation succeeded and, if not, the reason for failure (which can be either stream version mismatch or trying to write to a deleted stream). Remarks When appending events to a stream the ExpectedVersion choice can make a large difference in the observed behavior. For example, if no stream exists and ExpectedVersion.Any is used, a new stream will be implicitly created when appending. There are also differences in idempotency between different types of calls. If you specify an ExpectedVersion aside from ExpectedVersion.Any, Event Store will give you an idempotency guarantee. If using ExpectedVersion.Any, Event Store will do its best to provide idempotency but does not guarantee idempotency. ConnectAsync() Connects the IEventStoreConnection asynchronously to a destination. Declaration Task ConnectAsync() Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task to wait upon. ConnectToPersistentSubscription(String, String, Func<EventStorePersistentSubscriptionBase, ResolvedEvent, Nullable<Int32>, Task>, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception>, UserCredentials, Int32, Boolean) Subscribes to a persistent subscription (competing consumer) on an event store. Declaration EventStorePersistentSubscriptionBase ConnectToPersistentSubscription(string stream, string groupName, Func<EventStorePersistentSubscriptionBase, ResolvedEvent, int?, Task> eventAppeared, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null, int bufferSize = 10, bool autoAck = true) Parameters Type Name System.String stream System.String groupName System.Func < EventStorePersistentSubscriptionBase , ResolvedEvent , System.Nullable < System.Int32 >, System.Threading.Tasks.Task > eventAppeared System.Action < EventStorePersistentSubscriptionBase , SubscriptionDropReason , System.Exception > subscriptionDropped UserCredentials userCredentials System.Int32 bufferSize System.Boolean autoAck Returns Type Description EventStorePersistentSubscriptionBase An EventStorePersistentSubscriptionBase representing the subscription. Remarks This will connect you to a persistent subscription group for a stream. The subscription group must first be created with CreatePersistentSubscriptionAsync. Many connections can connect to the same group and they will be treated as competing consumers within the group. If one connection dies work will be balanced across the rest of the consumers in the group. If you attempt to connect to a group that does not exist you will be given an exception. ConnectToPersistentSubscriptionAsync(String, String, Func<EventStorePersistentSubscriptionBase, ResolvedEvent, Nullable<Int32>, Task>, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception>, UserCredentials, Int32, Boolean) Asynchronously subscribes to a persistent subscription (competing consumer) on an event store. Declaration Task<EventStorePersistentSubscriptionBase> ConnectToPersistentSubscriptionAsync(string stream, string groupName, Func<EventStorePersistentSubscriptionBase, ResolvedEvent, int?, Task> eventAppeared, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null, int bufferSize = 10, bool autoAck = true) Parameters Type Name System.String stream System.String groupName System.Func < EventStorePersistentSubscriptionBase , ResolvedEvent , System.Nullable < System.Int32 >, System.Threading.Tasks.Task > eventAppeared System.Action < EventStorePersistentSubscriptionBase , SubscriptionDropReason , System.Exception > subscriptionDropped UserCredentials userCredentials System.Int32 bufferSize System.Boolean autoAck Returns Type Description System.Threading.Tasks.Task < EventStorePersistentSubscriptionBase > An EventStorePersistentSubscriptionBase representing the subscription. Remarks This will connect you to a persistent subscription group for a stream. The subscription group must first be created with CreatePersistentSubscriptionAsync. Many connections can connect to the same group and they will be treated as competing consumers within the group. If one connection dies work will be balanced across the rest of the consumers in the group. If you attempt to connect to a group that does not exist you will be given an exception. ContinueTransaction(Int64, UserCredentials) Continues specified transaction. Declaration EventStoreTransaction ContinueTransaction(long transactionId, UserCredentials userCredentials = null) Parameters Type Name System.Int64 transactionId UserCredentials userCredentials Returns Type Description EventStoreTransaction A EventStoreTransaction representing a multi-request transaction. Remarks A EventStoreTransaction allows the calling of multiple writes with multiple round trips over long periods of time between the caller and the event store. This method is only available through the TCP interface and no equivalent exists for the RESTful interface. CreatePersistentSubscriptionAsync(String, String, PersistentSubscriptionSettings, UserCredentials) Asynchronously create a persistent subscription group on a stream. Declaration Task CreatePersistentSubscriptionAsync(string stream, string groupName, PersistentSubscriptionSettings settings, UserCredentials credentials) Parameters Type Name System.String stream System.String groupName PersistentSubscriptionSettings settings UserCredentials credentials Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that can be waited upon. DeletePersistentSubscriptionAsync(String, String, UserCredentials) Asynchronously delete a persistent subscription group on a stream. Declaration Task DeletePersistentSubscriptionAsync(string stream, string groupName, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.String groupName UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that can be waited upon. DeleteStreamAsync(String, Int64, UserCredentials) Deletes a stream from Event Store asynchronously. Declaration Task<DeleteResult> DeleteStreamAsync(string stream, long expectedVersion, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.Int64 expectedVersion UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < DeleteResult > A System.Threading.Tasks.Task<TResult> containing the results of the delete stream operation. DeleteStreamAsync(String, Int64, Boolean, UserCredentials) Deletes a stream from Event Store asynchronously. Declaration Task<DeleteResult> DeleteStreamAsync(string stream, long expectedVersion, bool hardDelete, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.Int64 expectedVersion System.Boolean hardDelete UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < DeleteResult > A System.Threading.Tasks.Task<TResult> containing the results of the delete stream operation. GetStreamMetadataAsRawBytesAsync(String, UserCredentials) Asynchronously reads the metadata for a stream as a byte array. Declaration Task<RawStreamMetadataResult> GetStreamMetadataAsRawBytesAsync(string stream, UserCredentials userCredentials = null) Parameters Type Name System.String stream UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < RawStreamMetadataResult > A System.Threading.Tasks.Task<TResult> representing system metadata as properties and user-specified metadata as bytes. GetStreamMetadataAsync(String, UserCredentials) Asynchronously reads the metadata for a stream and converts the metadata into a StreamMetadata . Declaration Task<StreamMetadataResult> GetStreamMetadataAsync(string stream, UserCredentials userCredentials = null) Parameters Type Name System.String stream UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < StreamMetadataResult > A System.Threading.Tasks.Task<TResult> representing system and user-specified metadata as properties. ReadAllEventsBackwardAsync(Position, Int32, Boolean, UserCredentials) Asynchronously reads all events in the node backwards (e.g. end to beginning). Declaration Task<AllEventsSlice> ReadAllEventsBackwardAsync(Position position, int maxCount, bool resolveLinkTos, UserCredentials userCredentials = null) Parameters Type Name Position position System.Int32 maxCount System.Boolean resolveLinkTos UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < AllEventsSlice > A System.Threading.Tasks.Task<TResult> containing the records read. ReadAllEventsForwardAsync(Position, Int32, Boolean, UserCredentials) Asynchronously reads all events in the node forward (e.g. beginning to end). Declaration Task<AllEventsSlice> ReadAllEventsForwardAsync(Position position, int maxCount, bool resolveLinkTos, UserCredentials userCredentials = null) Parameters Type Name Position position System.Int32 maxCount System.Boolean resolveLinkTos UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < AllEventsSlice > A System.Threading.Tasks.Task<TResult> containing the records read. ReadEventAsync(String, Int64, Boolean, UserCredentials) Asynchronously reads a single event from a stream. Declaration Task<EventReadResult> ReadEventAsync(string stream, long eventNumber, bool resolveLinkTos, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.Int64 eventNumber System.Boolean resolveLinkTos UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < EventReadResult > A System.Threading.Tasks.Task<TResult> containing the results of the read operation. ReadStreamEventsBackwardAsync(String, Int64, Int32, Boolean, UserCredentials) Asynchronously reads count events from an event stream backwards (e.g. newest to oldest) from position. Declaration Task<StreamEventsSlice> ReadStreamEventsBackwardAsync(string stream, long start, int count, bool resolveLinkTos, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.Int64 start System.Int32 count System.Boolean resolveLinkTos UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < StreamEventsSlice > A System.Threading.Tasks.Task<TResult> containing the results of the read operation. ReadStreamEventsForwardAsync(String, Int64, Int32, Boolean, UserCredentials) Asynchronously reads count events from an event stream forwards (e.g. oldest to newest) starting from position start. Declaration Task<StreamEventsSlice> ReadStreamEventsForwardAsync(string stream, long start, int count, bool resolveLinkTos, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.Int64 start System.Int32 count System.Boolean resolveLinkTos UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < StreamEventsSlice > A System.Threading.Tasks.Task<TResult> containing the results of the read operation. SetStreamMetadataAsync(String, Int64, StreamMetadata, UserCredentials) Asynchronously sets the metadata for a stream. Declaration Task<WriteResult> SetStreamMetadataAsync(string stream, long expectedMetastreamVersion, StreamMetadata metadata, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.Int64 expectedMetastreamVersion StreamMetadata metadata UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < WriteResult > A System.Threading.Tasks.Task<TResult> containing the results of the write operation. SetStreamMetadataAsync(String, Int64, Byte[], UserCredentials) Asynchronously sets the metadata for a stream. Declaration Task<WriteResult> SetStreamMetadataAsync(string stream, long expectedMetastreamVersion, byte[] metadata, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.Int64 expectedMetastreamVersion System.Byte [] metadata UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < WriteResult > A System.Threading.Tasks.Task<TResult> containing the results of the write operation. SetSystemSettingsAsync(SystemSettings, UserCredentials) Sets the global settings for the server or cluster to which the IEventStoreConnection is connected. Declaration Task SetSystemSettingsAsync(SystemSettings settings, UserCredentials userCredentials = null) Parameters Type Name SystemSettings settings UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that can be waited upon. StartTransactionAsync(String, Int64, UserCredentials) Starts an asynchronous transaction in Event Store on a given stream. Declaration Task<EventStoreTransaction> StartTransactionAsync(string stream, long expectedVersion, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.Int64 expectedVersion UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < EventStoreTransaction > A System.Threading.Tasks.Task<TResult> representing a multi-request transaction. Remarks A EventStoreTransaction allows the calling of multiple writes with multiple round trips over long periods of time between the caller and Event Store. This method is only available through the TCP interface and no equivalent exists for the RESTful interface. SubscribeToAllAsync(Boolean, Func<EventStoreSubscription, ResolvedEvent, Task>, Action<EventStoreSubscription, SubscriptionDropReason, Exception>, UserCredentials) Asynchronously subscribes to all events in Event Store. New events written to the stream while the subscription is active will be pushed to the client. Declaration Task<EventStoreSubscription> SubscribeToAllAsync(bool resolveLinkTos, Func<EventStoreSubscription, ResolvedEvent, Task> eventAppeared, Action<EventStoreSubscription, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null) Parameters Type Name System.Boolean resolveLinkTos System.Func < EventStoreSubscription , ResolvedEvent , System.Threading.Tasks.Task > eventAppeared System.Action < EventStoreSubscription , SubscriptionDropReason , System.Exception > subscriptionDropped UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < EventStoreSubscription > A System.Threading.Tasks.Task<TResult> representing the subscription. SubscribeToAllFrom(Nullable<Position>, CatchUpSubscriptionSettings, Func<EventStoreCatchUpSubscription, ResolvedEvent, Task>, Action<EventStoreCatchUpSubscription>, Action<EventStoreCatchUpSubscription, SubscriptionDropReason, Exception>, UserCredentials) Subscribes to a all events. Existing events from lastCheckpoint onwards are read from Event Store and presented to the user of EventStoreCatchUpSubscription as if they had been pushed. Once the end of the stream is read the subscription is transparently (to the user) switched to push new events as they are written. The action liveProcessingStarted is called when the EventStoreCatchUpSubscription switches from the reading phase to the live subscription phase. Declaration EventStoreAllCatchUpSubscription SubscribeToAllFrom(Position? lastCheckpoint, CatchUpSubscriptionSettings settings, Func<EventStoreCatchUpSubscription, ResolvedEvent, Task> eventAppeared, Action<EventStoreCatchUpSubscription> liveProcessingStarted = null, Action<EventStoreCatchUpSubscription, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null) Parameters Type Name System.Nullable < Position > lastCheckpoint CatchUpSubscriptionSettings settings System.Func < EventStoreCatchUpSubscription , ResolvedEvent , System.Threading.Tasks.Task > eventAppeared System.Action < EventStoreCatchUpSubscription > liveProcessingStarted System.Action < EventStoreCatchUpSubscription , SubscriptionDropReason , System.Exception > subscriptionDropped UserCredentials userCredentials Returns Type Description EventStoreAllCatchUpSubscription An EventStoreAllCatchUpSubscription representing the subscription. SubscribeToStreamAsync(String, Boolean, Func<EventStoreSubscription, ResolvedEvent, Task>, Action<EventStoreSubscription, SubscriptionDropReason, Exception>, UserCredentials) Asynchronously subscribes to a single event stream. New events written to the stream while the subscription is active will be pushed to the client. Declaration Task<EventStoreSubscription> SubscribeToStreamAsync(string stream, bool resolveLinkTos, Func<EventStoreSubscription, ResolvedEvent, Task> eventAppeared, Action<EventStoreSubscription, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.Boolean resolveLinkTos System.Func < EventStoreSubscription , ResolvedEvent , System.Threading.Tasks.Task > eventAppeared System.Action < EventStoreSubscription , SubscriptionDropReason , System.Exception > subscriptionDropped UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < EventStoreSubscription > A System.Threading.Tasks.Task<TResult> representing the subscription. SubscribeToStreamFrom(String, Nullable<Int64>, CatchUpSubscriptionSettings, Func<EventStoreCatchUpSubscription, ResolvedEvent, Task>, Action<EventStoreCatchUpSubscription>, Action<EventStoreCatchUpSubscription, SubscriptionDropReason, Exception>, UserCredentials) Subscribes to a single event stream. Existing events from lastCheckpoint onwards are read from the stream and presented to the user of EventStoreCatchUpSubscription as if they had been pushed. Once the end of the stream is read the subscription is transparently (to the user) switched to push new events as they are written. The action liveProcessingStarted is called when the EventStoreCatchUpSubscription switches from the reading phase to the live subscription phase. Declaration EventStoreStreamCatchUpSubscription SubscribeToStreamFrom(string stream, long? lastCheckpoint, CatchUpSubscriptionSettings settings, Func<EventStoreCatchUpSubscription, ResolvedEvent, Task> eventAppeared, Action<EventStoreCatchUpSubscription> liveProcessingStarted = null, Action<EventStoreCatchUpSubscription, SubscriptionDropReason, Exception> subscriptionDropped = null, UserCredentials userCredentials = null) Parameters Type Name System.String stream System.Nullable < System.Int64 > lastCheckpoint CatchUpSubscriptionSettings settings System.Func < EventStoreCatchUpSubscription , ResolvedEvent , System.Threading.Tasks.Task > eventAppeared System.Action < EventStoreCatchUpSubscription > liveProcessingStarted System.Action < EventStoreCatchUpSubscription , SubscriptionDropReason , System.Exception > subscriptionDropped UserCredentials userCredentials Returns Type Description EventStoreStreamCatchUpSubscription An EventStoreStreamCatchUpSubscription representing the subscription. UpdatePersistentSubscriptionAsync(String, String, PersistentSubscriptionSettings, UserCredentials) Asynchronously update a persistent subscription group on a stream. Declaration Task UpdatePersistentSubscriptionAsync(string stream, string groupName, PersistentSubscriptionSettings settings, UserCredentials credentials) Parameters Type Name System.String stream System.String groupName PersistentSubscriptionSettings settings UserCredentials credentials Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that can be waited upon. Events AuthenticationFailed Fired when a client fails to authenticate to an Event Store server. Declaration event EventHandler<ClientAuthenticationFailedEventArgs> AuthenticationFailed Event Type Type System.EventHandler < ClientAuthenticationFailedEventArgs > Closed Fired when an IEventStoreConnection is closed either using the Close() method, or when reconnection limits are reached without a successful connection being established. Declaration event EventHandler<ClientClosedEventArgs> Closed Event Type Type System.EventHandler < ClientClosedEventArgs > Connected Fired when an IEventStoreConnection connects to an Event Store server. Declaration event EventHandler<ClientConnectionEventArgs> Connected Event Type Type System.EventHandler < ClientConnectionEventArgs > Disconnected Fired when an IEventStoreConnection is disconnected from an Event Store server by some means other than by calling the Close() method. Declaration event EventHandler<ClientConnectionEventArgs> Disconnected Event Type Type System.EventHandler < ClientConnectionEventArgs > ErrorOccurred Fired when an error is thrown on an IEventStoreConnection . Declaration event EventHandler<ClientErrorEventArgs> ErrorOccurred Event Type Type System.EventHandler < ClientErrorEventArgs > Reconnecting Fired when an IEventStoreConnection is attempting to reconnect to an Event Store server following a disconnection. Declaration event EventHandler<ClientReconnectingEventArgs> Reconnecting Event Type Type System.EventHandler < ClientReconnectingEventArgs > Extension Methods IEventStoreConnectionExtensions.SubscribeToStreamAsync(IEventStoreConnection, String, Boolean, Action<EventStoreSubscription, ResolvedEvent>, Action<EventStoreSubscription, SubscriptionDropReason, Exception>, UserCredentials) IEventStoreConnectionExtensions.SubscribeToStreamFrom(IEventStoreConnection, String, Nullable<Int64>, CatchUpSubscriptionSettings, Action<EventStoreCatchUpSubscription, ResolvedEvent>, Action<EventStoreCatchUpSubscription>, Action<EventStoreCatchUpSubscription, SubscriptionDropReason, Exception>, UserCredentials) IEventStoreConnectionExtensions.SubscribeToAllAsync(IEventStoreConnection, Boolean, Action<EventStoreSubscription, ResolvedEvent>, Action<EventStoreSubscription, SubscriptionDropReason, Exception>, UserCredentials) IEventStoreConnectionExtensions.ConnectToPersistentSubscription(IEventStoreConnection, String, String, Action<EventStorePersistentSubscriptionBase, ResolvedEvent>, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception>, UserCredentials, Int32, Boolean) IEventStoreConnectionExtensions.ConnectToPersistentSubscription(IEventStoreConnection, String, String, Func<EventStorePersistentSubscriptionBase, ResolvedEvent, Task>, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception>, UserCredentials, Int32, Boolean) IEventStoreConnectionExtensions.ConnectToPersistentSubscriptionAsync(IEventStoreConnection, String, String, Action<EventStorePersistentSubscriptionBase, ResolvedEvent>, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception>, UserCredentials, Int32, Boolean) IEventStoreConnectionExtensions.ConnectToPersistentSubscriptionAsync(IEventStoreConnection, String, String, Func<EventStorePersistentSubscriptionBase, ResolvedEvent, Task>, Action<EventStorePersistentSubscriptionBase, SubscriptionDropReason, Exception>, UserCredentials, Int32, Boolean) IEventStoreConnectionExtensions.SubscribeToAllFrom(IEventStoreConnection, Nullable<Position>, CatchUpSubscriptionSettings, Action<EventStoreCatchUpSubscription, ResolvedEvent>, Action<EventStoreCatchUpSubscription>, Action<EventStoreCatchUpSubscription, SubscriptionDropReason, Exception>, UserCredentials)"
  },
  "dotnet-api/code/EventStore.ClientAPI.ClientApiConstants.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ClientApiConstants.html",
    "title": "Class ClientApiConstants | Event Store",
    "keywords": "Class ClientApiConstants Various constant values that may be useful when working with the ClientAPI. Inheritance System.Object ClientApiConstants Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public static class ClientApiConstants Fields MaxReadSize The maximum number of events that can be read in a single operation. Declaration public static readonly int MaxReadSize Field Value Type System.Int32"
  },
  "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptionNakEventAction.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptionNakEventAction.html",
    "title": "Enum PersistentSubscriptionNakEventAction | Event Store",
    "keywords": "Enum PersistentSubscriptionNakEventAction Actions to be taken by server in the case of a client NAK Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public enum PersistentSubscriptionNakEventAction Fields Name Description Park Park message do not resend. Put on poison queue Retry Explicitly retry the message. Skip Skip this message do not resend do not put in poison queue Stop Stop the subscription. Unknown Client unknown on action. Let server decide"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.ProjectionCommandConflictException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.ProjectionCommandConflictException.html",
    "title": "Class ProjectionCommandConflictException | Event Store",
    "keywords": "Class ProjectionCommandConflictException Exception thrown if a projection command fails. Inheritance System.Object System.Exception EventStoreConnectionException ProjectionCommandFailedException ProjectionCommandConflictException Implements System.Runtime.Serialization.ISerializable Inherited Members ProjectionCommandFailedException.HttpStatusCode System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class ProjectionCommandConflictException : ProjectionCommandFailedException, ISerializable Constructors ProjectionCommandConflictException() Constructs a new ProjectionCommandFailedException . Declaration public ProjectionCommandConflictException() ProjectionCommandConflictException(Int32, String) Constructs a new ProjectionCommandFailedException . Declaration public ProjectionCommandConflictException(int httpStatusCode, string message) Parameters Type Name System.Int32 httpStatusCode System.String message ProjectionCommandConflictException(SerializationInfo, StreamingContext) Constructs a new ProjectionCommandFailedException . Declaration protected ProjectionCommandConflictException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context ProjectionCommandConflictException(String, Exception) Constructs a new ProjectionCommandFailedException . Declaration public ProjectionCommandConflictException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Implements System.Runtime.Serialization.ISerializable"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to Event Store | Event Store",
    "keywords": "Welcome to Event Store The team and community behind Event Store welcomes you and hopes we can help you find what you're looking for. New to Event Sourcing? If the concept of event sourcing, and why it's useful, is new to you, we recommend you read our guide to event sourcing first. New to Event Store? If you're familiar with event sourcing and want to know how to test Event Store, read the Introduction section. Already using Event Store? If you're already using Event Store, then welcome back and hopefully you can find what you need under the other sub-sections you can see in the left hand navigation menu, you can also try using the search box in the top navigation bar. If there's still something missing, then create an issue on GitHub , use the 'Improve this Doc' link on the top right on any documentation page to make a pull request, or contact docs@eventstore.org ."
  },
  "projections/debugging/index.html": {
    "href": "projections/debugging/index.html",
    "title": "Debugging | Event Store",
    "keywords": "Debugging User projections you create in JavaScript have a bonus that debugging is easier via any browser that ships with debugging capabilities. The screenshots in this document show the use of Chrome, but we have tested debugging with all major browsers including Firefox, Edge and Safari. Logging from within a projection For debugging purposes, projections includes a log method which, when called, sends messages to the configured Event Store logger (the default is NLog , to a file, and stdout ). You might find printing out the structure of the event body for inspection useful. For example: fromStream('$stats-127.0.0.1:2113') .when({ $any: function(s,e){ log(JSON.stringify(e)); } }) Creating a sample projection for debugging purposes Filename: stats-counter.json Contents: fromStream('$stats-127.0.0.1:2113') .when({ $init: function(){ return { count: 0 } }, $any: function(s,e){ s.count += 1; } }) You create the projection by making a call to the API and providing it with the definition of the projection. curl -i -d@stats-counter.json http://localhost:2113/projections/continuous?name=stats-counter%26type=js%26enabled=true%26emit=true%26trackemittedstreams=true -u admin:changeit Debugging your first projection Once the projection is running, open your browser and enable the developer tools. Once you have the developer tools open, visit your projection URL and you should see a button labelled Debug . After clicking the projection \"Debug\" button, you see the debugging interface with the definition of the projection and information about the events the projection is processing on the right hand side. At the top there are couple of buttons to take note of, specifically the Run Step and Update buttons. You use Run Step to step through the event waiting in the queue, placing you in projection debugging mode. The Update button provides you with a way to update the projection definition without having to go back to the projection itself and leave the context of the debugger. If the Run Step button is not greyed out and you click it, the browser has hit a breakpoint. You are now able to step through the projection, the important method to step into is the handler(state, eventEnvelope) method."
  },
  "projections/api/index.html": {
    "href": "projections/api/index.html",
    "title": "API | Event Store",
    "keywords": "API <!-- TODO: Do Something better with this? Or just link? --> URI Description HTTP Verb /projections/any Returns all known projections. GET /projections/all-non-transient Returns all known non ad-hoc projections. GET /projections/transient Returns all known ad-hoc projections. GET /projections/onetime Returns all known one-time projections. GET /projections/continuous Returns all known continuous projections. GET /projections/transient?name={name}&type={type}&enabled={enabled} Create an ad-hoc projection. This type of projection runs until completion and automatically deleted afterwards. POST Parameters name: Name of the projection type: JS or Native. (JavaScript or native. At this time, Event Store only supports JavaScript) enabled: Enable the projection (true/false) /projections/onetime?name={name}&type={type}&enabled={enabled}&checkpoints={checkpoints}&emit={emit}&trackemittedstreams={trackemittedstreams} Create a one-time projection. This type of projection runs until completion and then stops. POST Parameters name: Name of the projection type: JS or Native. (JavaScript or native. At this time, Event Store only supports JavaScript) enabled: Enable the projection (true/false) checkpoints: Enable checkpoints (true/false) emit: Enable the ability for the projection to write to streams (true/false) trackemittedstreams: Write the name of the streams the projection is managing to a separate stream. $projections-{projection-name}-emittedstreams (true/false) /projections/continuous?name={name}&type={type}&enabled={enabled}&emit={emit}&trackemittedstreams={trackemittedstreams} Create a continuous projection. This type of projection will, if enabled will continuously run unless disabled or an unrecoverable error is encountered. POST Parameters name: Name of the projection type: JS or Native. (JavaScript or native. At this time, Event Store only supports JavaScript) enabled: Enable the projection (true/false) emit: Allow the projection to write to streams (true/false) trackemittedstreams: Write the name of the streams the projection is managing to a separate stream. $projections-{projection-name}-emittedstreams (true/false) /projection/{name}/query?config={config} Returns the definition query and if config is set to true, will return the configuration. GET Parameters name: Name of the projection config: Return the definition of the projection (true/false) /projection/{name}/query?type={type}&emit={emit} Update a projection's query. PUT Parameters name: Name of the projection type: JS or Native. (JavaScript or native. At this time, Event Store only supports JavaScript) emit: Allow the projection to write to streams (true/false) trackemittedstreams: Write the name of the streams the projection is managing to a separate stream. $projections-{projection-name}-emittedstreams (true/false) /projection/{name} Returns information for a projection. GET /projection/{name}?deleteStateStream={deleteStateStream}&deleteCheckpointStream={deleteCheckpointStream}&deleteEmittedStreams={deleteEmittedStreams} Delete a projection, optionally delete the streams that were created as part of the projection. DELETE Parameters name: Name of the projection deleteStateStream: Delete the state stream (true/false) deleteCheckpointStream: Delete the checkpoint stream (true/false) deleteEmittedStreams: Delete the emitted streams stream (true/false) /projection/{name}/statistics Returns detailed information for a projection. GET Parameters name: Name of the projection /projection/{name}/state?partition={partition} Query for the state of a projection. GET Parameters name: Name of the projection partition: The partition /projection/{name}/result?partition={partition} Query for the result of a projection. GET Parameters name: Name of the projection partition: The partition /projection/{name}/command/disable?enableRunAs={enableRunAs} Disable a projection. POST Parameters name: Name of the projection enableRunAs: Enables the projection to run as the user who issued the request. /projection/{name}/command/enable?enableRunAs={enableRunAs} Enable a projection. POST Parameters name: Name of the projection enableRunAs: Enables the projection to run as the user who issued the request. /projection/{name}/command/reset?enableRunAs={enableRunAs} Reset a projection. (This will re-emit events, streams that are written to from the projection will also be soft deleted). POST Parameters name: Name of the projection enableRunAs: Enables the projection to run as the user who issued the request. /projection/{name}/command/abort?enableRunAs={enableRunAs} Abort a projection. POST Parameters name: Name of the projection enableRunAs: Enables the projection to run as the user who issued the request."
  },
  "getting-started/which-api-sdk/index.html": {
    "href": "getting-started/which-api-sdk/index.html",
    "title": "Step 4 - Which API or SDK to use | Event Store",
    "keywords": "Step 4 - Which API or SDK to use This getting started guide shows you how to get started with Event Store using the Atom publishing protocol as the primary interface. This final step covers the different APIs, and client SDKs Event Store has available with the aim of helping you choose which one suits your use case. TCP Event Store offers a low-level protocol in the form of an asynchronous TCP protocol that exchanges protobuf objects. At present this protocol has adapters for .NET and the JVM. Event Store supported clients .NET Client JVM Client Community developed clients .NET Core Node.js Node.js Node.js Haskell Erlang F# Elixir Java 8 Maven plugin Rust Go HTTP Event Store also offers an HTTP-based interface, based specifically on the AtomPub protocol . As it operates over HTTP, this is less efficient, but nearly every environment supports it. Event Store supported clients HTTP API Community developed clients PHP Python Ruby Go If you have a client to add, click the 'Improve this Doc' link on the top right of the page to submit a pull request. Which to use? Many factors go into the choice of which of the protocols (TCP vs. HTTP) to use. Both have their strengths and weaknesses. TCP is faster This speed especially applies to subscribers as events pushed to the subscriber, whereas with Atom the subscribers poll the head of the atom feed to check if new events are available. The difference can be as high as 23 times higher (sub 10ms for TCP, vs. seconds for Atom). Also, the number of writes per second supported is often dramatically higher when using TCP. At the time of writing, standard Event Store appliances can service around 2000 writes/second over HTTP compared to 15,000-20,000/second over TCP. This increase might be a deciding factor if you are in a high-performance environment. AtomPub is more scalable for large numbers of subscribers This scalability is due to the ability to use intermediary caching with Atom feeds. Most URIs returned by Event Store point to immutable data and are infinitely cachable. Therefore on a replay of a projection, much of the data required is likely available on a local or intermediary cache. This can also lead to lower network traffic. Atom tends to operate better in a large heterogeneous environment where you have callers from different platforms. This is especially true if you have to integrate with different teams or external vendors. Atom is an industry standard and well-documented protocol whereas the TCP protocol is a custom protocol they would need to understand. Most platforms have good existing tooling for Atom including feed readers. None of this tooling exists for analyzing traffic with the TCP protocol. Note Our recommendation would be to use AtomPub as your primary protocol unless you have low subscriber SLAs or need higher throughput on reads and writes than Atom can offer. This is due to the open nature and ease of use of the Atom protocol. Often in integration scenarios, these are more important than raw performance. Next step Congratulations! You've reached the end of our getting started guide, what's next? Want to use the .NET client? Find more here . Want to use the HTTP API? Find out more here ."
  },
  "getting-started/projections/index.html": {
    "href": "getting-started/projections/index.html",
    "title": "Step 3 - Projections | Event Store",
    "keywords": "Step 3 - Projections This getting started guide shows you how to get started with Event Store using the Atom publishing protocol as the primary interface. Note The described is for development and evaluation of Event Store. It does not describe a production setup. The HTTP examples use cURL, but you can read Atom feeds with a wide variety of applications and languages. Projections is an Event Store subsystem that lets you write new events or link existing events to streams in a reactive manner. Projections are good at solving one specific query type, a category known as 'temporal correlation queries'. This query type is common in business systems and few can execute these queries well. Note Projections require the event body to be in JSON. When running a projection, you can choose whether the query should run and give you all results present or whether the query should continue running into the future finding new results as they happen and updating its result set. Setting up projections You enable projections with the command line argument --run-projections . For example, the command below enables all projection modes (system and user-defined): Tip Read this guide for all the possible parameter values. Windows Linux Docker macOS EventStore.ClusterNode.exe --run-projections=all --start-standard-projections=true To disable them again, run: EventStore.ClusterNode.exe --run-projections=none Add EVENTSTORE_RUN_PROJECTIONS=All and EVENTSTORE_START_STANDARD_PROJECTIONS=true to your environment variables, or the /etc/eventstore/eventstore.conf configuration file and start Event Store: sudo systemctl start eventstore To disable them again, change the values to EVENTSTORE_RUN_PROJECTIONS=none . The Event Store Docker image has projections enabled by default, but you need to enable standard projections: docker run --name eventstore-node -it -p 2113:2113 -p 1113:1113 -e EVENTSTORE_RUN_PROJECTIONS=All -e EVENTSTORE_START_STANDARD_PROJECTIONS=true eventstore/eventstore To disable them again: docker run --name eventstore-node -it -p 2113:2113 -p 1113:1113 -e EVENTSTORE_RUN_PROJECTIONS=None eventstore/eventstore eventstore --run-projections=all --start-standard-projections=true To disable them again, run: eventstore --run-projections=none Note To use the default database location on macOS you need to use sudo , or you can change the location with the --db parameter. You then see new tabs enabled in the Admin UI with the four system projections in a Stopped state: You can also query the state of all projections using the HTTP API. Request Response curl -i http://localhost:2113/projections/any -H \"accept:application/json\" | grep -E 'effectiveName|status' The response is a list of all known projections and useful information about them. \"effectiveName\": \"$streams\" \"status\": \"Stopped\" \"statusUrl\": \"http://localhost:2113/projection/$streams\" \"effectiveName\": \"$stream_by_category\" \"status\": \"Stopped\" \"statusUrl\": \"http://localhost:2113/projection/$stream_by_category\" \"effectiveName\": \"$by_category\" \"status\": \"Stopped\" \"statusUrl\": \"http://localhost:2113/projection/$by_category\" \"effectiveName\": \"$by_event_type\" \"status\": \"Stopped\" \"statusUrl\": \"http://localhost:2113/projection/$by_event_type\" Add sample data Download the following files that contain sample data used throughout this step of the getting started guide. shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1164.json shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1165.json shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1166.json shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167.json Add the sample data to four different streams: HTTP API .NET API JVM client curl -i -d \"@shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1164.json\" \"http://127.0.0.1:2113/streams/shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1164\" -H \"Content-Type:application/vnd.eventstore.events+json\" curl -i -d \"@shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1165.json\" \"http://127.0.0.1:2113/streams/shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1165\" -H \"Content-Type:application/vnd.eventstore.events+json\" curl -i -d \"@shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1166.json\" \"http://127.0.0.1:2113/streams/shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1166\" -H \"Content-Type:application/vnd.eventstore.events+json\" curl -i -d \"@shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167.json\" \"http://127.0.0.1:2113/streams/shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167\" -H \"Content-Type:application/vnd.eventstore.events+json\" foreach (string f in Directory.GetFiles(\"../\", \"shoppingCart-*\")) { var streamName = Path.GetFileNameWithoutExtension(f); conn.AppendToStreamAsync(streamName, ExpectedVersion.Any, eventData).Wait(); } final Collection fileList = getAllFilesThatMatchFilenameExtension(\"/Users/chrisward/Workspace/EventStore/docs.geteventstore.com/code-examples/getting-started\", \"shoppingCart-*\"); for (Object file : fileList) { String streamName = FilenameUtils.getBaseName(removeExtension(file.toString())); System.out.println(\"value= \" + streamName); JSONParser parser = new JSONParser(); try { JSONArray events = (JSONArray) parser.parse(new FileReader(file.toString())); for (Object e : events) { JSONObject event = (JSONObject) e; final EventData json = new EventDataBuilder(\"json\") .eventId(UUID.fromString((String) event.get(\"eventId\"))) .jsonData((event.get(\"data\")).toString()) .jsonMetadata(event.get(\"metadata\").toString()) .build(); final WriteEvents writeEvents = new WriteEventsBuilder(\"newstream\") .addEvent(json) .expectAnyVersion() .build(); connection.tell(writeEvents, writeResult); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (ParseException e) { e.printStackTrace(); } } Note While it's not the fastest method, you can also use the Admin UI for creating the streams, and all the tasks in this step, as we saw in step 1 . Writing your first projection Tip Read this guide to find out more about the user defined projection's API. The projection counts the number of 'XBox One S's that customers added to their shopping carts. A projection starts with a selector, in this case fromAll() . Another possibility is fromCategory({category}) which this step discusses later, but for now, fromAll should do. The second part of a projection is a set of filters. There is a special filter called $init that sets up an initial state. You want to start a counter from 0 and each time Event Store observes an ItemAdded event for an 'Xbox One S,' increment the counter. Here is the projection, you can download it as a file here : fromAll() .when({ $init: function(){ return { count: 0 } }, ItemAdded: function(s,e){ if(e.body.Description.indexOf(\"Xbox One S\") >= 0){ s.count += 1; } } }) You create a projection by calling the projection API and providing it with the definition of the projection. Here you decide how to run the projection, declaring that you want the projection to start from the beginning and keep running. You can create a projection using the Admin UI by opening the Projections tab, clicking the New Projection button and filling in the details of your projection. To use the HTTP or .NET API, pass the projection JSON file as a parameter of your request, along with any other settings: HTTP API .NET API curl -i --data-binary \"@xbox-one-s-counter.json\" http://localhost:2113/projections/continuous?name=xbox-one-s-counter%26type=js%26enabled=true%26emit=true%26trackemittedstreams=true -u admin:changeit Next Steps Read here for more information on creating projections with the HTTP API and the parameters available, or our projections section for details on projection syntax. public static readonly ProjectionsManager Projection = new ProjectionsManager(new ConsoleLogger(), new IPEndPoint(IPAddress.Parse(\"127.0.0.1\"), 2113), TimeSpan.FromMilliseconds(5000)); projection.CreateContinuousAsync(\"xbox-one-s-counter\", countItemsProjection, adminCredentials).Wait(); Next Steps Read here for more information on creating projections with the .NET API and the parameters available, or our projections section for details on projection syntax. Querying for the state of the projection Now the projection is running, you can query the state of the projection. As this projection has a single state, query it with the following request: HTTP API .NET API Response curl -i http://localhost:2113/projection/xbox-one-s-counter/state var projectionState = projection.GetStateAsync(\"xbox-one-s-counter\", Globals.AdminCredentials); Console.WriteLine(projectionState.Result); { \"count\": 3 } Writing to streams from projections The above gives you the correct result but requires you to poll for the state of a projection. What if you wanted Event Store to notify you about state updates via subscriptions? Output state Update the projection to output the state to a stream by calling the outputState() method on the projection which by default produces a $projections-{projection-name}-result stream. Below is the updated projection, you can download it as a file here : fromAll() .when({ $init: function(){ return { count: 0 } }, ItemAdded: function(s,e){ if(e.body.Description.indexOf(\"Xbox One S\") >= 0){ s.count += 1; } } }).outputState() To update the projection, edit the projection definition in the Admin UI, or issue the following request: HTTP API .NET API curl -i -X PUT --data-binary @\"xbox-one-s-counter-outputState.json\" http://localhost:2113/projection/xbox-one-s-counter/query?emit=yes -u admin:changeit projection.UpdateQueryAsync(\"xbox-one-s-counter\", countItemsProjectionUpdate, adminCredentials).Wait(); Then reset the projection you created above: HTTP API .NET API Response curl -i -X POST \"http://localhost:2113/projection/xbox-one-s-counter/command/reset\" -H \"accept:application/json\" -H \"Content-Length:0\" -u admin:changeit projection.ResetAsync(\"xbox-one-s-counter\", adminCredentials).Wait(); { \"msgTypeId\": 293, \"name\": \"xbox-one-s-counter\" } You can now read the events in the result stream by issuing a read request. HTTP API .NET API Response curl -i \"http://localhost:2113/streams/\\$projections-xbox-one-s-counter-result?embed=body\" -H \"accept:application/json\" -u admin:changeit | grep data var readEvents = conn.ReadStreamEventsForwardAsync(\"$projections-xbox-one-s-counter-result\", 0, 10, true) .Result; foreach (var evt in readEvents.Events) Console.WriteLine(Encoding.UTF8.GetString(evt.Event.Data)); \"data\": \"{\\\"count\\\":3}\", \"data\": \"{\\\"count\\\":2}\", \"data\": \"{\\\"count\\\":1}\", Configure projection properties You can configure properties of the projection by updating values of the options object. For example, the following projection changes the name of the results stream, you can download it as a file here : options({ resultStreamName: \"xboxes\" }) fromAll() .when({ $init: function(){ return { count: 0 } }, ItemAdded: function(s,e){ if(e.body.Description.indexOf(\"Xbox One S\") >= 0){ s.count += 1; } } }).outputState() Then send the update to the projection: HTTP API .NET API curl -i -X PUT -d \"@update-projection-options.json\" http://localhost:2113/projection/xbox-one-s-counter/query?emit=yes -u admin:changeit projection.UpdateQueryAsync(\"xbox-one-s-counter\", optionsProjectionOptionsUpdate,adminCredentials).Wait(); Tip You can find all the options available in the user defined projections guide . Now you can read the result as above, but use the new stream name: HTTP API .NET API curl -i \"http://localhost:2113/streams/xboxes?embed=body\" -H \"accept:application/json\" -u admin:changeit | grep data readEvents = conn.ReadStreamEventsForwardAsync(\"xboxes\", 0, 10, true).Result; foreach (var evt in readEvents.Events) Console.WriteLine(Encoding.UTF8.GetString(evt.Event.Data)); } The number of items per shopping cart The example in this step so far relied on a global state for the projection, but what if you wanted a count of the number of items in the shopping cart per shopping cart. Event Store has a built-in $by_category projection that lets you select events from a particular list of streams. Enable this projection with the following command. HTTP API .NET API curl -i -d{} http://localhost:2113/projection/%24by_category/command/enable -u admin:changeit projection.EnableAsync(\"$by_category\", adminCredentials).Wait(); The projection links events from existing streams to new streams by splitting the stream name by a separator. You can configure the projection to specify the position of where to split the stream id and provide a separator. By default, the category splits the stream id by a dash. The category is the first string. Stream Name Category shoppingCart-54 shoppingCart shoppingCart-v1-54 shoppingCart shoppingCart No category as there is no separator You want to define a projection that produces a count per stream for a category, but the state needs to be per stream. To do so, use $by_category and its fromCategory API method. Below is the projection, you can download the file here : fromCategory('shoppingCart') .foreachStream() .when({ $init: function(){ return { count: 0 } }, ItemAdded: function(s,e){ s.count += 1; } }) Create the projection with the following request: HTTP API .NET API curl -i --data-binary \"@shopping-cart-counter.json\" http://localhost:2113/projections/continuous?name=shopping-cart-item-counter%26type=js%26enabled=true%26emit=true%26trackemittedstreams=true -u admin:changeit projection.CreateContinuousAsync(\"shopping-cart-item-counter\", itemCounterProjection, true, adminCredentials).Wait(); Querying for the state of the projection by partition Querying for the state of the projection is different due to the partitioning of the projection. You have to specify the partition and the name of the stream. HTTP API .NET API Response curl -i http://localhost:2113/projection/shopping-cart-item-counter/state?partition=shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1164 var projectionState = projection.GetPartitionStateAsync(\"shopping-cart-item-counter\", \"shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1164\", adminCredentials); Console.WriteLine(projectionState.Result); { \"count\": 2 } Next step In this third part of our getting started guide you learned about projections. The next, and final part covers which API or SDK to use, and when. Step 4 - Which API or SDK"
  },
  "getting-started/reading-subscribing-events/index.html": {
    "href": "getting-started/reading-subscribing-events/index.html",
    "title": "Step 2 - Read events from a stream and subscribe to changes | Event Store",
    "keywords": "Step 2 - Read events from a stream and subscribe to changes This getting started guide shows you how to get started with Event Store using the Atom publishing protocol as the primary interface. Note The described is for development and evaluation of Event Store. It does not describe a production setup. The HTTP examples use cURL, but you can read Atom feeds with a wide variety of applications and languages. This second step covers reading events from a stream and subscribing to changes to events in a stream. Read a stream of events Event Store exposes all streams as atom feeds , and you can read data from the stream by navigating to the head URI of the stream http://127.0.0.1:2113/streams/<STREAM_ID > with cURL, or click the Stream Browser tab in the Admin UI and you see the stream you created in step 1. Request Response curl -i -H \"Accept:application/vnd.eventstore.atom+json\" \"http://127.0.0.1:2113/streams/newstream\" Note This returns the feed in JSON format, you can also use Accept:application/atom+xml if you prefer XML. HTTP/1.1 200 OK Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Cache-Control: max-age=0, no-cache, must-revalidate Vary: Accept ETag: \"0;-2060438500\" Content-Type: application/vnd.eventstore.atom+json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 15 Dec 2017 12:23:23 GMT Content-Length: 1262 Keep-Alive: timeout=15,max=100 { \"title\": \"Event stream 'newstream'\", \"id\": \"http://127.0.0.1:2113/streams/newstream\", \"updated\": \"2017-12-15T12:19:32.021776Z\", \"streamId\": \"newstream\", \"author\": { \"name\": \"EventStore\" }, \"headOfStream\": true, \"selfUrl\": \"http://127.0.0.1:2113/streams/newstream\", \"eTag\": \"0;-2060438500\", \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream\", \"relation\": \"self\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/head/backward/20\", \"relation\": \"first\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/1/forward/20\", \"relation\": \"previous\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/metadata\", \"relation\": \"metadata\" } ], \"entries\": [ { \"title\": \"0@newstream\", \"id\": \"http://127.0.0.1:2113/streams/newstream/0\", \"updated\": \"2017-12-15T12:19:32.021776Z\", \"author\": { \"name\": \"EventStore\" }, \"summary\": \"event-type\", \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream/0\", \"relation\": \"edit\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/0\", \"relation\": \"alternate\" } ] } ] } .NET Client API JVM client To use the .NET API, use the following method passing the stream name, the start point in the stream, the number of events to read and whether to follow links to the event data: var readEvents = conn.ReadStreamEventsForwardAsync(streamName, 0, 10, true).Result; foreach (var evt in readEvents.Events) Console.WriteLine(Encoding.UTF8.GetString(evt.Event.Data)); Next Steps Read this guide for more information on how to read events with the .NET API. To use the JVM client, use the following method passing the stream name, the start point in the stream, and whether to follow links to the event data: final ActorRef readResult = system.actorOf(Props.create(ReadResult.class)); //TODO: How to read ten events? final ReadEvent readEvent = new ReadEventBuilder(\"newstream\") .first() .resolveLinkTos(false) .build(); connection.tell(readEvent, readResult); Read a single event The feed has a single item inside of it, the one you posted in part 1 . You can see details of the event in the Stream Browser tab in the Admin UI by selecting a stream to see its events, and then selecting an event. Or with cURL, issue a GET to the alternate URI value from the response above. Request Response curl -i http://127.0.0.1:2113/streams/newstream/0 -H \"Accept: application/json\" Note You can also use Accept: text/xml if you prefer XML. HTTP/1.1 200 OK Access-Control-Allow-Methods: GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER Access-Control-Allow-Origin: * Cache-Control: max-age=31536000, public Vary: Accept Content-Type: application/json; charset: utf-8 Server: Mono-HTTPAPI/1.0 Date: Wed, 03 Jul 2013 11:09:12 GMT Content-Length: 14 Keep-Alive: timeout=15,max=100 { \"a\": \"1\" } .NET client API JVM client To use the .NET API, use the following method passing the stream name, the event you want to read and wether to return the event data: var readResult = conn.ReadEventAsync(streamName, 0, true).Result; Console.WriteLine(Encoding.UTF8.GetString(readResult.Event.Value.Event.Data)); To use the Java client, use the following method passing the stream name, the event you want to read and if you want to also return the event data: final ActorRef readResult = system.actorOf(Props.create(ReadResult.class)); //TODO: How to read ten events? final ReadEvent readEvent = new ReadEventBuilder(\"newstream\") .first() .resolveLinkTos(false) .build(); connection.tell(readEvent, readResult); Paginating through events For longer feeds of events than this example, you need to paginate through the feed, reading a certain number of events at a time. You can use the HTTP API to paginate through the feed using previous and next links within the stream. Or you can use a read method of the .NET API (and JVM client), to loop through events a certain number at a time. Subscribing to receive stream updates A common operation is to subscribe to a stream and receive notifications for changes. As new events arrive, you continue following them. You can create subscriptions and watch events as they arrive under the Persistent Subscriptions tab, or use an API method. Create subscription in the admin UI Click Persistent Subscriptions Enter a name for this subscription group (this can be any value you choose). Enter the name of the stream you want to subscribe to. Configure the other options. You can find more information about the options in the .NET API PersistentSubscriptionSettings object . Click Create to create the new subscription. Create a subscription programmatically HTTP API .NET API JVM client API curl -i -X PUT -d $'{\"startFrom\": 0,\"resolveLinktos\": false}' http://localhost:2113/subscriptions/newstream/examplegroup -u admin:changeit -H \"Content-Type: application/json\" PersistentSubscriptionSettings settings = PersistentSubscriptionSettings.Create() .DoNotResolveLinkTos() .StartFromCurrent(); conn.CreatePersistentSubscriptionAsync(streamName, \"examplegroup\", settings, adminCredentials).Wait(); conn.ConnectToPersistentSubscription(streamName, \"examplegroup\", (_, x) => { var data = Encoding.ASCII.GetString(x.Event.Data); Console.WriteLine(\"Received: \" + x.Event.EventStreamId + \":\" + x.Event.EventNumber); Console.WriteLine(data); }, (sub, reason, ex) => { }, adminCredentials); Console.WriteLine(\"waiting for events. press enter to exit\"); Console.ReadLine(); Next Steps Find more details on the parameters used in the example above, read the API documentation for PersistentSubscriptionSettings , CreatePersistentSubscriptionAsync and ConnectToPersistentSubscription final Closeable closeable = connection.subscribeToStream(\"newstream\", new SubscriptionObserver<Event>() { @Override public void onLiveProcessingStart(Closeable subscription) { system.log().info(\"live processing started\"); } @Override public void onEvent(Event event, Closeable subscription) { system.log().info(event.toString()); } @Override public void onError(Throwable e) { system.log().error(e.toString()); } @Override public void onClose() { system.log().error(\"subscription closed\"); } }, false, null); <!-- TODO: The dotnet example has reading events as they are added to subscription, HTTP does not, expand? --> <!-- TODO: And write more events, then what etc --> Subscription types There are three types of subscription patterns, useful in different situations Volatile subscriptions This subscription calls a given function for events written after establishing the subscription. They are useful when you need notification of new events with minimal latency, but where it's not necessary to process every event. <!-- TODO: Example needed? --> For example, if a stream has 100 events in it when a subscriber connects, the subscriber can expect to see event number 101 onwards until the time the subscription is closed or dropped. Catch-up subscriptions This subscription specifies a starting point, in the form of an event number or transaction file position. You call the function for events from the starting point until the end of the stream, and then for subsequently written events. <!-- TODO: Example needed? --> For example, if you specify a starting point of 50 when a stream has 100 events, the subscriber can expect to see events 51 through 100, and then any events are subsequently written until you drop or close the subscription. Persistent subscriptions Note Persistent subscriptions exist in version 3.2.0 and above of Event Store. This subscription supports the \" competing consumers \" messaging pattern and are useful when you need to distribute messages to many workers. Event Store saves the subscription state server-side and allows for at-least-once delivery guarantees across multiple consumers on the same stream. It is possible to have many groups of consumers compete on the same stream, with each group getting an at-least-once guarantee. <!-- TODO: Example needed? --> Next step In this second part of our getting started guide you learned how to read events from a stream and subscribe to changes. The next part covers projections, used to give you continuous queries of your data. Step 3 - Projections"
  },
  "getting-started/index.html": {
    "href": "getting-started/index.html",
    "title": "Step 1 - Install, run, and write your first event | Event Store",
    "keywords": "Step 1 - Install, run, and write your first event This getting started guide shows you how to get started with Event Store using the Atom publishing protocol as the primary interface. Note The described is for development and evaluation of Event Store. It does not describe a production setup. The HTTP examples use cURL, but you can read Atom feeds with a wide variety of applications and languages. This first step covers installation and running Event Store, and writing your first event. Install and run Event Store Note Unless you pass a database option with --db , Event Store writes to a new database created in the host system's temporary files path each time it is started. For more information on Command Line Arguments read this guide . Windows Linux Docker Kubernetes macOS The prerequisites for installing on Windows are: NET Framework 4.0+ Event Store has Chocolatey packages available that you can install with the following command: choco install eventstore-oss You can also download a binary, unzip the archive and run from the folder location with an administrator console. The following command starts Event Store with the database stored at the path ./db and the logs in ./logs . You can view further command line arguments in the server docs . EventStore.ClusterNode.exe --db ./db --log ./logs Event Store runs in an administration context because it starts an HTTP server through http.sys . For permanent or production instances you need to provide an ACL such as: netsh http add urlacl url=http://+:2113/ user=DOMAIN\\username For more information, refer to Microsoft's add urlacl documentation . To build Event Store from source, refer to the Event Store README . The prerequisites for installing on Linux are: We recommend Mono 5.16.0 , but other versions may also work. Event Store has pre-built packages available for Debian-based distributions , manual instructions for distributions that use RPM , or you can build from source . The final package name to install is eventstore-oss . If you installed from a pre-built package, start Event Store with: sudo systemctl start eventstore When you install the Event Store package, the service doesn't start by default. This is to allow you to change the configuration, located at /etc/eventstore/eventstore.conf and to prevent creating a default database. Tip To start Event Store on port 80 as a service, refer to Configuring your installation Tip We recommend that when using Linux you set the 'open file limit' to a high number. The precise value depends on your use case, but at least between 30,000 and 60,000 . Event Store has a Docker image available for any platform that supports Docker. Pull the Docker image: docker pull eventstore/eventstore Run the container: docker run --name eventstore-node -it -p 2113:2113 -p 1113:1113 eventstore/eventstore Refer to the image overview for more information. Event Store has a Helm chart available for installing Event Store on Kubernetes clusters: helm repo add eventstore https://eventstore.github.io/EventStore.Charts helm repo update helm install -n eventstore eventstore/eventstore Note Read this guide for more details on how to use the helm chart. Read this guide for more details on using Kubernetes with AKS and this guide for more details on using Kubernetes with GKE. Event Store has a macOS package you can download and install, and we maintain a Homebrew Cask formula you can install: brew cask install eventstore In each case you can run Event Store with the eventstore command, and stop it with Ctrl+c . To use the default database location you need to use sudo , or you can change the location with the --db parameter. To build Event Store from source, refer to the Event Store README . Interacting with an Event Store server There are three ways to interact with Event Store: With the Admin UI . With the HTTP API . With a Client API, which you need to install first. Our documentation covers the .NET Core client API and the JVM client but others are available. .NET client JVM client Install the .NET client API using your preferred method. Add it to your project: dotnet add package EventStore.Client And require it in your code: using EventStore.ClientAPI; Add the JVM client using Maven: <dependency> <groupId>com.geteventstore</groupId> <artifactId>eventstore-client_2.12</artifactId> <version>5.0.8</version> </dependency> And require it in your code: import eventstore.*; Connecting to Event Store If you want to use the Admin UI or the HTTP API, then you use port 2113 . For example, http://127.0.0.1:2113/ in your web browser, or curl -i http://127.0.0.1:2113 for the HTTP API. Tip The default username and password is admin:changeit To use a client API, you use port 1113 and create a connection: .NET client JVM client When using the .NET client, you also need to give the connection a name. var conn = EventStoreConnection.Create(new Uri(\"tcp://admin:changeit@localhost:1113\"), \"InputFromFileConsoleApp\"); Next Steps In this example we used the EventStoreConnection.Create() overloaded method but others are available . final EventData event = new EventDataBuilder(\"my-event\").eventId(UUID.randomUUID()).data(\"my event data\") .metadata(\"my first event\").build(); final WriteEvents writeEvents = new WriteEventsBuilder(\"my-stream\").addEvent(event).expectAnyVersion().build(); Note For our JVM examples we use akka , a toolkit for building highly concurrent and distributed JVM applications. Writing events to an Event Stream Event Store operates on a concept of Event Streams, and the first operation we look at is how to write to a stream. If you are Event Sourcing a domain model, a stream equates to an aggregate function. Event Store can handle hundreds of millions of streams, so create as many as you need. If you post to a stream that doesn't exist, Event Store creates it before adding the events. Writing events using the admin UI You can write events using the Admin UI by clicking the Stream Browser tab, the Add Event button, filling in the form with relevant values and clicking the Add button at the bottom of the page. Open a text editor, copy and paste the following event definition, and save it as event.json . [ { \"eventId\": \"fbf4a1a1-b4a3-4dfe-a01f-ec52c34e16e4\", \"eventType\": \"event-type\", \"data\": { \"a\": \"1\" } } ] Writing events programmatically HTTP API .NET API JVM client Use the following cURL command, passing the name of the stream and the events to write: curl -i -d \"@event.json\" \"http://127.0.0.1:2113/streams/newstream\" -H \"Content-Type:application/vnd.eventstore.events+json\" Next Steps Read this guide for more information on how to write events with the HTTP API. Note You can also post events to the HTTP API as XML, by changing the Content-Type header to XML . To use the .NET API, use the following method, passing the name of the stream, the version, and the events to write: conn.AppendToStreamAsync(streamName, ExpectedVersion.Any, eventData).Wait(); Next Steps Read this guide for more information on how to write events with the .NET API. We don't cover version checking in this guide, but you can read more in the optimistic concurrency guide . To use the JVM Client, use the following method, passing the name of the stream, the version, and the events to write: connection.tell(writeEvents, writeResult); } public static class WriteResult extends AbstractActor { final LoggingAdapter log = Logging.getLogger(getContext().system(), this); @Override public Receive createReceive() { return receiveBuilder().match(WriteEventsCompleted.class, m -> { log.info(\"range: {}, position: {}\", m.numbersRange(), m.position()); context().system().terminate(); }).match(Status.Failure.class, f -> { final EsException exception = (EsException) f.cause(); Next step In this first part of our getting started guide you learned how to install and run Event Store and write your first event. The next part covers reading events from a stream. Step 2 - Read events from a stream and subscribe to changes"
  },
  "http-api/optional-http-headers/trusted-intermediary/index.html": {
    "href": "http-api/optional-http-headers/trusted-intermediary/index.html",
    "title": "Optional HTTP Headers: Trusted Intermediary | Event Store",
    "keywords": "Optional HTTP Headers: Trusted Intermediary The trusted intermediary header helps Event Store support a common security architecture. There are thousands of possible methods for handling authentication and it is impossible for us to support them all. The header allows you to configure a trusted intermediary to handle the authentication instead of Event Store. A sample configuration is to enable OAuth2 with the following steps: Configure Event Store to run on the local loopback. Configure nginx to handle OAuth2 authentication. After authenticating the user, nginx rewrites the request and forwards it to the loopback to the Event Store that serves the request. The header has the form of {user}; group, group1 and the Event Store ACLs use the information to handle security. ES-TrustedAuth: \"root; admin, other\" Note This feature is DISABLED by default. You must specifically opt into this feature by running Event Store with the Enable Trusted Intermediary configuration or command line option ."
  },
  "http-api/optional-http-headers/resolve-linkto/index.html": {
    "href": "http-api/optional-http-headers/resolve-linkto/index.html",
    "title": "Optional HTTP Headers: Resolve LinkTo | Event Store",
    "keywords": "Optional HTTP Headers: Resolve LinkTo When using projections you can have links placed into another stream. By default Event Store always resolve linkTo s for you returning the event that points to the link. You can use the ES-ResolveLinkTos: false HTTP header to tell Event Store to return you the actual link and to not resolve it. You can see the differences in behaviour in the following cURL commands. Request Response curl -i http://127.0.0.1:2113/streams/shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167/0 -H \"accept:application/vnd.eventstore.atom+json\" -H \"ES-ResolveLinkTos: true\" HTTP/1.1 200 OK Access-Control-Allow-Methods: GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Cache-Control: max-age=31536000, public Vary: Accept Content-Type: application/vnd.eventstore.atom+json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Tue, 28 Aug 2018 13:13:49 GMT Content-Length: 918 Keep-Alive: timeout=15,max=100 { \"title\": \"0@shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167\", \"id\": \"http://127.0.0.1:2113/streams/shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167/0\", \"updated\": \"2018-08-28T12:56:15.263731Z\", \"author\": { \"name\": \"EventStore\" }, \"summary\": \"ItemAdded\", \"content\": { \"eventStreamId\": \"shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167\", \"eventNumber\": 0, \"eventType\": \"ItemAdded\", \"eventId\": \"b989fe21-9469-4017-8d71-9820b8dd1167\", \"data\": { \"Description\": \"Xbox One Elite (Console)\" }, \"metadata\": { \"TimeStamp\": \"2016-12-23T10:00:00.9225401+01:00\" } }, \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167/0\", \"relation\": \"edit\" }, { \"uri\": \"http://127.0.0.1:2113/streams/shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167/0\", \"relation\": \"alternate\" } ] } Note The content links are pointing to the original projection stream. The linked events are resolved back to where they point. With the header set the links (or embedded content) instead point back to the actual linkTo events. Request Response curl -i http://127.0.0.1:2113/streams/shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167/0 -H \"accept:application/vnd.eventstore.atom+json\" -H \"ES-ResolveLinkTos: false\" HTTP/1.1 200 OK Access-Control-Allow-Methods: GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Cache-Control: max-age=31536000, public Vary: Accept Content-Type: application/vnd.eventstore.atom+json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Tue, 28 Aug 2018 13:22:09 GMT Content-Length: 918 Keep-Alive: timeout=15,max=100 { \"title\": \"0@shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167\", \"id\": \"http://127.0.0.1:2113/streams/shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167/0\", \"updated\": \"2018-08-28T12:56:15.263731Z\", \"author\": { \"name\": \"EventStore\" }, \"summary\": \"ItemAdded\", \"content\": { \"eventStreamId\": \"shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167\", \"eventNumber\": 0, \"eventType\": \"ItemAdded\", \"eventId\": \"b989fe21-9469-4017-8d71-9820b8dd1167\", \"data\": { \"Description\": \"Xbox One Elite (Console)\" }, \"metadata\": { \"TimeStamp\": \"2016-12-23T10:00:00.9225401+01:00\" } }, \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167/0\", \"relation\": \"edit\" }, { \"uri\": \"http://127.0.0.1:2113/streams/shoppingCart-b989fe21-9469-4017-8d71-9820b8dd1167/0\", \"relation\": \"alternate\" } ] }"
  },
  "http-api/stream-metadata/index.html": {
    "href": "http-api/stream-metadata/index.html",
    "title": "Stream metadata | Event Store",
    "keywords": "Stream metadata Every stream in Event Store has metadata stream associated with it, prefixed by $$ , so the metadata stream from a stream called foo is $$foo . Internally, the metadata includes information such as the ACL of the stream, the maximum count and age for the events in the stream. Client code can also add information into stream metadata for use with projections or the client API. Stream metadata is stored internally as JSON, and you can access it over the HTTP API. Reading stream metadata To read the metadata, issue a GET request to the attached metadata resource, which is typically of the form: http://{eventstore-ip-address}/streams/{stream-name}/metadata You should not access metadata by constructing this URL yourself, as the right to change the resource address is reserved. Instead, you should follow the link from the stream itself, which enables your client to tolerate future changes to the addressing structure. Request Response curl -i -H \"Accept:application/vnd.eventstore.atom+json\" http://127.0.0.1:2113/streams/%24users --user admin:changeit HTTP/1.1 200 OK Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Cache-Control: max-age=0, no-cache, must-revalidate Vary: Accept ETag: \"3;-2060438500\" Content-Type: application/vnd.eventstore.atom+json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Thu, 23 Aug 2018 10:03:34 GMT Content-Length: 2670 Keep-Alive: timeout=15,max=100 { \"title\": \"Event stream '$users'\", \"id\": \"http://127.0.0.1:2113/streams/%24users\", \"updated\": \"2018-08-23T09:19:37.880827Z\", \"streamId\": \"$users\", \"author\": { \"name\": \"EventStore\" }, \"headOfStream\": true, \"selfUrl\": \"http://127.0.0.1:2113/streams/%24users\", \"eTag\": \"3;-2060438500\", \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/%24users\", \"relation\": \"self\" }, { \"uri\": \"http://127.0.0.1:2113/streams/%24users/head/backward/20\", \"relation\": \"first\" }, { \"uri\": \"http://127.0.0.1:2113/streams/%24users/4/forward/20\", \"relation\": \"previous\" }, { \"uri\": \"http://127.0.0.1:2113/streams/%24users/metadata\", \"relation\": \"metadata\" } ], \"entries\": [ ] } Once you have the URI of the metadata stream, issue a GET request to retrieve the metadata: Request curl -i -H \"Accept:application/vnd.eventstore.atom+json\" http://127.0.0.1:2113/streams/%24users/metadata --user admin:changeit If you have security enabled, reading metadata may require that you pass credentials, as in the examples above. If credentials are required and you do not pass them, then you receive a '401 Unauthorized' response. Request Response curl -i -H \"Accept:application/vnd.eventstore.atom+json\" http://127.0.0.1:2113/streams/%24users HTTP/1.1 401 Unauthorized Access-Control-Allow-Methods: GET, POST, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion WWW-Authenticate: Basic realm=\"ES\" Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Thu, 23 Aug 2018 10:26:52 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 Writing metadata To update the metadata for a stream, issue a POST request to the metadata resource. Inside a file named metadata.json : [ { \"eventId\": \"7c314750-05e1-439f-b2eb-f5b0e019be72\", \"eventType\": \"$user-updated\", \"data\": { \"readRole\": \"$all\", \"metaReadRole\": \"$all\" } } ] You can also add user-specified metadata here. Some examples user-specified metadata are: Which adapter populates a stream. Which projection created a stream. A correlation ID to a business process. You then post this information is then posted to the stream: Request Response curl -i -d @metadata.json http://127.0.0.1:2113/streams/%24users/metadata --user admin:changeit -H \"Content-Type: application/vnd.eventstore.events+json\" HTTP/1.1 201 Created Access-Control-Allow-Methods: GET, POST, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Location: http://127.0.0.1:2113/streams/%24%24%24users/0 Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Thu, 23 Aug 2018 10:35:19 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 If the specified user does not have permissions to write to the stream metadata, you receive a '401 Unauthorized' response."
  },
  "http-api/security/index.html": {
    "href": "http-api/security/index.html",
    "title": "Security | Event Store",
    "keywords": "Security Event Store supports basic authentication for HTTP API calls, and access control lists (ACL). Authentication Creating users Event Store supports basic HTTP authentication to internal users. You create these users with the RESTful API or the admin console. You need to use the credentials of the default user in the request, which has the user name of admin , and the password of changeit . Request Response curl -i -d \"@new-user.json\" \"http://127.0.0.1:2113/users\" -H \"Content-Type:application/json\" HTTP/1.1 201 Created Access-Control-Allow-Methods: GET, POST, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Location: http://127.0.0.1:2113/users/adminuser Content-Type: application/json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Thu, 23 Aug 2018 09:08:40 GMT Content-Length: 90 Keep-Alive: timeout=15,max=100 { \"loginName\": \"adminuser\", \"success\": true, \"error\": \"Success\", \"msgTypeId\": 50 }% Once you have added users, you can use their details with requests. Note You can also use the 'trusted intermediary' header for externalized authentication that allows you to integrate almost any authentication system with Event Store. Read more about the trusted intermediary header . If you were to use the wrong user or no user when a request requires one, you receive a 401 Unauthorized response. Request Response curl -i 'http://127.0.0.1:2113/streams/$all' -u admin:password HTTP/1.1 401 Unauthorized Access-Control-Allow-Methods: Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion WWW-Authenticate: Basic realm=\"ES\" Content-Type: Server: Mono-HTTPAPI/1.0 Date: Thu, 23 Aug 2018 09:27:34 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 As you pass the username and password in the request we recommend you run Event Store over HTTP, and enable SSL to encrypt the user information. Read this guide for instructions . If you are running the clustered version you can also setup SSL for the replication protocol. <!-- TODO: Does this need further explanation? Any more details anywhere? --> Access control lists Alongside authentication, Event Store supports per stream configuration of Access Control Lists (ACL). To configure the ACL of a stream go to its head and look for the metadata relationship link to fetch the metadata for the stream. To set access control lists over HTTP you can post to the metadata stream as with setting any other metadata . You can also set Access Control Lists for a stream in the admin UI. For more information on the structure of Access Control Lists read Access Control Lists . <!-- TODO: Merge ACL here? -->"
  },
  "http-api/reading-streams/index.html": {
    "href": "http-api/reading-streams/index.html",
    "title": "Reading streams and events | Event Store",
    "keywords": "Reading streams and events Reading a stream Event Store exposes streams as a resource located at http(s)://{yourdomain.com}:{port}/streams/{stream} . If you issue a simple GET request to this resource, you receive a standard AtomFeed document as a response. Request Response curl -i -H \"Accept:application/vnd.eventstore.atom+json\" \"http://127.0.0.1:2113/streams/newstream\" HTTP/1.1 200 OK Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Cache-Control: max-age=0, no-cache, must-revalidate Vary: Accept ETag: \"0;-2060438500\" Content-Type: application/vnd.eventstore.atom+json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 15 Dec 2017 12:23:23 GMT Content-Length: 1262 Keep-Alive: timeout=15,max=100 { \"title\": \"Event stream 'newstream'\", \"id\": \"http://127.0.0.1:2113/streams/newstream\", \"updated\": \"2017-12-15T12:19:32.021776Z\", \"streamId\": \"newstream\", \"author\": { \"name\": \"EventStore\" }, \"headOfStream\": true, \"selfUrl\": \"http://127.0.0.1:2113/streams/newstream\", \"eTag\": \"0;-2060438500\", \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream\", \"relation\": \"self\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/head/backward/20\", \"relation\": \"first\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/1/forward/20\", \"relation\": \"previous\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/metadata\", \"relation\": \"metadata\" } ], \"entries\": [ { \"title\": \"0@newstream\", \"id\": \"http://127.0.0.1:2113/streams/newstream/0\", \"updated\": \"2017-12-15T12:19:32.021776Z\", \"author\": { \"name\": \"EventStore\" }, \"summary\": \"event-type\", \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream/0\", \"relation\": \"edit\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/0\", \"relation\": \"alternate\" } ] } ] } Reading an event from a stream The feed has one item in it, and if there are more than one, then items are sorted from newest to oldest. For each entry, there are a series of links to the actual events, we cover embedding data into a stream later . To GET an event, follow the alternate link and set your Accept headers to the mime type you would like the event in. The accepted content types for GET requests are: application/xml application/atom+xml application/json application/vnd.eventstore.atom+json text/xml text/html The non-atom version of the event has fewer details about the event. Request Response curl -i http://127.0.0.1:2113/streams/newstream/0 -H \"Accept: application/json\" HTTP/1.1 200 OK Access-Control-Allow-Methods: GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER Access-Control-Allow-Origin: * Cache-Control: max-age=31536000, public Vary: Accept Content-Type: application/json; charset: utf-8 Server: Mono-HTTPAPI/1.0 Date: Wed, 03 Jul 2013 11:09:12 GMT Content-Length: 14 Keep-Alive: timeout=15,max=100 { \"a\": \"1\" } Feed paging The next step in understanding how to read a stream is the first / last / previous / next links within a stream. Event Store supplies these links so you can read through a stream, and they follow the pattern defined in RFC 5005 . In the example above the server returned the following links as part of its result: \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream\", \"relation\": \"self\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/head/backward/20\", \"relation\": \"first\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/2/forward/20\", \"relation\": \"previous\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/metadata\", \"relation\": \"metadata\" } ], This shows that there is not a next URL as all the information is in this request and that the URL requested is the first link. When dealing with these URLs, there are two ways of reading the data in the stream. You GET the last link and move backwards following previous links, or You GET the first link and follow the next links, and the final item will not have a next link. If you want to follow a live stream, then you keep following the previous links. When you reach the end of a stream, you receive an empty document with no entries or previous link. You then continue polling this URI (in the future a document will appear). You can see this by trying the previous link from the above feed. Request Response curl -i http://127.0.0.1:2113/streams/newstream/1/forward/20 -H \"Accept:application/vnd.eventstore.atom+json\" HTTP/1.1 200 OK Access-Control-Allow-Methods: GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTo, ES-ExpectedVersion Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position Cache-Control: max-age=0, no-cache, must-revalidate Vary: Accept ETag: \"0;248368668\" Content-Type: application/vnd.eventstore.atom+json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 13 Mar 2015 14:04:47 GMT Content-Length: 795 Keep-Alive: timeout=15,max=100 { \"title\": \"Event stream 'newstream'\", \"id\": \"<http://127.0.0.1:2113/streams/newstream\">, \"updated\": \"0001-01-01T00:00:00Z\", \"streamId\": \"newstream\", \"author\": { \"name\": \"EventStore\" }, \"headOfStream\": false, \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream\", \"relation\": \"self\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/head/backward/20\", \"relation\": \"first\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/0/forward/20\", \"relation\": \"last\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/0/backward/20\", \"relation\": \"next\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/metadata\", \"relation\": \"metadata\" } ], \"entries\": \\[] } When parsing an atom subscription, the IDs of events always stay the same. This is important for figuring out if you are referring to the same event. Paging through events Let's now try an example with more than a single page. First create the multiple events: Request Response curl -i -d \"@paging-events.json\" \"http://127.0.0.1:2113/streams/alphabet\" -H \"Content-Type:application/vnd.eventstore.events+json\" HTTP/1.1 100 Continue HTTP/1.1 201 Created Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Location: http://127.0.0.1:2113/streams/alphabet/0 Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Tue, 21 Aug 2018 09:53:46 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 If you request the stream of events, you see a series of links above the events: Request Response curl -i http://127.0.0.1:2113/streams/alphabet -H \"Accept:application/vnd.eventstore.atom+json\" HTTP/1.1 200 OK Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Cache-Control: max-age=0, no-cache, must-revalidate Vary: Accept ETag: \"26;-2060438500\" Content-Type: application/vnd.eventstore.atom+json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Tue, 21 Aug 2018 10:12:31 GMT Content-Length: 10727 Keep-Alive: timeout=15,max=100 { \"title\": \"Event stream 'alphabet'\", \"id\": \"http://127.0.0.1:2113/streams/alphabet\", \"updated\": \"2018-08-21T09:53:46.869815Z\", \"streamId\": \"alphabet\", \"author\": { \"name\": \"EventStore\" }, \"headOfStream\": true, \"selfUrl\": \"http://127.0.0.1:2113/streams/alphabet\", \"eTag\": \"26;-2060438500\", \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/alphabet\", \"relation\": \"self\" }, { \"uri\": \"http://127.0.0.1:2113/streams/alphabet/head/backward/20\", \"relation\": \"first\" }, { \"uri\": \"http://127.0.0.1:2113/streams/alphabet/0/forward/20\", \"relation\": \"last\" }, { \"uri\": \"http://127.0.0.1:2113/streams/alphabet/6/backward/20\", \"relation\": \"next\" }, { \"uri\": \"http://127.0.0.1:2113/streams/alphabet/27/forward/20\", \"relation\": \"previous\" }, { \"uri\": \"http://127.0.0.1:2113/streams/alphabet/metadata\", \"relation\": \"metadata\" } ], \"entries\": [ ] } Using the links in the stream of events, you can traverse through all the events in the stream by going to the last URL and following previous links, or by following next links from the first link. For example, if you request the last link from above: Request Response curl -i http://127.0.0.1:2113/streams/alphabet/0/forward/20 -H \"Accept:application/vnd.eventstore.atom+json\" HTTP/1.1 200 OK Access-Control-Allow-Methods: GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Cache-Control: max-age=31536000, public Vary: Accept Content-Type: application/vnd.eventstore.atom+json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Tue, 21 Aug 2018 10:24:28 GMT Content-Length: 10403 Keep-Alive: timeout=15,max=100 { \"title\": \"Event stream 'alphabet'\", \"id\": \"http://127.0.0.1:2113/streams/alphabet\", \"updated\": \"2018-08-21T09:53:46.869716Z\", \"streamId\": \"alphabet\", \"author\": { \"name\": \"EventStore\" }, \"headOfStream\": false, \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/alphabet\", \"relation\": \"self\" }, { \"uri\": \"http://127.0.0.1:2113/streams/alphabet/head/backward/20\", \"relation\": \"first\" }, { \"uri\": \"http://127.0.0.1:2113/streams/alphabet/20/forward/20\", \"relation\": \"previous\" }, { \"uri\": \"http://127.0.0.1:2113/streams/alphabet/metadata\", \"relation\": \"metadata\" } ], \"entries\": [ ] } You then follow previous links until you are back to the head of the stream, where you can continue reading events in real time by polling the previous link. Note All links except the head link are fully cacheable as you can see in the HTTP header Cache-Control: max-age=31536000, public . This is important when discussing intermediaries and performance as you commonly replay a stream from storage. You should never bookmark links aside from the head of the stream resource, and always follow links. We may in the future change how internal links work, and bookmarking links other than the head may break. Reading all events $all is a special paged stream for all events. You can use the same paged form of reading described above to read all events for a node by pointing the stream at /streams/$all . As it's a stream like any other, you can perform all operations, except posting to it. Note To access the $all stream, you must use admin details. Find more information on the security page. Request Response curl -i http://127.0.0.1:2113/streams/%24all -H \"Accept:application/vnd.eventstore.atom+json\" -u admin:changeit HTTP/1.1 200 OK Access-Control-Allow-Methods: POST, DELETE, GET, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTo, ES-ExpectedVersion Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position Cache-Control: max-age=0, no-cache, must-revalidate Vary: Accept ETag: \"25159393;248368668\" Content-Type: application/vnd.eventstore.atom+json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 13 Mar 2015 16:19:09 GMT Content-Length: 12157 Keep-Alive: timeout=15,max=100 { \"title\": \"All events\", \"id\": \"<http://127.0.0.1:2113/streams/%24all\">, \"updated\": \"2015-03-13T16:19:06.548415Z\", \"author\": { \"name\": \"EventStore\" }, \"headOfStream\": false, \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/%24all\", \"relation\": \"self\" }, { \"uri\": \"http://127.0.0.1:2113/streams/%24all/head/backward/20\", \"relation\": \"first\" }, { \"uri\": \"http://127.0.0.1:2113/streams/%24all/00000000000000000000000000000000/forward/20\", \"relation\": \"last\" }, { \"uri\": \"http://127.0.0.1:2113/streams/%24all/00000000017BC0D000000000017BC0D0/backward/20\", \"relation\": \"next\" }, { \"uri\": \"http://127.0.0.1:2113/streams/%24all/0000000001801EBF0000000001801EBF/forward/20\", \"relation\": \"previous\" }, { \"uri\": \"http://127.0.0.1:2113/streams/%24all/metadata\", \"relation\": \"metadata\" } ], \"entries\": [] # TODO: Make complete Conditional GETs The head link supports conditional GET s with the use of ETAGS , a well-known HTTP construct. You can include the ETAG of your last request and issue a conditional GET to the server. If nothing has changed, it won't return the full feed. For example the earlier request has an ETAG: Request Response curl -i http://127.0.0.1:2113/streams/alphabet -H \"Accept:application/vnd.eventstore.atom+json\" ETag: \"26;-2060438500\" You can use this in your next request when polling the stream for changes by putting it in the If-None-Match header. This tells the server to check if the response is the one you already know and returning a '304 not modified' response. If the tags have changed, the server returns a '200 OK' response. You can use this method to optimise your application by not sending large streams if there are no changes. Request Response curl -i http://127.0.0.1:2113/streams/alphabet -H \"Accept:application/vnd.eventstore.atom+json\" -H \"If-None-Match:26;-2060438500\" HTTP/1.1 304 Not Modified Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-Forwarded-Host, X-Forwarded-Prefix, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTos Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position, ES-CurrentVersion Content-Type: text/plain; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Tue, 21 Aug 2018 12:07:35 GMT Content-Length: 0 Keep-Alive: timeout=15,max=100 Note You create Etags using the version of the stream and the media type of the stream you are reading. You can't read an Etag from a stream in one media type and use it with another media type. Embedding data into streams in JSON format So far in this guide, the feeds returned have contained links that refer to the actual event data. This is normally a preferable mechanism for several reasons: They can be in a different media type than the feed, and you can negotiate them separately from the feed itself (for example, the feed in JSON, the event in XML). You can cache the event data separately from the feed, and you can point it to different feeds. If you use a linkTo() in your projection this is what happens in your atom feeds. If you are using JSON, you can embed the events into the atom feed events. This can help cut down on the number of requests in some situations, but the messages are larger. There are ways of embedding events and further metadata into your stream by using the embed= parameter. Rich embed mode The rich embed mode returns more properties about the event ( eventtype , streamid , position , and so on) as you can see in the following request. Request Response curl -i -H \"Accept:application/vnd.eventstore.atom+json\" \"http://127.0.0.1:2113/streams/newstream?embed=rich\" HTTP/1.1 200 OK Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTo, ES-ExpectedVersion Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position Cache-Control: max-age=0, no-cache, must-revalidate Vary: Accept ETag: \"0;248368668\" Content-Type: application/vnd.eventstore.atom+json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 13 Mar 2015 16:30:57 GMT Content-Length: 1570 Keep-Alive: timeout=15,max=100 { \"title\": \"Event stream 'newstream'\", \"id\": \"<http://127.0.0.1:2113/streams/newstream\">, \"updated\": \"2015-03-13T12:13:42.492473Z\", \"streamId\": \"newstream\", \"author\": { \"name\": \"EventStore\" }, \"headOfStream\": true, \"selfUrl\": \"<http://127.0.0.1:2113/streams/newstream\">, \"eTag\": \"0;248368668\", \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream\", \"relation\": \"self\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/head/backward/20\", \"relation\": \"first\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/1/forward/20\", \"relation\": \"previous\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/metadata\", \"relation\": \"metadata\" } ], \"entries\": [ { \"eventId\": \"fbf4a1a1-b4a3-4dfe-a01f-ec52c34e16e4\", \"eventType\": \"event-type\", \"eventNumber\": 0, \"streamId\": \"newstream\", \"isJson\": true, \"isMetaData\": false, \"isLinkMetaData\": false, \"positionEventNumber\": 0, \"positionStreamId\": \"newstream\", \"title\": \"0@newstream\", \"id\": \"<http://127.0.0.1:2113/streams/newstream/0\">, \"updated\": \"2015-03-13T12:13:42.492473Z\", \"author\": { \"name\": \"EventStore\" }, \"summary\": \"event-type\", \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream/0\", \"relation\": \"edit\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/0\", \"relation\": \"alternate\" } ] } ] } Body embed mode The body embed mode returns the JSON/XML body of the events into the feed as well, depending on the type of the feed. You can see this in the request below: Request Response curl -i -H \"Accept:application/vnd.eventstore.atom+json\" \"http://127.0.0.1:2113/streams/newstream?embed=body\" HTTP/1.1 200 OK Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTo, ES-ExpectedVersion Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position Cache-Control: max-age=0, no-cache, must-revalidate Vary: Accept ETag: \"0;248368668\" Content-Type: application/vnd.eventstore.atom+json; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 13 Mar 2015 16:32:06 GMT Content-Length: 1608 Keep-Alive: timeout=15,max=100 { \"title\": \"Event stream 'newstream'\", \"id\": \"<http://127.0.0.1:2113/streams/newstream\">, \"updated\": \"2015-03-13T12:13:42.492473Z\", \"streamId\": \"newstream\", \"author\": { \"name\": \"EventStore\" }, \"headOfStream\": true, \"selfUrl\": \"<http://127.0.0.1:2113/streams/newstream\">, \"eTag\": \"0;248368668\", \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream\", \"relation\": \"self\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/head/backward/20\", \"relation\": \"first\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/1/forward/20\", \"relation\": \"previous\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/metadata\", \"relation\": \"metadata\" } ], \"entries\": \\[ { \"eventId\": \"fbf4a1a1-b4a3-4dfe-a01f-ec52c34e16e4\", \"eventType\": \"event-type\", \"eventNumber\": 0, \"data\": \"{\\\\n \"a\": \"1\"\\\\n}\", \"streamId\": \"newstream\", \"isJson\": true, \"isMetaData\": false, \"isLinkMetaData\": false, \"positionEventNumber\": 0, \"positionStreamId\": \"newstream\", \"title\": \"0@newstream\", \"id\": \"<http://127.0.0.1:2113/streams/newstream/0\">, \"updated\": \"2015-03-13T12:13:42.492473Z\", \"author\": { \"name\": \"EventStore\" }, \"summary\": \"event-type\", \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream/0\", \"relation\": \"edit\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream/0\", \"relation\": \"alternate\" } ] } ] } Variants of body embed mode Two other modes are variants of body : PrettyBody tries to reformat the JSON to make it \"pretty to read\". TryHarder works harder to try to parse and reformat the JSON from an event to return it in the feed. These do not include further information and are focused on how the feed looks. Embedding data into streams in XML format The XML format embeds no additional data, as only JSON supports embedding. Request Response curl -i -H \"Accept:application/atom+xml\" \"http://127.0.0.1:2113/streams/newstream?embed=body\" HTTP/1.1 200 OK Access-Control-Allow-Methods: POST, DELETE, GET, OPTIONS Access-Control-Allow-Headers: Content-Type, X-Requested-With, X-PINGOTHER, Authorization, ES-LongPoll, ES-ExpectedVersion, ES-EventId, ES-EventType, ES-RequiresMaster, ES-HardDelete, ES-ResolveLinkTo, ES-ExpectedVersion Access-Control-Allow-Origin: * Access-Control-Expose-Headers: Location, ES-Position Cache-Control: max-age=0, no-cache, must-revalidate Vary: Accept ETag: \"0;-1296467268\" Content-Type: application/atom+xml; charset=utf-8 Server: Mono-HTTPAPI/1.0 Date: Fri, 13 Mar 2015 16:32:56 GMT Content-Length: 929 Keep-Alive: timeout=15,max=100 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <feed xmlns=\"http://www.w3.org/2005/Atom\"> <title>Event stream 'newstream'</title> <id>http://127.0.0.1:2113/streams/newstream</id> <updated>2013-06-29T15:12:53.570125Z</updated> <author> <name>EventStore</name> </author> <link href=\"http://127.0.0.1:2113/streams/newstream\" rel=\"self\" /> <link href=\"http://127.0.0.1:2113/streams/newstream/head/backward/20\" rel=\"first\" /> <link href=\"http://127.0.0.1:2113/streams/newstream/0/forward/20\" rel=\"last\" /> <link href=\"http://127.0.0.1:2113/streams/newstream/1/forward/20\" rel=\"previous\" /> <link href=\"http://127.0.0.1:2113/streams/newstream/metadata\" rel=\"metadata\" /> <entry> <title>0@newstream</title> <id>http://127.0.0.1:2113/streams/newstream/0</id> <updated>2013-06-29T15:12:53.570125Z</updated> <author> <name>EventStore</name> </author> <summary>event-type</summary> <link href=\"http://127.0.0.1:2113/streams/newstream/0\" rel=\"edit\" /> <link href=\"http://127.0.0.1:2113/streams/newstream/0\" rel=\"alternate\" /> </entry> </feed>"
  },
  "http-api/optimistic-concurrency-and-idempotence/index.html": {
    "href": "http-api/optimistic-concurrency-and-idempotence/index.html",
    "title": "Optimistic concurrency and idempotence | Event Store",
    "keywords": "Optimistic concurrency and idempotence Idempotency All operations on the HTTP interface are idempotent (unless the expected version is ignored). It is the responsibility of the client to retry operations under failure conditions, ensuring that the event IDs of the events posted are the same as the first attempt. Provided the client maintains this Event Store will treat all operations as idempotent. For example: Request Response curl -i -d @event.txt \"http://127.0.0.1:2113/streams/newstream\" HTTP/1.1 201 Created Access-Control-Allow-Origin: * Access-Control-Allow-Methods: POST, GET, PUT, DELETE Location: http://127.0.0.1:2113/streams/newstream444/1 Content-Type: application/json Server: Mono-HTTPAPI/1.0 Date: Thu, 06 Sep 2012 19:49:37 GMT Content-Length: 107 Keep-Alive: timeout=15,max=100 <!-- TODO: What's this? --> Request Response curl -i -d @event.txt \"http://127.0.0.1:2113/streams/newstream444\" HTTP/1.1 201 Created Access-Control-Allow-Origin: * Access-Control-Allow-Methods: POST, GET, PUT, DELETE Location: http://127.0.0.1:2113/streams/newstream444/1 Content-Type: application/json Server: Mono-HTTPAPI/1.0 Date: Thu, 06 Sep 2012 19:49:37 GMT Content-Length: 107 Keep-Alive: timeout=15,max=100 Assuming you were posting to a new stream you would get the event written once (and the stream created). The second event will return as the first but not write again. Note This allows the client rule of if you get an unknown condition, retry to work. For example: Request Response curl -i \"http://127.0.0.1:2113/streams/newstream444\" HTTP/1.1 200 OK Access-Control-Allow-Origin: * Access-Control-Allow-Methods: POST, GET, PUT, DELETE Content-Type: application/json Server: Mono-HTTPAPI/1.0 Date: Thu, 06 Sep 2012 19:50:30 GMT Content-Length: 2131 Keep-Alive: timeout=15,max=100 { \"title\": \"Event stream 'newstream444'\", \"id\": \"http://127.0.0.1:2113/streams/newstream444\", \"updated\": \"2012-09-06T16:39:44.695643Z\", \"author\": { \"name\": \"EventStore\" }, \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream444\", \"relation\": \"self\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream444\", \"relation\": \"first\" } ], \"entries\": [ { \"title\": \"newstream444 #1\", \"id\": \"http://127.0.0.1:2113/streams/newstream444/1\", \"updated\": \"2012-09-06T16:39:44.695643Z\", \"author\": { \"name\": \"EventStore\" }, \"summary\": \"Entry #1\", \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream444/1\", \"relation\": \"edit\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream444/event/1?format=text\", \"type\": \"text/plain\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream444/event/1?format=json\", \"relation\": \"alternate\", \"type\": \"application/json\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream444/event/1?format=xml\", \"relation\": \"alternate\", \"type\": \"text/xml\" } ] }, { \"title\": \"newstream444 #0\", \"id\": \"http://127.0.0.1:2113/streams/newstream444/0\", \"updated\": \"2012-09-06T16:39:44.695631Z\", \"author\": { \"name\": \"EventStore\" }, \"summary\": \"Entry #0\", \"links\": [ { \"uri\": \"http://127.0.0.1:2113/streams/newstream444/0\", \"relation\": \"edit\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream444/event/0?format=text\", \"type\": \"text/plain\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream444/event/0?format=json\", \"relation\": \"alternate\", \"type\": \"application/json\" }, { \"uri\": \"http://127.0.0.1:2113/streams/newstream444/event/0?format=xml\", \"relation\": \"alternate\", \"type\": \"text/xml\" } ] } ] } <!-- TODO: Still to do -->"
  },
  "http-api/swagger/Update a user.html": {
    "href": "http-api/swagger/Update a user.html",
    "title": "Update a user | Event Store",
    "keywords": "Update a user Update the FullName of Groups of the specified user. Request PUT /users/{login} Parameters Name Type Value Notes *login string The user's name userUpdateItem object Name Type Notes FullName string The full name of the new user. Groups array The groups the new user should become a member of. User to update Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Delete a user.html": {
    "href": "http-api/swagger/Delete a user.html",
    "title": "Delete a user | Event Store",
    "keywords": "Delete a user Delete specified user. Request DELETE /users/{login} Parameters Name Type Value Notes *login string The user's name Responses Status Code Description Samples 204 User deleted"
  },
  "http-api/swagger/Enable a user.html": {
    "href": "http-api/swagger/Enable a user.html",
    "title": "Enable a user | Event Store",
    "keywords": "Enable a user Enable the acount of the specified user. Request PUT /users/{login}/command/enable Parameters Name Type Value Notes *login string The user's name Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Disable a user.html": {
    "href": "http-api/swagger/Disable a user.html",
    "title": "Disable a user | Event Store",
    "keywords": "Disable a user Disable the acount of the specified user. Request PUT /users/{login}/command/disable Parameters Name Type Value Notes *login string The user's name Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Reset password.html": {
    "href": "http-api/swagger/Reset password.html",
    "title": "Reset password | Event Store",
    "keywords": "Reset password Reset the password of the specified user. Request POST /users/{login}/command/reset-password Parameters Name Type Value Notes *login string The user's name *newPassword object Name Type Notes NewPassword string The new password for the user The new password for the user Responses Status Code Description Samples 200 OK 400 Bad request"
  },
  "http-api/swagger/Change password.html": {
    "href": "http-api/swagger/Change password.html",
    "title": "Change password | Event Store",
    "keywords": "Change password Change the password of the specified user. Request POST /users/{login}/command/change-password Parameters Name Type Value Notes *login string The user's name *newPassword object Name Type Notes CurrentPassword string The current password for the user NewPassword string The new password for the user The new password for the user Responses Status Code Description Samples 200 OK 400 Bad request"
  },
  "http-api/swagger/Get all projections.html": {
    "href": "http-api/swagger/Get all projections.html",
    "title": "Get all projections | Event Store",
    "keywords": "Get all projections Returns all projections defined in Event Store. Request GET /projections/any Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Get all non-transient projections.html": {
    "href": "http-api/swagger/Get all non-transient projections.html",
    "title": "Get all non-transient projections | Event Store",
    "keywords": "Get all non-transient projections Returns all known projections except ad-hoc projections. Request GET /projections/all-non-transient Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Get all queries.html": {
    "href": "http-api/swagger/Get all queries.html",
    "title": "Get all queries | Event Store",
    "keywords": "Get all queries Returns all queries defined in Event Store. Request GET /projections/onetime Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Create a onetime projection.html": {
    "href": "http-api/swagger/Create a onetime projection.html",
    "title": "Create a onetime projection | Event Store",
    "keywords": "Create a onetime projection Create a new onetime projection. Request POST /projections/onetime[?name&type&enabled&checkpoints&emit&trackemittedstreams] Parameters Name Type Value Notes name string Name of the projection type string The projection type enabled boolean Is the projection enabled checkpoints boolean Are checkpoints enabled emit boolean Is emit enabled trackemittedstreams boolean Should your projection create a separate stream and write any streams it emits to that stream. Responses Status Code Description Samples 201 New projection created 400 Bad request"
  },
  "http-api/swagger/Get all continious projections.html": {
    "href": "http-api/swagger/Get all continious projections.html",
    "title": "Get all continious projections | Event Store",
    "keywords": "Get all continious projections Returns all continually running projections defined in Event Store. Request GET /projections/continuous Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Create a continious projection.html": {
    "href": "http-api/swagger/Create a continious projection.html",
    "title": "Create a continious projection | Event Store",
    "keywords": "Create a continious projection Create a new continious projection. Request POST /projections/continuous[?name&enabled&checkpoints&emit&type&trackemittedstreams] Parameters Name Type Value Notes name string Name of the projection enabled boolean Is the projection enabled checkpoints boolean Are checkpoints enabled emit boolean Is emit enabled type string The projection type trackemittedstreams boolean Should your projection create a separate stream and write any streams it emits to that stream. Responses Status Code Description Samples 201 New projection created 400 Bad request"
  },
  "http-api/swagger/Read projection events based on a query.html": {
    "href": "http-api/swagger/Read projection events based on a query.html",
    "title": "Read projection events based on a query | Event Store",
    "keywords": "Read projection events based on a query Read events from projection based on a query definition, i.e. fromAll, fromStream, fromStreams Request POST /projections/read-events Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Get all transient projections.html": {
    "href": "http-api/swagger/Get all transient projections.html",
    "title": "Get all transient projections | Event Store",
    "keywords": "Get all transient projections Returns all transient projections defined in Event Store. Request GET /projections/transient Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Create a transient projection.html": {
    "href": "http-api/swagger/Create a transient projection.html",
    "title": "Create a transient projection | Event Store",
    "keywords": "Create a transient projection Create a new transient projection. Request POST /projections/transient[?name&type&enabled] Parameters Name Type Value Notes name string Name of the projection type string The projection type enabled boolean Is the projection enabled Responses Status Code Description Samples 201 New user created 400 Bad request"
  },
  "http-api/swagger/Get projection definition.html": {
    "href": "http-api/swagger/Get projection definition.html",
    "title": "Get projection definition | Event Store",
    "keywords": "Get projection definition Returns definition of the specified projection. Request GET /projection/{name}/query[?config] Parameters Name Type Value Notes *name string The name of the projection config boolean Wether to return the projection definition config. Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Update projection definition.html": {
    "href": "http-api/swagger/Update projection definition.html",
    "title": "Update projection definition | Event Store",
    "keywords": "Update projection definition Update the specified projection definition. Request PUT /projection/{name}/query[?type&emit] Parameters Name Type Value Notes *name string The name of the projection type string The projection type emit boolean Is emit enabled Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Get the projection state.html": {
    "href": "http-api/swagger/Get the projection state.html",
    "title": "Get the projection state | Event Store",
    "keywords": "Get the projection state Return the current state of the specified projection. Request GET /projection/{name}/state[?partition] Parameters Name Type Value Notes *name string The name of the projection partition string The partition name in state Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Get result of projection.html": {
    "href": "http-api/swagger/Get result of projection.html",
    "title": "Get result of projection | Event Store",
    "keywords": "Get result of projection Get the final result of a projection. Request GET /projection/{name}/result[?partition] Parameters Name Type Value Notes *name string The name of the projection partition string The partition name in state Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Get projection statistics.html": {
    "href": "http-api/swagger/Get projection statistics.html",
    "title": "Get projection statistics | Event Store",
    "keywords": "Get projection statistics Returns the statistics for a projection, such as how many events, the status etc. Request GET /projection/{name}/statistics Parameters Name Type Value Notes *name string The name of the projection Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Disable projection.html": {
    "href": "http-api/swagger/Disable projection.html",
    "title": "Disable projection | Event Store",
    "keywords": "Disable projection Disable the specified projection. Request POST /projection/{name}/command/disable[?enableRunAs] Parameters Name Type Value Notes *name string The name of the projection enableRunAs boolean Run as the user issuing the command. Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Enable projection.html": {
    "href": "http-api/swagger/Enable projection.html",
    "title": "Enable projection | Event Store",
    "keywords": "Enable projection Enable the specified projection. Request POST /projection/{name}/command/enable[?enableRunAs] Parameters Name Type Value Notes *name string The name of the projection enableRunAs boolean Run as the user issuing the command. Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Reset projection.html": {
    "href": "http-api/swagger/Reset projection.html",
    "title": "Reset projection | Event Store",
    "keywords": "Reset projection Reset the specified projection. Request POST /projection/{name}/command/reset[?enableRunAs] Parameters Name Type Value Notes *name string The name of the projection enableRunAs boolean Run as the user issuing the command. Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Abort projection.html": {
    "href": "http-api/swagger/Abort projection.html",
    "title": "Abort projection | Event Store",
    "keywords": "Abort projection Abort the specified projection. Request POST /projection/{name}/command/abort[?enableRunAs] Parameters Name Type Value Notes *name string The name of the projection enableRunAs boolean Run as the user issuing the command. Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Get projection config.html": {
    "href": "http-api/swagger/Get projection config.html",
    "title": "Get projection config | Event Store",
    "keywords": "Get projection config Returns the performance configuration of the specified projection. Request GET /projection/{name}/config Parameters Name Type Value Notes *name string The name of the projection Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Update projection config.html": {
    "href": "http-api/swagger/Update projection config.html",
    "title": "Update projection config | Event Store",
    "keywords": "Update projection config Update the performance configuration of the specified projection. Request PUT /projection/{name}/config Parameters Name Type Value Notes *name string The name of the projection Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Get a projection.html": {
    "href": "http-api/swagger/Get a projection.html",
    "title": "Get a projection | Event Store",
    "keywords": "Get a projection Returns a specific projection. Request GET /projection/{name} Parameters Name Type Value Notes *name string The name of the projection Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Delete a projection.html": {
    "href": "http-api/swagger/Delete a projection.html",
    "title": "Delete a projection | Event Store",
    "keywords": "Delete a projection Deletes a projection Request DELETE /projection/{name}[?deleteStateStream&deleteCheckpointStream&deleteEmittedStreams] Parameters Name Type Value Notes *name string The projection to delete deleteStateStream boolean TBD deleteCheckpointStream boolean TBD deleteEmittedStreams boolean TBD Responses Status Code Description Samples 204 Projection deleted"
  },
  "http-api/swagger/Get all stats.html": {
    "href": "http-api/swagger/Get all stats.html",
    "title": "Get all stats | Event Store",
    "keywords": "Get all stats Returns all stats enabled for Event Store. Request GET /stats Responses Status Code Description Samples 200 A list of stats Name Type Notes proc object Name Type Notes startTime string Time the associated process started id integer Id of the associated process mem integer Virtual memory used by the associated process cpu number CPU usage of the process cpuScaled number CPU usage of the process scaled by logical processor count threadsCount integer Number of threads used by process contentionsRate number The rate at which threads in the process attempt to acquire a managed lock unsuccessfully thrownExceptionsRate number Number of exceptions thrown per second gc object Stats on garbage collection diskIo object Disk input and output stats tcp object TCP connection stats Stats on the currently active process sys object Name Type Notes cpu number Total CPU usage in percentage freeMem number Free memory in bytes drive object Drive usage stats System usage stats es object Name Type Notes checksum number checksumNonFlushed number queue object Multiple queue instance stats writer object Storage writing stats readIndex object 404 Not found"
  },
  "http-api/swagger/Get specified stat.html": {
    "href": "http-api/swagger/Get specified stat.html",
    "title": "Get specified stat | Event Store",
    "keywords": "Get specified stat Returns the sub path of the Event Store statistics available. Request GET /stats/{statPath} Parameters Name Type Value Notes *statPath string The stats sub path Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Return Gossip details.html": {
    "href": "http-api/swagger/Return Gossip details.html",
    "title": "Return Gossip details | Event Store",
    "keywords": "Return Gossip details Return Gossip details for nodes in cluster. Request GET /gossip Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "http-api/swagger/Update Gossip details.html": {
    "href": "http-api/swagger/Update Gossip details.html",
    "title": "Update Gossip details | Event Store",
    "keywords": "Update Gossip details Update Gossip details for nodes in a cluster. Request POST /gossip Responses Status Code Description Samples 200 OK 404 Not found"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.StreamDeletedException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.StreamDeletedException.html",
    "title": "Class StreamDeletedException | Event Store",
    "keywords": "Class StreamDeletedException Exception thrown if an operation is attempted on a stream which has been deleted. Inheritance System.Object System.Exception EventStoreConnectionException StreamDeletedException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class StreamDeletedException : EventStoreConnectionException, ISerializable Constructors StreamDeletedException() Constructs a new instance of StreamDeletedException . Declaration public StreamDeletedException() StreamDeletedException(String) Constructs a new instance of StreamDeletedException . Declaration public StreamDeletedException(string stream) Parameters Type Name System.String stream Fields Stream The name of the deleted stream. Declaration public readonly string Stream Field Value Type System.String Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.ClientClosedEventArgs.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ClientClosedEventArgs.html",
    "title": "Class ClientClosedEventArgs | Event Store",
    "keywords": "Class ClientClosedEventArgs Event Arguments for the event raised when an IEventStoreConnection is disconnected from an Event Store server. Inheritance System.Object System.EventArgs ClientClosedEventArgs Inherited Members System.EventArgs.Empty System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class ClientClosedEventArgs : EventArgs Constructors ClientClosedEventArgs(IEventStoreConnection, String) Constructs a new instance of ClientClosedEventArgs . Declaration public ClientClosedEventArgs(IEventStoreConnection connection, string reason) Parameters Type Name IEventStoreConnection connection System.String reason Properties Connection The IEventStoreConnection responsible for raising the event. Declaration public IEventStoreConnection Connection { get; } Property Value Type IEventStoreConnection Reason A description of the reason the connection was closed if closing was initiated by the server or client API directly rather than by calling Close() . Declaration public string Reason { get; } Property Value Type System.String"
  },
  "dotnet-api/code/EventStore.ClientAPI.EventStoreCatchUpSubscription.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.EventStoreCatchUpSubscription.html",
    "title": "Class EventStoreCatchUpSubscription | Event Store",
    "keywords": "Class EventStoreCatchUpSubscription Base class representing catch-up subscriptions. Inheritance System.Object EventStoreCatchUpSubscription EventStoreAllCatchUpSubscription EventStoreStreamCatchUpSubscription Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public abstract class EventStoreCatchUpSubscription Constructors EventStoreCatchUpSubscription(IEventStoreConnection, ILogger, String, UserCredentials, Func<EventStoreCatchUpSubscription, ResolvedEvent, Task>, Action<EventStoreCatchUpSubscription>, Action<EventStoreCatchUpSubscription, SubscriptionDropReason, Exception>, CatchUpSubscriptionSettings) Constructs state for EventStoreCatchUpSubscription. Declaration protected EventStoreCatchUpSubscription(IEventStoreConnection connection, ILogger log, string streamId, UserCredentials userCredentials, Func<EventStoreCatchUpSubscription, ResolvedEvent, Task> eventAppeared, Action<EventStoreCatchUpSubscription> liveProcessingStarted, Action<EventStoreCatchUpSubscription, SubscriptionDropReason, Exception> subscriptionDropped, CatchUpSubscriptionSettings settings) Parameters Type Name IEventStoreConnection connection ILogger log System.String streamId UserCredentials userCredentials System.Func < EventStoreCatchUpSubscription , ResolvedEvent , System.Threading.Tasks.Task > eventAppeared System.Action < EventStoreCatchUpSubscription > liveProcessingStarted System.Action < EventStoreCatchUpSubscription , SubscriptionDropReason , System.Exception > subscriptionDropped CatchUpSubscriptionSettings settings Fields EventAppeared Action invoked when a new event appears on the subscription. Declaration protected readonly Func<EventStoreCatchUpSubscription, ResolvedEvent, Task> EventAppeared Field Value Type System.Func < EventStoreCatchUpSubscription , ResolvedEvent , System.Threading.Tasks.Task > Log The ILogger to use for the subscription. Declaration protected readonly ILogger Log Field Value Type ILogger MaxPushQueueSize The maximum number of events to buffer before the subscription drops. Declaration protected readonly int MaxPushQueueSize Field Value Type System.Int32 ReadBatchSize The batch size to use during the read phase of the subscription. Declaration protected readonly int ReadBatchSize Field Value Type System.Int32 ShouldStop stop has been called. Declaration protected volatile bool ShouldStop Field Value Type System.Boolean Verbose Whether or not to use verbose logging (useful during debugging). Declaration protected readonly bool Verbose Field Value Type System.Boolean Properties IsSubscribedToAll Indicates whether the subscription is to all events or to a specific stream. Declaration public bool IsSubscribedToAll { get; } Property Value Type System.Boolean StreamId The name of the stream to which the subscription is subscribed (empty if subscribed to all). Declaration public string StreamId { get; } Property Value Type System.String SubscriptionName The name of subscription. Declaration public string SubscriptionName { get; } Property Value Type System.String Methods ReadEventsTillAsync(IEventStoreConnection, Boolean, UserCredentials, Nullable<Int64>, Nullable<Int64>) Read events until the given position or event number async. Declaration protected abstract Task ReadEventsTillAsync(IEventStoreConnection connection, bool resolveLinkTos, UserCredentials userCredentials, long? lastCommitPosition, long? lastEventNumber) Parameters Type Name IEventStoreConnection connection System.Boolean resolveLinkTos UserCredentials userCredentials System.Nullable < System.Int64 > lastCommitPosition System.Nullable < System.Int64 > lastEventNumber Returns Type Description System.Threading.Tasks.Task Stop() Attempts to stop the subscription without blocking for completion of stop Declaration public void Stop() Stop(TimeSpan) Attempts to stop the subscription blocking for completion of stop. Declaration public void Stop(TimeSpan timeout) Parameters Type Name System.TimeSpan timeout Exceptions Type Condition System.TimeoutException Thrown if the subscription fails to stop within it's timeout period. TryProcessAsync(ResolvedEvent) Try to process a single ResolvedEvent . Declaration protected abstract Task TryProcessAsync(ResolvedEvent e) Parameters Type Name ResolvedEvent e Returns Type Description System.Threading.Tasks.Task"
  },
  "dotnet-api/code/EventStore.ClientAPI.Position.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Position.html",
    "title": "Struct Position | Event Store",
    "keywords": "Struct Position A structure referring to a potential logical record position in the Event Store transaction file. Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public struct Position Constructors Position(Int64, Int64) Constructs a position with the given commit and prepare positions. It is not guaranteed that the position is actually the start of a record in the transaction file. The commit position cannot be less than the prepare position. Declaration public Position(long commitPosition, long preparePosition) Parameters Type Name System.Int64 commitPosition System.Int64 preparePosition Fields CommitPosition The commit position of the record Declaration public readonly long CommitPosition Field Value Type System.Int64 End Position representing the end of the transaction file Declaration public static readonly Position End Field Value Type Position PreparePosition The prepare position of the record. Declaration public readonly long PreparePosition Field Value Type System.Int64 Start Position representing the start of the transaction file Declaration public static readonly Position Start Field Value Type Position Methods Equals(Position) Compares this instance of Position for equality with another instance. Declaration public bool Equals(Position other) Parameters Type Name Position other Returns Type Description System.Boolean True if this instance is equal to the other instance. Equals(Object) Indicates whether this instance and a specified object are equal. Declaration public override bool Equals(object obj) Parameters Type Name System.Object obj Returns Type Description System.Boolean true if obj and this instance are the same type and represent the same value; otherwise, false. Overrides System.ValueType.Equals(System.Object) GetHashCode() Returns the hash code for this instance. Declaration public override int GetHashCode() Returns Type Description System.Int32 A 32-bit signed integer that is the hash code for this instance. Overrides System.ValueType.GetHashCode() ToString() Returns the fully qualified type name of this instance. Declaration public override string ToString() Returns Type Description System.String A System.String containing a fully qualified type name. Overrides System.ValueType.ToString() Operators Equality(Position, Position) Compares p1 and p2 for equality. Declaration public static bool operator ==(Position p1, Position p2) Parameters Type Name Position p1 Position p2 Returns Type Description System.Boolean True if p1 is equal to p2. GreaterThan(Position, Position) Compares whether p1 > p2. Declaration public static bool operator>(Position p1, Position p2) Parameters Type Name Position p1 Position p2 Returns Type Description System.Boolean True if p1 > p2. GreaterThanOrEqual(Position, Position) Compares whether p1 >= p2. Declaration public static bool operator >=(Position p1, Position p2) Parameters Type Name Position p1 Position p2 Returns Type Description System.Boolean True if p1 >= p2. Inequality(Position, Position) Compares p1 and p2 for equality. Declaration public static bool operator !=(Position p1, Position p2) Parameters Type Name Position p1 Position p2 Returns Type Description System.Boolean True if p1 is not equal to p2. LessThan(Position, Position) Compares whether p1 < p2. Declaration public static bool operator <(Position p1, Position p2) Parameters Type Name Position p1 Position p2 Returns Type Description System.Boolean True if p1 < p2. LessThanOrEqual(Position, Position) Compares whether p1 <= p2. Declaration public static bool operator <=(Position p1, Position p2) Parameters Type Name Position p1 Position p2 Returns Type Description System.Boolean True if p1 <= p2."
  },
  "dotnet-api/code/EventStore.ClientAPI.GossipSeed.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.GossipSeed.html",
    "title": "Class GossipSeed | Event Store",
    "keywords": "Class GossipSeed Represents a source of cluster gossip. Inheritance System.Object GossipSeed Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class GossipSeed Constructors GossipSeed(IPEndPoint, String, Boolean) Creates a new GossipSeed . Declaration public GossipSeed(IPEndPoint endPoint, string hostHeader = \"\", bool seedOverTls = false) Parameters Type Name System.Net.IPEndPoint endPoint System.String hostHeader System.Boolean seedOverTls Fields EndPoint The System.Net.IPEndPoint for the External HTTP endpoint of the gossip seed. The HTTP endpoint is used rather than the TCP endpoint because it is required for the client to exchange gossip with the server. The standard port which should be used here is 2113. Declaration public readonly IPEndPoint EndPoint Field Value Type System.Net.IPEndPoint HostHeader The host header to be sent when requesting gossip. Declaration public readonly string HostHeader Field Value Type System.String SeedOverTls If Gossip should be requested Declaration public readonly bool SeedOverTls Field Value Type System.Boolean"
  },
  "dotnet-api/code/EventStore.ClientAPI.ReadDirection.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ReadDirection.html",
    "title": "Enum ReadDirection | Event Store",
    "keywords": "Enum ReadDirection Represents the direction of read operation (both from $all and usual streams) Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public enum ReadDirection Fields Name Description Backward From end to beginning. Forward From beginning to end."
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.OperationTimedOutException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.OperationTimedOutException.html",
    "title": "Class OperationTimedOutException | Event Store",
    "keywords": "Class OperationTimedOutException Exception thrown if an operation times out. Inheritance System.Object System.Exception EventStoreConnectionException OperationTimedOutException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class OperationTimedOutException : EventStoreConnectionException, ISerializable Constructors OperationTimedOutException() Constructs a new OperationTimedOutException . Declaration public OperationTimedOutException() OperationTimedOutException(SerializationInfo, StreamingContext) Constructs a new OperationTimedOutException . Declaration protected OperationTimedOutException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context OperationTimedOutException(String) Constructs a new OperationTimedOutException . Declaration public OperationTimedOutException(string message) Parameters Type Name System.String message OperationTimedOutException(String, Exception) Constructs a new OperationTimedOutException . Declaration public OperationTimedOutException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.Internal.PersistentSubscriptionUpdateStatus.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Internal.PersistentSubscriptionUpdateStatus.html",
    "title": "Enum PersistentSubscriptionUpdateStatus | Event Store",
    "keywords": "Enum PersistentSubscriptionUpdateStatus Enumeration representing the status of a single subscription create message. Namespace : EventStore.ClientAPI.Internal Assembly : EventStore.ClientAPI.dll Syntax public enum PersistentSubscriptionUpdateStatus Fields Name Description AccessDenied You do not have permissions to update this subscription Failure Some failure happened creating the subscription NotFound The subscription already exists Success The subscription was created successfully"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.html",
    "title": "Namespace EventStore.ClientAPI.Exceptions | Event Store",
    "keywords": "Namespace EventStore.ClientAPI.Exceptions Classes AccessDeniedException Exception thrown when a user is not authorised to carry out an operation. CannotEstablishConnectionException Exception thrown if an EventStoreConnection is unable to establish a connection to an Event Store server. ClusterException Exception thrown if cluster discovery fails. CommandNotExpectedException Exception thrown if an unexpected command is received. ConnectionClosedException Exception thrown by ongoing operations which are terminated by an IEventStoreConnection closing. EventStoreConnectionException Base type for exceptions thrown by an IEventStoreConnection , thrown in circumstances which do not have a specific derived exception. InvalidTransactionException Exception thrown if there is an attempt to operate inside a transaction which does not exist. NoResultException Exception thrown if there is no result for an operation for which one is expected. NotAuthenticatedException Exception thrown if an operation requires authentication but the client is not authenticated. OperationExpiredException Exception thrown if an operation expires before it can be scheduled. OperationTimedOutException Exception thrown if an operation times out. PersistentSubscriptionCommandFailedException Exception thrown if a persistent subscription command fails. ProjectionCommandConflictException Exception thrown if a projection command fails. ProjectionCommandFailedException Exception thrown if a projection command fails. RetriesLimitReachedException Exception thrown if the number of retries for an operation is reached. To change the number of retries attempted for an operation, use the methods LimitRetriesForOperationTo(Int32) or KeepRetrying() and pass the resulting ConnectionSettings into the constructor of the connection. ServerErrorException Exception thrown if a server-side error occurs during an operation. StreamDeletedException Exception thrown if an operation is attempted on a stream which has been deleted. UserCommandConflictException Exception thrown if a user command fails. UserCommandFailedException Exception thrown if a projection command fails. WrongExpectedVersionException Exception thrown if the expected version specified on an operation does not match the version of the stream when the operation was attempted."
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.RetriesLimitReachedException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.RetriesLimitReachedException.html",
    "title": "Class RetriesLimitReachedException | Event Store",
    "keywords": "Class RetriesLimitReachedException Exception thrown if the number of retries for an operation is reached. To change the number of retries attempted for an operation, use the methods LimitRetriesForOperationTo(Int32) or KeepRetrying() and pass the resulting ConnectionSettings into the constructor of the connection. Inheritance System.Object System.Exception EventStoreConnectionException RetriesLimitReachedException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class RetriesLimitReachedException : EventStoreConnectionException, ISerializable Constructors RetriesLimitReachedException(Int32) Constructs a new instance of RetriesLimitReachedException . Declaration public RetriesLimitReachedException(int retries) Parameters Type Name System.Int32 retries RetriesLimitReachedException(String, Int32) Constructs a new instance of RetriesLimitReachedException . Declaration public RetriesLimitReachedException(string item, int retries) Parameters Type Name System.String item System.Int32 retries Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.IEndPointDiscoverer.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.IEndPointDiscoverer.html",
    "title": "Interface IEndPointDiscoverer | Event Store",
    "keywords": "Interface IEndPointDiscoverer Represents a way of discovering cluster endpoints. This could be through gossip, consul, text files, etc Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public interface IEndPointDiscoverer Methods DiscoverAsync(IPEndPoint) Called to discover a new System.Net.IPEndPoint Declaration Task<NodeEndPoints> DiscoverAsync(IPEndPoint failedTcpEndPoint) Parameters Type Name System.Net.IPEndPoint failedTcpEndPoint Returns Type Description System.Threading.Tasks.Task < NodeEndPoints >"
  },
  "dotnet-api/code/EventStore.ClientAPI.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.html",
    "title": "Namespace EventStore.ClientAPI | Event Store",
    "keywords": "Namespace EventStore.ClientAPI Classes AllCheckpoint This class contains constants to be used when setting up subscriptions using the IEventStoreConnection.SubscribeToAllFrom method on IEventStoreConnection . AllEventsSlice The result of a read operation from the $all stream. CatchUpSubscriptionSettings Settings for EventStoreCatchUpSubscription . ClientApiConstants Various constant values that may be useful when working with the ClientAPI. ClientAuthenticationFailedEventArgs Event Arguments for the event raised when an IEventStoreConnection fails to authenticate against an Event Store server. ClientClosedEventArgs Event Arguments for the event raised when an IEventStoreConnection is disconnected from an Event Store server. ClientConnectionEventArgs Event Arguments for the event raised when an IEventStoreConnection is connected to or disconnected from an Event Store server. ClientErrorEventArgs Event Arguments for the event raised when an error occurs on an IEventStoreConnection . ClientReconnectingEventArgs Event Arguments for the event raised when an IEventStoreConnection is about to reconnect to an Event Store server. ClusterSettings Contains settings relating to a connection to a cluster. ClusterSettingsBuilder Builder used for creating instances of ClusterSettings. ConnectionSettings A ConnectionSettings object is an immutable representation of the settings for an IEventStoreConnection . You can build a ConnectionSettings object using a ConnectionSettingsBuilder , either via the Create() method, or via the constructor of ConnectionSettingsBuilder . ConnectionSettingsBuilder Used to build a connection settings (fluent API) ConnectionString Methods for dealing with connection strings. DnsClusterSettingsBuilder Fluent builder used to configure ClusterSettings for connecting to a cluster using DNS discovery. EventData Represents an event to be written. EventReadResult A event read result is the result of a single event read operation to Event Store. EventStoreAllCatchUpSubscription A catch-up subscription to all events in the Event Store. EventStoreCatchUpSubscription Base class representing catch-up subscriptions. EventStoreConnection Contains factory methods for building connections to an Event Store server. EventStorePersistentSubscription Represents a persistent subscription connection. EventStorePersistentSubscriptionBase Represents a persistent subscription connection. EventStoreStreamCatchUpSubscription A catch-up subscription to a single stream in the Event Store. EventStoreSubscription Represents a subscription to a single stream or to the stream of all events in the Event Store. EventStoreTransaction Represents a multi-request transaction with the Event Store ExpectedVersion Constants used for expected version control GossipSeed Represents a source of cluster gossip. GossipSeedClusterSettingsBuilder Fluent builder used to configure ClusterSettings for connecting to a cluster using gossip seeds. IEventStoreConnectionExtensions Extensions for IEventStoreConnection PersistentSubscriptionSettings Represents the settings for a EventStore.ClientAPI.PersistentEventStoreSubscription . You should not use this directly, but instead created via a PersistentSubscriptionSettingsBuilder . PersistentSubscriptionSettingsBuilder Builds a PersistentSubscriptionSettings object. RecordedEvent Represents a previously written event StreamAcl Represents an access control list for a stream StreamCheckpoint This class contains constants to be used when setting up subscriptions using the IEventStoreConnection.SubscribeToStreamFrom method on IEventStoreConnection . StreamEventsSlice A stream events slice represents the result of a single read operation to Event Store. StreamMetadata A class representing stream metadata with strongly typed properties for system values and a dictionary-like interface for custom values. StreamMetadataBuilder Builder for StreamMetadata . StreamPosition Constants for stream positions SystemSettings Represents global settings for an Event Store server. Structs ConditionalWriteResult Result type returned after conditionally writing to a stream. DeleteResult Result type returned after deleting a stream. NodeEndPoints Represents a node and its possible endpoints Position A structure referring to a potential logical record position in the Event Store transaction file. RawStreamMetadataResult Represents stream metadata as a series of properties for system data and a byte array for user metadata. ResolvedEvent A structure representing a single event or an resolved link event. StreamMetadataResult Represents stream metadata as a series of properties for system data and a StreamMetadata object for user metadata. WriteResult Result type returned after writing to a stream. Interfaces IEndPointDiscoverer Represents a way of discovering cluster endpoints. This could be through gossip, consul, text files, etc IEventStoreConnection Maintains a full duplex connection to Event Store. ILogger Simple abstraction of a logger. Enums ConditionalWriteStatus The reason why a conditional write fails EventReadStatus Enumeration representing the status of a single event read operation. NodePreference Indicates which order of preferred nodes for connecting to. PersistentSubscriptionNakEventAction Actions to be taken by server in the case of a client NAK ReadDirection Represents the direction of read operation (both from $all and usual streams) SliceReadStatus Enumeration detailing the possible outcomes of reading a slice of a stream. SubscriptionDropReason Represents the reason subscription drop happened"
  },
  "dotnet-api/code/EventStore.ClientAPI.NodeEndPoints.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.NodeEndPoints.html",
    "title": "Struct NodeEndPoints | Event Store",
    "keywords": "Struct NodeEndPoints Represents a node and its possible endpoints Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public struct NodeEndPoints Constructors NodeEndPoints(IPEndPoint, IPEndPoint) Called to create a new NodeEndPoints Declaration public NodeEndPoints(IPEndPoint tcpEndPoint, IPEndPoint secureTcpEndPoint) Parameters Type Name System.Net.IPEndPoint tcpEndPoint System.Net.IPEndPoint secureTcpEndPoint Fields SecureTcpEndPoint The ssl endpoint of the node Declaration public readonly IPEndPoint SecureTcpEndPoint Field Value Type System.Net.IPEndPoint TcpEndPoint The tcp endpoint of the node. Declaration public readonly IPEndPoint TcpEndPoint Field Value Type System.Net.IPEndPoint Methods ToString() Formats the endpoints as a string Declaration public override string ToString() Returns Type Description System.String Overrides System.ValueType.ToString()"
  },
  "dotnet-api/code/EventStore.ClientAPI.WriteResult.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.WriteResult.html",
    "title": "Struct WriteResult | Event Store",
    "keywords": "Struct WriteResult Result type returned after writing to a stream. Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public struct WriteResult Constructors WriteResult(Int64, Position) Constructs a new WriteResult . Declaration public WriteResult(long nextExpectedVersion, Position logPosition) Parameters Type Name System.Int64 nextExpectedVersion Position logPosition Fields LogPosition The LogPosition of the write. Declaration public readonly Position LogPosition Field Value Type Position NextExpectedVersion The next expected version for the stream. Declaration public readonly long NextExpectedVersion Field Value Type System.Int64"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.UserCommandFailedException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.UserCommandFailedException.html",
    "title": "Class UserCommandFailedException | Event Store",
    "keywords": "Class UserCommandFailedException Exception thrown if a projection command fails. Inheritance System.Object System.Exception EventStoreConnectionException UserCommandFailedException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class UserCommandFailedException : EventStoreConnectionException, ISerializable Constructors UserCommandFailedException() Constructs a new UserCommandFailedException . Declaration public UserCommandFailedException() UserCommandFailedException(Int32, String) Constructs a new UserCommandFailedException . Declaration public UserCommandFailedException(int httpStatusCode, string message) Parameters Type Name System.Int32 httpStatusCode System.String message UserCommandFailedException(SerializationInfo, StreamingContext) Constructs a new UserCommandFailedException . Declaration protected UserCommandFailedException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context UserCommandFailedException(String, Exception) Constructs a new UserCommandFailedException . Declaration public UserCommandFailedException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Properties HttpStatusCode The Http status code returned for the operation Declaration public int HttpStatusCode { get; } Property Value Type System.Int32 Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.UserCommandConflictException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.UserCommandConflictException.html",
    "title": "Class UserCommandConflictException | Event Store",
    "keywords": "Class UserCommandConflictException Exception thrown if a user command fails. Inheritance System.Object System.Exception EventStoreConnectionException ProjectionCommandFailedException UserCommandConflictException Implements System.Runtime.Serialization.ISerializable Inherited Members ProjectionCommandFailedException.HttpStatusCode System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class UserCommandConflictException : ProjectionCommandFailedException, ISerializable Constructors UserCommandConflictException() Constructs a new UserCommandFailedException . Declaration public UserCommandConflictException() UserCommandConflictException(Int32, String) Constructs a new UserCommandFailedException . Declaration public UserCommandConflictException(int httpStatusCode, string message) Parameters Type Name System.Int32 httpStatusCode System.String message UserCommandConflictException(SerializationInfo, StreamingContext) Constructs a new UserCommandFailedException . Declaration protected UserCommandConflictException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context UserCommandConflictException(String, Exception) Constructs a new UserCommandFailedException . Declaration public UserCommandConflictException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.UserManagement.UserDetails.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.UserManagement.UserDetails.html",
    "title": "Class UserDetails | Event Store",
    "keywords": "Class UserDetails Provides the details for a user. Inheritance System.Object UserDetails Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.UserManagement Assembly : EventStore.ClientAPI.dll Syntax public sealed class UserDetails Constructors UserDetails(String, String, String[], Boolean, Nullable<DateTimeOffset>, RelLink[]) create a new UserDetails class. Declaration public UserDetails(string loginName, string fullName, string[] groups, bool disabled, DateTimeOffset? dateLastUpdated, RelLink[] links) Parameters Type Name System.String loginName System.String fullName System.String [] groups System.Boolean disabled System.Nullable < System.DateTimeOffset > dateLastUpdated RelLink [] links Fields DateLastUpdated The date/time the user was updated in UTC format. Declaration public readonly DateTimeOffset? DateLastUpdated Field Value Type System.Nullable < System.DateTimeOffset > Disabled Whether the user disable or not. Declaration public readonly bool Disabled Field Value Type System.Boolean FullName The full name of the user. Declaration public readonly string FullName Field Value Type System.String Groups The groups the user is a member of. Declaration public readonly string[] Groups Field Value Type System.String [] Links List of hypermedia links describing actions allowed on user resource. Declaration public readonly RelLink[] Links Field Value Type RelLink [] LoginName The users login name. Declaration public readonly string LoginName Field Value Type System.String Methods GetRelLink(String) Declaration public string GetRelLink(string rel) Parameters Type Name System.String rel Returns Type Description System.String"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.WrongExpectedVersionException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.WrongExpectedVersionException.html",
    "title": "Class WrongExpectedVersionException | Event Store",
    "keywords": "Class WrongExpectedVersionException Exception thrown if the expected version specified on an operation does not match the version of the stream when the operation was attempted. Inheritance System.Object System.Exception EventStoreConnectionException WrongExpectedVersionException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class WrongExpectedVersionException : EventStoreConnectionException, ISerializable Constructors WrongExpectedVersionException(SerializationInfo, StreamingContext) Constructs a new instance of WrongExpectedVersionException . Declaration protected WrongExpectedVersionException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context WrongExpectedVersionException(String) Constructs a new instance of WrongExpectedVersionException . Declaration public WrongExpectedVersionException(string message) Parameters Type Name System.String message WrongExpectedVersionException(String, Exception) Constructs a new instance of WrongExpectedVersionException . Declaration public WrongExpectedVersionException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException WrongExpectedVersionException(String, Nullable<Int64>, Nullable<Int64>) Constructs a new instance of WrongExpectedVersionException with the expected and actual versions if available. Declaration public WrongExpectedVersionException(string message, long? expectedVersion, long? actualVersion) Parameters Type Name System.String message System.Nullable < System.Int64 > expectedVersion System.Nullable < System.Int64 > actualVersion Properties ActualVersion If available, the current version of the stream that the operation was attempted on. Declaration public long? ActualVersion { get; } Property Value Type System.Nullable < System.Int64 > Remarks Only available if the operation was AppendToStreamAsync(String, Int64, EventData[]) or one of it's overloads. ExpectedVersion If available, the expected version specified for the operation that failed. Declaration public long? ExpectedVersion { get; } Property Value Type System.Nullable < System.Int64 > Remarks Only available if the operation was AppendToStreamAsync(String, Int64, EventData[]) or one of it's overloads. Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.Common.Log.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Common.Log.html",
    "title": "Namespace EventStore.ClientAPI.Common.Log | Event Store",
    "keywords": "Namespace EventStore.ClientAPI.Common.Log Classes ConsoleLogger Implementation of ILogger which outputs to System.Console ."
  },
  "dotnet-api/code/EventStore.ClientAPI.Projections.ProjectionsManager.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Projections.ProjectionsManager.html",
    "title": "Class ProjectionsManager | Event Store",
    "keywords": "Class ProjectionsManager API for managing projections in the Event Store through C# code. Communicates with the Event Store over the RESTful API. Inheritance System.Object ProjectionsManager Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.Projections Assembly : EventStore.ClientAPI.dll Syntax public class ProjectionsManager Constructors ProjectionsManager(ILogger, EndPoint, TimeSpan, IHttpClient, String) Creates a new instance of ProjectionsManager . Declaration public ProjectionsManager(ILogger log, EndPoint httpEndPoint, TimeSpan operationTimeout, IHttpClient client = null, string httpSchema = \"http\") Parameters Type Name ILogger log System.Net.EndPoint httpEndPoint System.TimeSpan operationTimeout IHttpClient client System.String httpSchema Methods AbortAsync(String, UserCredentials) Asynchronously disables a projection. Declaration public Task AbortAsync(string name, UserCredentials userCredentials = null) Parameters Type Name System.String name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A task representing the operation. CreateContinuousAsync(String, String, UserCredentials) Asynchronously creates a continuous projection. Declaration public Task CreateContinuousAsync(string name, string query, UserCredentials userCredentials = null) Parameters Type Name System.String name System.String query UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task CreateContinuousAsync(String, String, Boolean, UserCredentials) Asynchronously creates a continuous projection. Declaration public Task CreateContinuousAsync(string name, string query, bool trackEmittedStreams, UserCredentials userCredentials = null) Parameters Type Name System.String name System.String query System.Boolean trackEmittedStreams UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task CreateOneTimeAsync(String, UserCredentials) Asynchronously creates a one-time query. Declaration public Task CreateOneTimeAsync(string query, UserCredentials userCredentials = null) Parameters Type Name System.String query UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task CreateTransientAsync(String, String, UserCredentials) Asynchronously creates a one-time query. Declaration public Task CreateTransientAsync(string name, string query, UserCredentials userCredentials = null) Parameters Type Name System.String name System.String query UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task DeleteAsync(String, UserCredentials) Asynchronously deletes a projection Declaration public Task DeleteAsync(string name, UserCredentials userCredentials = null) Parameters Type Name System.String name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A task representing the operation. DeleteAsync(String, Boolean, UserCredentials) Asynchronously deletes a projection Declaration public Task DeleteAsync(string name, bool deleteEmittedStreams, UserCredentials userCredentials = null) Parameters Type Name System.String name System.Boolean deleteEmittedStreams UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A task representing the operation. DisableAsync(String, UserCredentials) Asynchronously aborts and disables a projection without writing a checkpoint. Declaration public Task DisableAsync(string name, UserCredentials userCredentials = null) Parameters Type Name System.String name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A task representing the operation. EnableAsync(String, UserCredentials) Asynchronously enables a projection Declaration public Task EnableAsync(string name, UserCredentials userCredentials = null) Parameters Type Name System.String name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A task representing the operation. GetConfigAsync(String, UserCredentials) Asynchronously gets the projection config. Declaration public Task<ProjectionConfig> GetConfigAsync(string name, UserCredentials userCredentials = null) Parameters Type Name System.String name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < ProjectionConfig > String of JSON containing projection config. GetPartitionResultAsync(String, String, UserCredentials) Asynchronously gets the state of a projection for a specified partition. Declaration public Task<string> GetPartitionResultAsync(string name, string partitionId, UserCredentials userCredentials = null) Parameters Type Name System.String name System.String partitionId UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < System.String > String of JSON containing projection state. GetPartitionStateAsync(String, String, UserCredentials) Asynchronously gets the state of a projection for a specified partition. Declaration public Task<string> GetPartitionStateAsync(string name, string partitionId, UserCredentials userCredentials = null) Parameters Type Name System.String name System.String partitionId UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < System.String > String of JSON containing projection state. GetQueryAsync(String, UserCredentials) Asynchronously gets the status of a query. Declaration public Task<string> GetQueryAsync(string name, UserCredentials userCredentials = null) Parameters Type Name System.String name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < System.String > String of JSON containing query status. GetResultAsync(String, UserCredentials) Asynchronously gets the state of a projection. Declaration public Task<string> GetResultAsync(string name, UserCredentials userCredentials = null) Parameters Type Name System.String name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < System.String > String of JSON containing projection state. GetStateAsync(String, UserCredentials) Asynchronously gets the state of a projection. Declaration public Task<string> GetStateAsync(string name, UserCredentials userCredentials = null) Parameters Type Name System.String name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < System.String > String of JSON containing projection state. GetStatisticsAsync(String, UserCredentials) Asynchronously gets the statistics of a projection. Declaration public Task<string> GetStatisticsAsync(string name, UserCredentials userCredentials = null) Parameters Type Name System.String name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < System.String > String of JSON containing projection statistics. GetStatusAsync(String, UserCredentials) Asynchronously gets the status of a projection. Declaration public Task<string> GetStatusAsync(string name, UserCredentials userCredentials = null) Parameters Type Name System.String name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < System.String > String of JSON containing projection status. ListAllAsync(UserCredentials) Asynchronously lists this status of all projections. Declaration public Task<List<ProjectionDetails>> ListAllAsync(UserCredentials userCredentials = null) Parameters Type Name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < System.Collections.Generic.List < ProjectionDetails >> List of all ProjectionDetails items containing projection statuses. ListContinuousAsync(UserCredentials) Synchronously lists this status of all continuous projections. Declaration public Task<List<ProjectionDetails>> ListContinuousAsync(UserCredentials userCredentials = null) Parameters Type Name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < System.Collections.Generic.List < ProjectionDetails >> List of continuous ProjectionDetails items containing projection statuses. ListOneTimeAsync(UserCredentials) Asynchronously lists this status of all one-time projections. Declaration public Task<List<ProjectionDetails>> ListOneTimeAsync(UserCredentials userCredentials = null) Parameters Type Name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task < System.Collections.Generic.List < ProjectionDetails >> List of one-time ProjectionDetails items containing projection statuses. ResetAsync(String, UserCredentials) Asynchronously resets a projection Declaration public Task ResetAsync(string name, UserCredentials userCredentials = null) Parameters Type Name System.String name UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task A task representing the operation. UpdateConfigAsync(String, ProjectionConfig, UserCredentials) Asynchronously updates the projection config. Declaration public Task UpdateConfigAsync(string name, ProjectionConfig config, UserCredentials userCredentials = null) Parameters Type Name System.String name ProjectionConfig config UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task UpdateQueryAsync(String, String, UserCredentials) Asynchronously updates the definition of a query. Declaration public Task UpdateQueryAsync(string name, string query, UserCredentials userCredentials = null) Parameters Type Name System.String name System.String query UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task UpdateQueryAsync(String, String, Nullable<Boolean>, UserCredentials) Asynchronously updates the definition of a query. Declaration public Task UpdateQueryAsync(string name, string query, bool? emitEnabled = default(bool? ), UserCredentials userCredentials = null) Parameters Type Name System.String name System.String query System.Nullable < System.Boolean > emitEnabled UserCredentials userCredentials Returns Type Description System.Threading.Tasks.Task"
  },
  "dotnet-api/code/EventStore.ClientAPI.ClientReconnectingEventArgs.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ClientReconnectingEventArgs.html",
    "title": "Class ClientReconnectingEventArgs | Event Store",
    "keywords": "Class ClientReconnectingEventArgs Event Arguments for the event raised when an IEventStoreConnection is about to reconnect to an Event Store server. Inheritance System.Object System.EventArgs ClientReconnectingEventArgs Inherited Members System.EventArgs.Empty System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class ClientReconnectingEventArgs : EventArgs Constructors ClientReconnectingEventArgs(IEventStoreConnection) Constructs a new instance of ClientReconnectingEventArgs . Declaration public ClientReconnectingEventArgs(IEventStoreConnection connection) Parameters Type Name IEventStoreConnection connection Properties Connection The IEventStoreConnection responsible for raising the event. Declaration public IEventStoreConnection Connection { get; } Property Value Type IEventStoreConnection"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.AccessDeniedException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.AccessDeniedException.html",
    "title": "Class AccessDeniedException | Event Store",
    "keywords": "Class AccessDeniedException Exception thrown when a user is not authorised to carry out an operation. Inheritance System.Object System.Exception EventStoreConnectionException AccessDeniedException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class AccessDeniedException : EventStoreConnectionException, ISerializable Constructors AccessDeniedException() Constructs a new AccessDeniedException . Declaration public AccessDeniedException() AccessDeniedException(SerializationInfo, StreamingContext) Constructs a new AccessDeniedException . Declaration protected AccessDeniedException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context AccessDeniedException(String) Constructs a new AccessDeniedException . Declaration public AccessDeniedException(string message) Parameters Type Name System.String message AccessDeniedException(String, Exception) Constructs a new AccessDeniedException . Declaration public AccessDeniedException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.AllEventsSlice.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.AllEventsSlice.html",
    "title": "Class AllEventsSlice | Event Store",
    "keywords": "Class AllEventsSlice The result of a read operation from the $all stream. Inheritance System.Object AllEventsSlice Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class AllEventsSlice Fields Events The events read. Declaration public readonly ResolvedEvent[] Events Field Value Type ResolvedEvent [] FromPosition A Position representing the position where this slice was read from. Declaration public readonly Position FromPosition Field Value Type Position NextPosition A Position representing the position where the next slice should be read from. Declaration public readonly Position NextPosition Field Value Type Position ReadDirection The direction of read request. Declaration public readonly ReadDirection ReadDirection Field Value Type ReadDirection Properties IsEndOfStream A boolean representing whether or not this is the end of the $all stream. Declaration public bool IsEndOfStream { get; } Property Value Type System.Boolean"
  },
  "dotnet-api/code/EventStore.ClientAPI.SystemData.UserCredentials.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.SystemData.UserCredentials.html",
    "title": "Class UserCredentials | Event Store",
    "keywords": "Class UserCredentials A username/password pair used for authentication and authorization to perform operations over an IEventStoreConnection . Inheritance System.Object UserCredentials Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.SystemData Assembly : EventStore.ClientAPI.dll Syntax public class UserCredentials Constructors UserCredentials(String, String) Constructs a new UserCredentials . Declaration public UserCredentials(string username, string password) Parameters Type Name System.String username System.String password Fields Password The password Declaration public readonly string Password Field Value Type System.String Username The username Declaration public readonly string Username Field Value Type System.String"
  },
  "dotnet-api/code/EventStore.ClientAPI.SystemSettings.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.SystemSettings.html",
    "title": "Class SystemSettings | Event Store",
    "keywords": "Class SystemSettings Represents global settings for an Event Store server. Inheritance System.Object SystemSettings Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class SystemSettings Constructors SystemSettings(StreamAcl, StreamAcl) Constructs a new SystemSettings . Declaration public SystemSettings(StreamAcl userStreamAcl, StreamAcl systemStreamAcl) Parameters Type Name StreamAcl userStreamAcl StreamAcl systemStreamAcl Fields SystemStreamAcl Default access control list for new system streams. Declaration public readonly StreamAcl SystemStreamAcl Field Value Type StreamAcl UserStreamAcl Default access control list for new user streams. Declaration public readonly StreamAcl UserStreamAcl Field Value Type StreamAcl Methods FromJsonBytes(Byte[]) Creates a SystemSettings object from a JSON string in a byte array. Declaration public static SystemSettings FromJsonBytes(byte[] json) Parameters Type Name System.Byte [] json Returns Type Description SystemSettings A SystemSettings object. ToJsonBytes() Creates a byte array containing a UTF-8 string with no byte order mark representing this SystemSettings object. Declaration public byte[] ToJsonBytes() Returns Type Description System.Byte [] A byte array containing a UTF-8 string with no byte order mark. ToJsonString() Creates a string containing representing this SystemSettings object. Declaration public string ToJsonString() Returns Type Description System.String A string representing this SystemSettings . ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description System.String A string that represents the current object. Overrides System.Object.ToString()"
  },
  "dotnet-api/code/EventStore.ClientAPI.Common.Log.ConsoleLogger.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Common.Log.ConsoleLogger.html",
    "title": "Class ConsoleLogger | Event Store",
    "keywords": "Class ConsoleLogger Implementation of ILogger which outputs to System.Console . Inheritance System.Object ConsoleLogger Implements ILogger Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.Common.Log Assembly : EventStore.ClientAPI.dll Syntax public class ConsoleLogger : ILogger Methods Debug(Exception, String, Object[]) Writes a debug message to the logger Declaration public void Debug(Exception ex, string format, params object[] args) Parameters Type Name System.Exception ex System.String format System.Object [] args Debug(String, Object[]) Writes a debug message to the logger Declaration public void Debug(string format, params object[] args) Parameters Type Name System.String format System.Object [] args Error(Exception, String, Object[]) Writes an error to the logger Declaration public void Error(Exception ex, string format, params object[] args) Parameters Type Name System.Exception ex System.String format System.Object [] args Error(String, Object[]) Writes an error to the logger Declaration public void Error(string format, params object[] args) Parameters Type Name System.String format System.Object [] args Info(Exception, String, Object[]) Writes an information message to the logger Declaration public void Info(Exception ex, string format, params object[] args) Parameters Type Name System.Exception ex System.String format System.Object [] args Info(String, Object[]) Writes an information message to the logger Declaration public void Info(string format, params object[] args) Parameters Type Name System.String format System.Object [] args Implements ILogger"
  },
  "dotnet-api/code/EventStore.ClientAPI.DnsClusterSettingsBuilder.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.DnsClusterSettingsBuilder.html",
    "title": "Class DnsClusterSettingsBuilder | Event Store",
    "keywords": "Class DnsClusterSettingsBuilder Fluent builder used to configure ClusterSettings for connecting to a cluster using DNS discovery. Inheritance System.Object DnsClusterSettingsBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public class DnsClusterSettingsBuilder Methods Build() Builds a ClusterSettings object from a DnsClusterSettingsBuilder . Declaration public ClusterSettings Build() Returns Type Description ClusterSettings KeepDiscovering() Allows infinite nodes discovery attempts. Declaration public DnsClusterSettingsBuilder KeepDiscovering() Returns Type Description DnsClusterSettingsBuilder PreferRandomNode() Whether to randomly choose a node that's alive from the known nodes. Declaration public DnsClusterSettingsBuilder PreferRandomNode() Returns Type Description DnsClusterSettingsBuilder A DnsClusterSettingsBuilder for further configuration. PreferSlaveNode() Whether to prioritize choosing a slave node that's alive from the known nodes. Declaration public DnsClusterSettingsBuilder PreferSlaveNode() Returns Type Description DnsClusterSettingsBuilder A DnsClusterSettingsBuilder for further configuration. SetClusterDns(String) Sets the DNS name under which cluster nodes are listed. Declaration public DnsClusterSettingsBuilder SetClusterDns(string clusterDns) Parameters Type Name System.String clusterDns Returns Type Description DnsClusterSettingsBuilder A DnsClusterSettingsBuilder for further configuration. Exceptions Type Condition System.ArgumentNullException If clusterDns is null or empty. SetClusterGossipPort(Int32) Sets the well-known port on which the cluster gossip is taking place. If you are using the commercial edition of Event Store HA, with Manager nodes in place, this should be the port number of the External HTTP port on which the managers are running. If you are using the open source edition of Event Store HA, this should be the External HTTP port that the nodes are running on. If you cannot use a well-known port for this across all nodes, you can instead use gossip seed discovery and set the System.Net.IPEndPoint of some seed nodes instead. Declaration public DnsClusterSettingsBuilder SetClusterGossipPort(int clusterGossipPort) Parameters Type Name System.Int32 clusterGossipPort Returns Type Description DnsClusterSettingsBuilder A DnsClusterSettingsBuilder for further configuration. SetGossipTimeout(TimeSpan) Sets the period after which gossip times out if none is received. Declaration public DnsClusterSettingsBuilder SetGossipTimeout(TimeSpan timeout) Parameters Type Name System.TimeSpan timeout Returns Type Description DnsClusterSettingsBuilder A DnsClusterSettingsBuilder for further configuration. SetMaxDiscoverAttempts(Int32) Sets the maximum number of attempts for discovery. Declaration public DnsClusterSettingsBuilder SetMaxDiscoverAttempts(int maxDiscoverAttempts) Parameters Type Name System.Int32 maxDiscoverAttempts Returns Type Description DnsClusterSettingsBuilder A DnsClusterSettingsBuilder for further configuration. Exceptions Type Condition System.ArgumentOutOfRangeException If maxDiscoverAttempts is less than or equal to 0. Operators Implicit(DnsClusterSettingsBuilder to ClusterSettings) Builds a ClusterSettings object from a DnsClusterSettingsBuilder . Declaration public static implicit operator ClusterSettings(DnsClusterSettingsBuilder builder) Parameters Type Name DnsClusterSettingsBuilder builder Returns Type Description ClusterSettings"
  },
  "dotnet-api/code/EventStore.ClientAPI.ConditionalWriteStatus.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ConditionalWriteStatus.html",
    "title": "Enum ConditionalWriteStatus | Event Store",
    "keywords": "Enum ConditionalWriteStatus The reason why a conditional write fails Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public enum ConditionalWriteStatus Fields Name Description StreamDeleted The stream has been deleted Succeeded The write operation succeeded VersionMismatch The expected version does not match actual stream version"
  },
  "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptions.PersistentSubscriptionConfigDetails.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.PersistentSubscriptions.PersistentSubscriptionConfigDetails.html",
    "title": "Class PersistentSubscriptionConfigDetails | Event Store",
    "keywords": "Class PersistentSubscriptionConfigDetails Configuration details of a persistent subscription. Inheritance System.Object PersistentSubscriptionConfigDetails Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.PersistentSubscriptions Assembly : EventStore.ClientAPI.dll Syntax public sealed class PersistentSubscriptionConfigDetails Properties BufferSize Buffer size. Declaration public int BufferSize { get; set; } Property Value Type System.Int32 CheckPointAfterMilliseconds Checkpoint interval in ms. Declaration public int CheckPointAfterMilliseconds { get; set; } Property Value Type System.Int32 ExtraStatistics Extra statistics. Declaration public bool ExtraStatistics { get; set; } Property Value Type System.Boolean LiveBufferSize Live buffer size. Declaration public int LiveBufferSize { get; set; } Property Value Type System.Int32 MaxCheckPointCount Max number of events between checkpoints. Declaration public int MaxCheckPointCount { get; set; } Property Value Type System.Int32 MaxRetryCount Max retry count. Declaration public int MaxRetryCount { get; set; } Property Value Type System.Int32 MaxSubscriberCount Max subscribers permitted. Declaration public int MaxSubscriberCount { get; set; } Property Value Type System.Int32 MessageTimeoutMilliseconds Message timeout in ms. Declaration public int MessageTimeoutMilliseconds { get; set; } Property Value Type System.Int32 MinCheckPointCount Min number of events between checkpoints. Declaration public int MinCheckPointCount { get; set; } Property Value Type System.Int32 NamedConsumerStrategy Consumer strategy. Declaration public string NamedConsumerStrategy { get; set; } Property Value Type System.String PreferRoundRobin Whether to prefer round robin. Declaration public bool PreferRoundRobin { get; set; } Property Value Type System.Boolean ReadBatchSize Read buffer size. Declaration public int ReadBatchSize { get; set; } Property Value Type System.Int32 ResolveLinktos Whether to resolve LinkTos. Declaration public bool ResolveLinktos { get; set; } Property Value Type System.Boolean StartFrom Which event to start from. Declaration public long StartFrom { get; set; } Property Value Type System.Int64"
  },
  "dotnet-api/code/EventStore.ClientAPI.ClientOperations.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ClientOperations.html",
    "title": "Namespace EventStore.ClientAPI.ClientOperations | Event Store",
    "keywords": "Namespace EventStore.ClientAPI.ClientOperations Classes MaximumSubscribersReachedException Thrown when max subscribers is set on subscription and it has been reached PersistentSubscriptionDeletedException Thrown when the persistent subscription has been deleted to subscribers connected to it"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.ConnectionClosedException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.ConnectionClosedException.html",
    "title": "Class ConnectionClosedException | Event Store",
    "keywords": "Class ConnectionClosedException Exception thrown by ongoing operations which are terminated by an IEventStoreConnection closing. Inheritance System.Object System.Exception EventStoreConnectionException ConnectionClosedException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class ConnectionClosedException : EventStoreConnectionException, ISerializable Constructors ConnectionClosedException() Constructs a new ConnectionClosedException . Declaration public ConnectionClosedException() ConnectionClosedException(SerializationInfo, StreamingContext) Constructs a new ConnectionClosedException . Declaration protected ConnectionClosedException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context ConnectionClosedException(String) Constructs a new ConnectionClosedException . Declaration public ConnectionClosedException(string message) Parameters Type Name System.String message ConnectionClosedException(String, Exception) Constructs a new ConnectionClosedException . Declaration public ConnectionClosedException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.SystemData.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.SystemData.html",
    "title": "Namespace EventStore.ClientAPI.SystemData | Event Store",
    "keywords": "Namespace EventStore.ClientAPI.SystemData Classes UserCredentials A username/password pair used for authentication and authorization to perform operations over an IEventStoreConnection ."
  },
  "dotnet-api/code/EventStore.ClientAPI.Projections.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Projections.html",
    "title": "Namespace EventStore.ClientAPI.Projections | Event Store",
    "keywords": "Namespace EventStore.ClientAPI.Projections Classes ProjectionConfig Provides the configuration for a projection. ProjectionDetails Provides the details for a projection. ProjectionsManager API for managing projections in the Event Store through C# code. Communicates with the Event Store over the RESTful API. QueryManager API for executing queries in the Event Store through C# code. Communicates with the Event Store over the RESTful API."
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.NotAuthenticatedException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.NotAuthenticatedException.html",
    "title": "Class NotAuthenticatedException | Event Store",
    "keywords": "Class NotAuthenticatedException Exception thrown if an operation requires authentication but the client is not authenticated. Inheritance System.Object System.Exception EventStoreConnectionException NotAuthenticatedException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class NotAuthenticatedException : EventStoreConnectionException, ISerializable Constructors NotAuthenticatedException() Constructs a new NotAuthenticatedException . Declaration public NotAuthenticatedException() NotAuthenticatedException(SerializationInfo, StreamingContext) Constructs a new NotAuthenticatedException . Declaration protected NotAuthenticatedException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context NotAuthenticatedException(String) Constructs a new NotAuthenticatedException . Declaration public NotAuthenticatedException(string message) Parameters Type Name System.String message NotAuthenticatedException(String, Exception) Constructs a new NotAuthenticatedException . Declaration public NotAuthenticatedException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.Exceptions.OperationExpiredException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Exceptions.OperationExpiredException.html",
    "title": "Class OperationExpiredException | Event Store",
    "keywords": "Class OperationExpiredException Exception thrown if an operation expires before it can be scheduled. Inheritance System.Object System.Exception EventStoreConnectionException OperationExpiredException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.Exceptions Assembly : EventStore.ClientAPI.dll Syntax public class OperationExpiredException : EventStoreConnectionException, ISerializable Constructors OperationExpiredException() Constructs a new OperationExpiredException . Declaration public OperationExpiredException() OperationExpiredException(SerializationInfo, StreamingContext) Constructs a new OperationExpiredException . Declaration protected OperationExpiredException(SerializationInfo info, StreamingContext context) Parameters Type Name System.Runtime.Serialization.SerializationInfo info System.Runtime.Serialization.StreamingContext context OperationExpiredException(String) Constructs a new OperationExpiredException . Declaration public OperationExpiredException(string message) Parameters Type Name System.String message OperationExpiredException(String, Exception) Constructs a new OperationExpiredException . Declaration public OperationExpiredException(string message, Exception innerException) Parameters Type Name System.String message System.Exception innerException Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.SliceReadStatus.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.SliceReadStatus.html",
    "title": "Enum SliceReadStatus | Event Store",
    "keywords": "Enum SliceReadStatus Enumeration detailing the possible outcomes of reading a slice of a stream. Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public enum SliceReadStatus Fields Name Description StreamDeleted The stream has previously existed but is deleted. StreamNotFound The stream was not found. Success The read was successful."
  },
  "dotnet-api/code/EventStore.ClientAPI.ClientOperations.MaximumSubscribersReachedException.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.ClientOperations.MaximumSubscribersReachedException.html",
    "title": "Class MaximumSubscribersReachedException | Event Store",
    "keywords": "Class MaximumSubscribersReachedException Thrown when max subscribers is set on subscription and it has been reached Inheritance System.Object System.Exception MaximumSubscribersReachedException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : EventStore.ClientAPI.ClientOperations Assembly : EventStore.ClientAPI.dll Syntax public class MaximumSubscribersReachedException : Exception, ISerializable Constructors MaximumSubscribersReachedException() Constructs a MaximumSubscribersReachedException Declaration public MaximumSubscribersReachedException() Implements System.Runtime.Serialization.ISerializable"
  },
  "dotnet-api/code/EventStore.ClientAPI.Transport.Http.HttpAsyncClient.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.Transport.Http.HttpAsyncClient.html",
    "title": "Class HttpAsyncClient | Event Store",
    "keywords": "Class HttpAsyncClient Inheritance System.Object HttpAsyncClient Implements IHttpClient Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI.Transport.Http Assembly : EventStore.ClientAPI.dll Syntax public class HttpAsyncClient : IHttpClient Constructors HttpAsyncClient(TimeSpan, HttpClientHandler) Declaration public HttpAsyncClient(TimeSpan timeout, HttpClientHandler clientHandler = null) Parameters Type Name System.TimeSpan timeout System.Net.Http.HttpClientHandler clientHandler Methods Delete(String, UserCredentials, Action<HttpResponse>, Action<Exception>) Declaration public void Delete(string url, UserCredentials userCredentials, Action<HttpResponse> onSuccess, Action<Exception> onException) Parameters Type Name System.String url UserCredentials userCredentials System.Action < HttpResponse > onSuccess System.Action < System.Exception > onException Get(String, UserCredentials, Action<HttpResponse>, Action<Exception>, String) Declaration public void Get(string url, UserCredentials userCredentials, Action<HttpResponse> onSuccess, Action<Exception> onException, string hostHeader = \"\") Parameters Type Name System.String url UserCredentials userCredentials System.Action < HttpResponse > onSuccess System.Action < System.Exception > onException System.String hostHeader Post(String, String, String, UserCredentials, Action<HttpResponse>, Action<Exception>) Declaration public void Post(string url, string body, string contentType, UserCredentials userCredentials, Action<HttpResponse> onSuccess, Action<Exception> onException) Parameters Type Name System.String url System.String body System.String contentType UserCredentials userCredentials System.Action < HttpResponse > onSuccess System.Action < System.Exception > onException Put(String, String, String, UserCredentials, Action<HttpResponse>, Action<Exception>) Declaration public void Put(string url, string body, string contentType, UserCredentials userCredentials, Action<HttpResponse> onSuccess, Action<Exception> onException) Parameters Type Name System.String url System.String body System.String contentType UserCredentials userCredentials System.Action < HttpResponse > onSuccess System.Action < System.Exception > onException Implements IHttpClient"
  },
  "dotnet-api/code/EventStore.ClientAPI.EventStoreConnection.html": {
    "href": "dotnet-api/code/EventStore.ClientAPI.EventStoreConnection.html",
    "title": "Class EventStoreConnection | Event Store",
    "keywords": "Class EventStoreConnection Contains factory methods for building connections to an Event Store server. Inheritance System.Object EventStoreConnection Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : EventStore.ClientAPI Assembly : EventStore.ClientAPI.dll Syntax public static class EventStoreConnection Methods Create(ConnectionSettings, ClusterSettings, String) Creates a new IEventStoreConnection to EventStore cluster using specific ConnectionSettings and ClusterSettings Declaration public static IEventStoreConnection Create(ConnectionSettings connectionSettings, ClusterSettings clusterSettings, string connectionName = null) Parameters Type Name ConnectionSettings connectionSettings ClusterSettings clusterSettings System.String connectionName Returns Type Description IEventStoreConnection a new IEventStoreConnection Create(ConnectionSettings, IEndPointDiscoverer, String) Creates a new IEventStoreConnection using specific ConnectionSettings and a custom-defined IEndPointDiscoverer Declaration public static IEventStoreConnection Create(ConnectionSettings connectionSettings, IEndPointDiscoverer endPointDiscoverer, string connectionName = null) Parameters Type Name ConnectionSettings connectionSettings IEndPointDiscoverer endPointDiscoverer System.String connectionName Returns Type Description IEventStoreConnection a new IEventStoreConnection Create(ConnectionSettings, IPEndPoint, String) Creates a new IEventStoreConnection to single node using specific ConnectionSettings Declaration public static IEventStoreConnection Create(ConnectionSettings connectionSettings, IPEndPoint tcpEndPoint, string connectionName = null) Parameters Type Name ConnectionSettings connectionSettings System.Net.IPEndPoint tcpEndPoint System.String connectionName Returns Type Description IEventStoreConnection a new IEventStoreConnection Create(ConnectionSettings, String) Creates a new IEventStoreConnection using the gossip seeds specified in the connectionSettings Declaration public static IEventStoreConnection Create(ConnectionSettings connectionSettings, string connectionName = null) Parameters Type Name ConnectionSettings connectionSettings System.String connectionName Returns Type Description IEventStoreConnection a new IEventStoreConnection Create(ConnectionSettings, Uri, String) Creates a new IEventStoreConnection Declaration public static IEventStoreConnection Create(ConnectionSettings connectionSettings, Uri uri, string connectionName = null) Parameters Type Name ConnectionSettings connectionSettings System.Uri uri System.String connectionName Returns Type Description IEventStoreConnection a new IEventStoreConnection Remarks You must pass a uri or set gossip seeds in the connection settings. Create(IPEndPoint, String) Creates a new IEventStoreConnection to single node using default ConnectionSettings Declaration public static IEventStoreConnection Create(IPEndPoint tcpEndPoint, string connectionName = null) Parameters Type Name System.Net.IPEndPoint tcpEndPoint System.String connectionName Returns Type Description IEventStoreConnection a new IEventStoreConnection Create(String, ConnectionSettingsBuilder, String) Creates a new IEventStoreConnection to single node using default ConnectionSettings provided via a connectionstring Declaration public static IEventStoreConnection Create(string connectionString, ConnectionSettingsBuilder builder, string connectionName = null) Parameters Type Name System.String connectionString ConnectionSettingsBuilder builder System.String connectionName Returns Type Description IEventStoreConnection a new IEventStoreConnection Create(String, String) Creates a new IEventStoreConnection to single node using default ConnectionSettings provided via a connectionstring Declaration public static IEventStoreConnection Create(string connectionString, string connectionName = null) Parameters Type Name System.String connectionString System.String connectionName Returns Type Description IEventStoreConnection a new IEventStoreConnection Create(Uri, String) Creates a new IEventStoreConnection to single node using default ConnectionSettings Declaration public static IEventStoreConnection Create(Uri uri, string connectionName = null) Parameters Type Name System.Uri uri System.String connectionName Returns Type Description IEventStoreConnection a new IEventStoreConnection"
  }
}